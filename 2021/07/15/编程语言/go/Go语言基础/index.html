<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    
    <title>golang语言基础 | Dawnyh&#39;s Blog</title>

    <meta name="description" content="Dawnyh&#39;s Blog">
    <meta name="keywords" content="">

    

    <meta property="og:locale" content="zh-CN" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content= "golang语言基础 | Dawnyh&#39;s Blog"  />
    <meta property="og:description" content= "Dawnyh&#39;s Blog" />
    <meta property="og:url" content="http://dawnyh99.github.io/2021/07/15/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/index.html" />
    <meta property="og:site_name" content="" />
    <meta property="article:author" content="Dawnyh" />
    <meta property="article:publisher" content="" />
    <meta property="og:description" content="Dawnyh&#39;s Blog" />
    <meta name="twitter:title" content="golang语言基础 | Dawnyh&#39;s Blog"/>
    <meta name="twitter:description" content="Dawnyh&#39;s Blog"/>
    <script type="application/ld+json">
        {
            "description": "Dawnyh&#39;s Blog",
            "author": { "@type": "Person", "name": "Dawnyh" },
            "@type": "BlogPosting",
            "url": "http://dawnyh99.github.io/2021/07/15/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/index.html",
            "publisher": {
            "@type": "Organization",
            "logo": {
                "@type": "ImageObject",
                "url": "http://dawnyh99.github.ioundefined"
            },
            "name": "Dawnyh"
            },
            "headline": "golang语言基础 | Dawnyh&#39;s Blog",
            "datePublished": "2021-07-14T16:00:00.000Z",
            "mainEntityOfPage": {
                "@type": "WebPage",
                "@id": "http://dawnyh99.github.io/2021/07/15/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/index.html"
            },
            "@context": "http://schema.org"
        }
    </script>




    

    

    

    

    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1654266144177.css">


    
<link rel="stylesheet" href="/dist/custom.css?v=1654266144177.css">


    <script>
        window.isPost = true
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = false
        window.aomori_search_algolia = false

    </script>

<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Dawnyh's Blog" type="application/atom+xml">
</head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-inner">
                
                    <a class="header-type-title" href="/">Dawnyh&#39;s Blog</a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
            </div>
            <div class="header-menu-social">
                
            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="post">
    <article id="post-clc9gad8e004j4ctl7sclgpyg" class="article article-type-post" itemscope
    itemprop="blogPost">

    <div class="article-inner">

        
          
        
        
        

        
        <header class="article-header">
            
  
    <h1 class="article-title" itemprop="name">
      golang语言基础
    </h1>
  

        </header>
        

        <div class="article-more-info article-more-info-post hairline">

            <div class="article-date">
  <time datetime="2021-07-14T16:00:00.000Z" itemprop="datePublished">2021-07-15</time>
</div>

            
            <div class="article-category">
                <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
            </div>
            

            
            <div class="article-tag">
                <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go/" rel="tag">go</a></li></ul>
            </div>
            

            

        </div>

        <div class="article-entry post-inner-html hairline" itemprop="articleBody">
            <h2 id="变量"><a class="header-anchor" href="#变量"></a>变量</h2>
<h3 id="定义变量"><a class="header-anchor" href="#定义变量"></a>定义变量</h3>
<pre><code class="language-go">//定义一个名称为“variableName”，类型为&quot;type&quot;的变量
var variableName type

//定义三个类型都是“type”的变量
var vname1, vname2, vname3 type

//初始化“variableName”的变量为“value”值，类型是“type”
var variableName type = value

/*
    定义三个类型都是&quot;type&quot;的变量,并且分别初始化为相应的值
    vname1为v1，vname2为v2，vname3为v3
*/
var vname1, vname2, vname3 type = v1, v2, v3

/*
    定义三个变量，它们分别初始化为相应的值
    vname1为v1，vname2为v2，vname3为v3
    然后Go会根据其相应值的类型来帮你初始化它们
*/
var vname1, vname2, vname3 = v1, v2, v3

/*
    :=这个符号直接取代了var和type,这种形式叫做简短声明。不过它有一个限制，那就是它只能用     在函数内部；在函数外部使用则会无法编译通过，所以一般用var方式来定义全局变量
*/
vname1, vname2, vname3 := v1, v2, v3

/*
	_（下划线）是个特殊的变量名，任何赋予它的值都会被丢弃。在这个例子中，我们将值35赋予     b，并同时丢弃34：
*/
_, b := 34, 35

</code></pre>
<p>Go对于已声明但未使用的变量会在编译阶段报错</p>
<h3 id="变量类型"><a class="header-anchor" href="#变量类型"></a>变量类型</h3>
<h4 id="Boolean"><a class="header-anchor" href="#Boolean"></a>Boolean</h4>
<p>在Go中，布尔值的类型为<code>bool</code>，值是<code>true</code>或<code>false</code>，默认为<code>false</code></p>
<pre><code class="language-go">//示例代码
var isActive bool  // 全局变量声明
var enabled, disabled = true, false  // 忽略类型的声明
func test() {
    var available bool  // 一般声明
    valid := false      // 简短声明
    available = true    // 赋值操作
}
</code></pre>
<h4 id="数值型"><a class="header-anchor" href="#数值型"></a>数值型</h4>
<p>整数类型有无符号和带符号两种。Go同时支持<code>int</code>和<code>uint</code>，这两种类型的长度相同，但具体长度取决于不同编译器的实现。Go里面也有直接定义好位数的类型：<code>rune</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>和<code>byte</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>。其中<code>rune</code>是<code>int32</code>的别称，<code>byte</code>是<code>uint8</code>的别称。</p>
<blockquote>
<p>需要注意的一点是，这些类型的变量之间不允许互相赋值或操作，不然会在编译时引起编译器报错</p>
<p>另外，尽管int的长度是32 bit, 但int 与 int32并不可以互用。</p>
</blockquote>
<p>浮点数的类型有<code>float32</code>和<code>float64</code>两种（没有<code>float</code>类型），默认是<code>float64</code></p>
<h4 id="字符串"><a class="header-anchor" href="#字符串"></a>字符串</h4>
<p>Go中的字符串都是采用<code>UTF-8</code>字符集编码。字符串是用一对双引号（&quot;&quot;）或反引号（``）括起来定义，它的类型是<code>string</code></p>
<p>在Go中字符串是不可变的，例如下面的代码编译时会报错：cannot assign to s[0]</p>
<pre><code class="language-go">var s string = &quot;hello&quot;
s[0] = 'c'
</code></pre>
<p>如果真的想要修改怎么办呢？下面的代码可以实现</p>
<pre><code class="language-go">s := &quot;hello&quot;
c := []byte(s)  // 将字符串 s 转换为 []byte 类型
c[0] = 'c'
s2 := string(c)  // 再转换回 string 类型
fmt.Printf(&quot;%s\n&quot;, s2)
</code></pre>
<p>Go中可以使用<code>+</code>操作符来连接两个字符串</p>
<p>修改字符串也可写为：</p>
<pre><code class="language-go">s := &quot;hello&quot;
s = &quot;c&quot; + s[1:] // 字符串虽不能更改，但可进行切片操作
fmt.Printf(&quot;%s\n&quot;, s)
</code></pre>
<p>如果要声明一个多行的字符串怎么办？可以通过反引号（``）来声明：</p>
<pre><code class="language-go">m := `hello
    world`
</code></pre>
<p>(``) 括起的字符串为Raw字符串，即字符串在代码中的形式就是打印时的形式，它没有字符转义，换行也将原样输出。例如本例中会输出：</p>
<pre><code>hello
    world
</code></pre>
<h4 id="错误类型"><a class="header-anchor" href="#错误类型"></a>错误类型</h4>
<p>Go内置有一个<code>error</code>类型，专门用来处理错误信息，Go的<code>package</code>里面还专门有一个包<code>errors</code>来处理错误</p>
<pre><code class="language-go">err := errors.New(&quot;emit macho dwarf: elf header corrupted&quot;)
if err != nil {  //nil 是 map、slice、pointer、channel、func、interface 的零值
    fmt.Print(err)
}
</code></pre>
<h4 id="类型转换"><a class="header-anchor" href="#类型转换"></a>类型转换</h4>
<pre><code class="language-go">// type_name(expression) 将 expression 转化为 type_name 类型
var sum int = 17
var count int =5
var mean float32
mean = float32(sum)/float32(count)
fmt.Printf(&quot;mean 的值为：%f\n&quot;,mean)
</code></pre>
<h3 id="常量"><a class="header-anchor" href="#常量"></a>常量</h3>
<p>常量也就是在程序编译阶段就确定下来的值，而程序在运行时无法改变该值。在Go程序中，常量可定义为数值、布尔值或字符串等类型。</p>
<pre><code class="language-go">const constantName = value
//如果需要，也可以明确指定常量的类型：
const Pi float32 = 3.1415926
</code></pre>
<h3 id="分组声明"><a class="header-anchor" href="#分组声明"></a>分组声明</h3>
<p>在Go语言中，同时声明多个常量、变量，或者导入多个包时，可采用分组的方式进行声明</p>
<p>例如下面的代码：</p>
<pre><code class="language-go">import &quot;fmt&quot;
import &quot;os&quot;

const i = 100
const pi = 3.1415
const prefix = &quot;Go_&quot;

var i int
var pi float32
var prefix string
</code></pre>
<p>可以分组写成如下形式：</p>
<pre><code class="language-go">import(
    &quot;fmt&quot;
    &quot;os&quot;
)

const(
    i = 100
    pi = 3.1415
    prefix = &quot;Go_&quot;
)

var(
    i int
    pi float32
    prefix string
)
</code></pre>
<h2 id="运算符"><a class="header-anchor" href="#运算符"></a>运算符</h2>
<p>go的运算符和C相同</p>
<p>算术运算符</p>
<p>关系运算符</p>
<p>逻辑运算符</p>
<p>位运算符——<code>&amp;</code>（与）、<code>|</code>（或）、<code>^</code>（异或）</p>
<h2 id="array、slice、map"><a class="header-anchor" href="#array、slice、map"></a>array、slice、map</h2>
<h3 id="array"><a class="header-anchor" href="#array"></a>array</h3>
<p><code>array</code>就是数组，它的定义方式如下：</p>
<pre><code class="language-go">var arr [n]type
</code></pre>
<p>在<code>[n]type</code>中，<code>n</code>表示数组的长度，<code>type</code>表示存储元素的类型。对数组的操作和其它语言类似，都是通过<code>[]</code>来进行读取或赋值：</p>
<pre><code class="language-go">var arr [10]int  // 声明了一个int类型的数组
arr[0] = 42      // 数组下标是从0开始的
arr[1] = 13      // 赋值操作
fmt.Printf(&quot;The first element is %d\n&quot;, arr[0])  // 获取数据，返回42
fmt.Printf(&quot;The last element is %d\n&quot;, arr[9]) //返回未赋值的最后一个元素，默认返回0
</code></pre>
<p>由于长度也是数组类型的一部分，因此<code>[3]int</code>与<code>[4]int</code>是不同的类型，数组也就不能改变长度。数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该数组的副本，而不是它的指针。如果要使用指针，那么就需要用到后面介绍的<code>slice</code>类型了。</p>
<p>数组同样可以使用<code>:=</code>进行简短声明</p>
<pre><code class="language-go">a := [3]int{1, 2, 3} // 声明了一个长度为3的int数组

b := [10]int{1, 2, 3} // 声明了一个长度为10的int数组，其中前三个元素初始化为1、2、3，其它默认为0

c := [...]int{4, 5, 6} // 可以省略长度而采用`...`的方式，Go会自动根据元素个数来计算长度
</code></pre>
<pre><code class="language-go">// 声明了一个二维数组，该数组以两个数组作为元素，其中每个数组中又有4个int类型的元素
doubleArray := [2][4]int{[4]int{1, 2, 3, 4}, [4]int{5, 6, 7, 8}}

// 上面的声明可以简化，直接忽略内部的类型
easyArray := [2][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}}
</code></pre>
<p><img src="/2021/07/15/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/2.2.array.png" alt="img"></p>
<h3 id="slice"><a class="header-anchor" href="#slice"></a>slice</h3>
<p>在很多应用场景中，数组并不能满足我们的需求。在初始定义数组时，我们并不知道需要多大的数组，因此我们就需要“动态数组”。在Go里面这种数据结构叫<code>slice</code></p>
<p><code>slice</code>并不是真正意义上的动态数组，而是一个引用类型。<code>slice</code>总是指向一个底层<code>array</code>，<code>slice</code>的声明也可以像<code>array</code>一样，只是不需要长度。</p>
<pre><code class="language-go">// 和声明array一样，只是少了长度
var fslice []int
</code></pre>
<p><code>slice</code>可以从一个数组或一个已经存在的<code>slice</code>中再次声明。<code>slice</code>通过<code>array[i:j]</code>来获取，其中<code>i</code>是数组的开始位置，<code>j</code>是结束位置，但不包含<code>array[j]</code>，它的长度是<code>j-i</code>。</p>
<pre><code class="language-go">// 声明一个含有10个元素元素类型为byte的数组
var ar = [10]byte {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}

// 声明两个含有byte的slice
var a, b []byte

// a指向数组的第3个元素开始，并到第五个元素结束，
a = ar[2:5]
//现在a含有的元素: ar[2]、ar[3]和ar[4]

// b是数组ar的另一个slice
b = ar[3:5]
// b的元素是：ar[3]和ar[4]
</code></pre>
<p><img src="/2021/07/15/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/2.2.slice.png" alt="img"></p>
<blockquote>
<p>注意<code>slice</code>和数组在声明时的区别：声明数组时，方括号内写明了数组的长度或使用<code>...</code>自动计算长度，而声明<code>slice</code>时，方括号内没有任何字符。</p>
</blockquote>
<p><code>slice</code>是引用类型，所以当引用改变其中元素的值时，其它的所有引用都会改变该值，例如上面的<code>aSlice</code>和<code>bSlice</code>，如果修改了<code>bSlice</code>中元素的值，那么<code>aSlice</code>相对应的值也会改变。</p>
<p>对于<code>slice</code>有几个有用的内置函数：</p>
<ul>
<li><code>len</code> 获取<code>slice</code>的长度</li>
<li><code>cap</code> 获取<code>slice</code>的最大容量</li>
<li><code>append</code> 向<code>slice</code>里面追加一个或者多个元素，然后返回一个和<code>slice</code>一样类型的<code>slice</code></li>
<li><code>copy</code> 函数<code>copy</code>从源<code>slice</code>的<code>src</code>中复制元素到目标<code>dst</code>，并且返回复制的元素的个数</li>
</ul>
<pre><code class="language-go">leng := len(slice_a)
slice_b := append(slice_a, 'l')
</code></pre>
<p>注：<code>append</code>函数会改变<code>slice</code>所引用的数组的内容，从而影响到引用同一数组的其它<code>slice</code>。 但当<code>slice</code>中没有剩余空间（即<code>(cap-len) == 0</code>）时，此时将动态分配新的数组空间。返回的<code>slice</code>数组指针将指向这个空间，而原数组的内容将保持不变；其它引用此数组的<code>slice</code>则不受影响。</p>
<h3 id="map"><a class="header-anchor" href="#map"></a>map</h3>
<p><code>map</code>也就是Python中字典的概念，它的格式为<code>map[keyType]valueType</code></p>
<p>我们看下面的代码，<code>map</code>的读取和设置也类似<code>slice</code>一样，通过<code>key</code>来操作，只是<code>slice</code>的<code>index</code>只能是<code>int</code>类型，而<code>map</code>多了很多类型，可以是<code>int</code>，可以是<code>string</code>及所有完全定义了<code>==</code>与<code>!=</code>操作的类型。</p>
<pre><code class="language-go">// 声明一个key是字符串，值为int的字典,这种方式的声明需要在使用之前使用make初始化
var numbers map[string]int
numbers = make(map[string]int)

// 另一种map的声明方式
numbers := make(map[string]int)
numbers[&quot;one&quot;] = 1  //赋值
numbers[&quot;ten&quot;] = 10 //赋值
numbers[&quot;three&quot;] = 3

fmt.Println(&quot;第三个数字是: &quot;, numbers[&quot;three&quot;]) // 读取数据
// 打印出来如:第三个数字是: 3
</code></pre>
<p>这个<code>map</code>就像我们平常看到的表格一样，左边列是<code>key</code>，右边列是值</p>
<p>使用map过程中需要注意的几点：</p>
<ul>
<li><code>map</code>是无序的，每次打印出来的<code>map</code>都会不一样，它不能通过<code>index</code>获取，而必须通过<code>key</code>获取</li>
<li><code>map</code>的长度是不固定的，也就是和<code>slice</code>一样，也是一种引用类型</li>
<li>内置的<code>len</code>函数同样适用于<code>map</code>，返回<code>map</code>拥有的<code>key</code>的数量</li>
<li><code>map</code>的值可以很方便的修改，通过<code>numbers[&quot;one&quot;]=11</code>可以很容易的把key为<code>one</code>的字典值改为<code>11</code></li>
<li><code>map</code>和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制</li>
</ul>
<p><code>map</code>的初始化可以通过<code>key:val</code>的方式初始化值，同时<code>map</code>内置有判断是否存在<code>key</code>的方式</p>
<p>通过<code>delete</code>删除<code>map</code>的元素：</p>
<pre><code class="language-go">// 初始化一个字典
rating := map[string]float32{&quot;C&quot;:5, &quot;Go&quot;:4.5, &quot;Python&quot;:4.5, &quot;C++&quot;:2 }
// map有两个返回值，第二个返回值，如果不存在key，那么ok为false，如果存在ok为true
csharpRating, ok := rating[&quot;C#&quot;]
if ok {
    fmt.Println(&quot;C# is in the map and its rating is &quot;, csharpRating)
} else {
    fmt.Println(&quot;We have no rating associated with C# in the map&quot;)
}

delete(rating, &quot;C&quot;)  // 删除key为C的元素
</code></pre>
<p>上面说过了，<code>map</code>也是一种引用类型，如果两个<code>map</code>同时指向一个底层，那么一个改变，另一个也相应的改变：</p>
<pre><code class="language-go">m := make(map[string]string)
m[&quot;Hello&quot;] = &quot;Bonjour&quot;
m1 := m
m1[&quot;Hello&quot;] = &quot;Salut&quot;  // 现在m[&quot;hello&quot;]的值已经是Salut了
</code></pre>
<h3 id="遍历"><a class="header-anchor" href="#遍历"></a>遍历</h3>
<p>Go语言中<code>range</code>关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。返回索引值和索引对应位置的值</p>
<h2 id="分配存储空间"><a class="header-anchor" href="#分配存储空间"></a>分配存储空间</h2>
<p><code>make</code>用于内建类型（<code>map</code>、<code>slice</code> 和<code>channel</code>）的内存分配。<code>new</code>用于各种类型的内存分配。</p>
<h3 id="make"><a class="header-anchor" href="#make"></a>make</h3>
<pre><code class="language-go">func make(t Type, size ...IntegerType) Type
</code></pre>
<p><code>make</code>返回一个<code>Type</code>类型的值，返回值取决于<code>Type</code></p>
<pre><code class="language-go">//如下声明一个slice，得到一个length为0，cap为10的slice
slice1 := make([]int, 0, 10)
//此时需要我们自行使用 append 向 slice1 中添加数据
</code></pre>
<h3 id="new"><a class="header-anchor" href="#new"></a>new</h3>
<pre><code class="language-go">func new(Type) *Type
</code></pre>
<p><code>new</code>返回的是<code>*Type</code>类型指针，指针指向由零值填充的<code>Type</code>类型的内存空间</p>
<h3 id="零值"><a class="header-anchor" href="#零值"></a>零值</h3>
<p>“零值”所指并非空值，而是一种“变量未填充前”的默认值，通常为0。 此处罗列部分类型的“零值”</p>
<pre><code>int     0
int8    0
int32   0
int64   0
uint    0x0
rune    0 //rune的实际类型是 int32
byte    0x0 // byte的实际类型是 uint8
float32 0 //长度为 4 byte
float64 0 //长度为 8 byte
bool    false
string  &quot;&quot;
</code></pre>
<h2 id="流程控制"><a class="header-anchor" href="#流程控制"></a>流程控制</h2>
<h3 id="条件判断"><a class="header-anchor" href="#条件判断"></a>条件判断</h3>
<p>Go里面<code>if</code>条件判断语句中不需要括号，如下代码所示</p>
<pre><code class="language-go">if x &gt; 10 {
    fmt.Println(&quot;x is greater than 10&quot;)
} else {
    fmt.Println(&quot;x is less than 10&quot;)
}
</code></pre>
<p>多个条件的时候如下所示：</p>
<pre><code class="language-go">if integer == 3 {
    fmt.Println(&quot;The integer is equal to 3&quot;)
} else if integer &lt; 3 {
    fmt.Println(&quot;The integer is less than 3&quot;)
} else {
    fmt.Println(&quot;The integer is greater than 3&quot;)
}
</code></pre>
<p>Go中也有<code>switch-case</code>，特别之处是Go默认每个case后带有一个<code>break</code>，所以不需要我们自己添加<code>break</code>，但是可以使用<code>fallthrough</code>强制执行后面的case代码；</p>
<p>另外，case 后的表达式非常灵活，可以为数值、字符串或者其他表达式</p>
<pre><code class="language-go">switch sExpr {
case expr1:
    some instructions
    fallthrough
case expr2:
    some other instructions
case expr3:
    some other instructions
default:
    other code
}
</code></pre>
<h3 id="循环控制"><a class="header-anchor" href="#循环控制"></a>循环控制</h3>
<p>Go里面最强大的一个控制逻辑就是<code>for</code>，它即可以用来循环读取数据，又可以当作<code>while</code>来控制逻辑，还能迭代操作。它的语法如下：</p>
<pre><code class="language-go">for expression1; expression2; expression3 {
    //...
}
</code></pre>
<p><code>expression1</code>、<code>expression2</code>和<code>expression3</code>都是表达式，其中<code>expression1</code>和<code>expression3</code>是变量声明或者函数调用返回值之类的，<code>expression2</code>是用来条件判断，<code>expression1</code>在循环开始之前调用，<code>expression3</code>在每轮循环结束之时调用。</p>
<p>一个例子比上面讲那么多更有用，那么我们看看下面的例子吧：</p>
<pre><code class="language-go">package main
import &quot;fmt&quot;

func main(){
    sum := 0;
    for index:=0; index &lt; 10 ; index++ {
        sum += index
    }
    fmt.Println(&quot;sum is equal to &quot;, sum)
}
// 输出：sum is equal to 45
</code></pre>
<p>有些时候需要进行多个赋值操作，由于Go里面没有<code>,</code>操作符，那么可以使用平行赋值<code>i, j = i+1, j-1</code></p>
<p>有些时候如果我们忽略<code>expression1</code>和<code>expression3</code>：</p>
<pre><code class="language-go">sum := 1
for ; sum &lt; 1000;  {
    sum += sum
}
</code></pre>
<p>其中<code>;</code>也可以省略，那么就变成如下的代码了，是不是似曾相识？对，这就是<code>while</code>的功能。</p>
<pre><code class="language-go">sum := 1
for sum &lt; 1000 {
    sum += sum
}
</code></pre>
<p>在循环里面有两个关键操作<code>break</code>和<code>continue</code> ,<code>break</code>操作是跳出当前循环，<code>continue</code>是跳过本次循环。当嵌套过深的时候，<code>break</code>和<code>continue</code>还可以跟着标号，配合标签使用，即跳转至标签所指定的位置，详细参考如下例子：</p>
<pre><code class="language-go">for index := 10; index&gt;0; index-- {
    if index == 5{
        break // 或者continue
    }
    fmt.Println(index)
}
// break打印出来10、9、8、7、6
// continue打印出来10、9、8、7、6、4、3、2、1
</code></pre>
<p><code>for</code>配合<code>range</code>可以用于读取<code>slice</code>和<code>map</code>的数据：</p>
<pre><code class="language-go">for k,v:=range map {
    fmt.Println(&quot;map's key:&quot;,k)
    fmt.Println(&quot;map's val:&quot;,v)
}
</code></pre>
<p>由于 Go 支持 “多值返回”, 而对于“声明而未被调用”的变量, 编译器会报错, 在这种情况下, 可以使用<code>_</code>来丢弃不需要的返回值 例如</p>
<pre><code class="language-go">for _, v := range map{
    fmt.Println(&quot;map's val:&quot;, v)
}
</code></pre>
<h3 id="无条件跳转"><a class="header-anchor" href="#无条件跳转"></a>无条件跳转</h3>
<p>Go有<code>goto</code>语句，可以用<code>goto</code>跳转到必须在当前函数内定义的标签。例如假设这样一个循环：</p>
<pre><code class="language-go">func myFunc() {
    i := 0
Here:   //这行的第一个词，以冒号结束作为标签
    println(i)
    i++
    goto Here   //跳转到Here去
}
</code></pre>
<blockquote>
<p>标签名是大小写敏感的。</p>
</blockquote>
<h2 id="import"><a class="header-anchor" href="#import"></a>import</h2>
<p>我们在写Go代码的时候经常用到import这个命令用来导入包文件，而我们经常看到的方式参考如下：</p>
<pre><code>import(
    &quot;fmt&quot;
)
</code></pre>
<p>然后我们代码里面可以通过如下的方式调用</p>
<pre><code>fmt.Println(&quot;hello world&quot;)
</code></pre>
<p>上面这个fmt是Go语言的标准库，其实是去<code>GOROOT</code>环境变量指定目录下去加载该模块，当然Go的import还支持如下两种方式来加载自己写的模块：</p>
<p>1.相对路径</p>
<p>import “./myModule” //当前文件同一目录的myModule目录，但是不建议这种方式来import</p>
<p>2.绝对路径</p>
<p>import “shorturl/model” //加载gopath/src/shorturl/model模块</p>
<p>上面展示了一些import常用的几种方式，但是还有一些特殊的import，让很多新手很费解，下面我们来一一讲解一下到底是怎么一回事</p>
<p>1.点操作</p>
<p>我们有时候会看到如下的方式导入包</p>
<pre><code class="language-go">  import(
      . &quot;fmt&quot;
  )
</code></pre>
<p>这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名，也就是前面你调用的fmt.Println(“hello world”)可以省略的写成Println(“hello world”)</p>
<p>2.别名操作</p>
<p>别名操作顾名思义我们可以把包命名成另一个我们用起来容易记忆的名字</p>
<pre><code class="language-go">  import(
      f &quot;fmt&quot;
  )
</code></pre>
<p>别名操作的话调用包函数时前缀变成了我们的前缀，即f.Println(“hello world”)</p>
<p>3._操作</p>
<p>这个操作经常是让很多人费解的一个操作符，请看下面这个import</p>
<pre><code class="language-go">  import (
      &quot;database/sql&quot;
      _ &quot;github.com/ziutek/mymysql/godrv&quot;
  )
</code></pre>
<p>_操作其实是引入该包，而不直接使用包里面的函数，而是调用了该包里面的init函数。</p>
<h2 id="函数"><a class="header-anchor" href="#函数"></a>函数</h2>
<p>函数声明</p>
<pre><code class="language-go">func funcName(input1 type1, input2 type2) (output1 type1, output2 type2) {
    //这里是处理逻辑代码
    //返回多个值
    //output1 和 output2 已在上方定义，这里可以省略，只写return
    return output1,output2
}
</code></pre>
<blockquote>
<p>golang 的函数可以返回多个值</p>
<p>input 的 type1 和 type2 相同时，可以只写一个</p>
<p>output 可以省略变量名，只写类型</p>
<p>只有一个 output 时可以省略括号</p>
<p>没有output时就直接省略最后的返回信息</p>
</blockquote>
<h3 id="变参"><a class="header-anchor" href="#变参"></a>变参</h3>
<p>Go函数支持变参。接受变参的函数是有着不定数量的参数的。为了做到这点，首先需要定义函数使其接受变参</p>
<pre><code class="language-go">func myfunc(arg ...int) {}
</code></pre>
<p><code>arg ...int</code>告诉Go这个函数接受不定数量的参数。注意，这些参数的类型全部是<code>int</code>。在函数体中，变量<code>arg</code>是一个<code>int</code>的<code>slice</code></p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func myfunc(arg ...int) (int,int) {
	sum := 0
	for _,a:=range arg {
		sum += a
		fmt.Printf(&quot;a is %d,sum is %d\n&quot;,a,sum)
	}
	return sum, 1
}

func main() {
	var slice1 []int
	slice1 = append(slice1,1,2,3,4,5,6,7)
	sum,_ := myfunc(1,2,3,4,5,6,7,8,9,10)
	fmt.Printf(&quot;sum from 1 to 10 is %d\n&quot;, sum)
}
</code></pre>
<h3 id="函数作为值、类型"><a class="header-anchor" href="#函数作为值、类型"></a>函数作为值、类型</h3>
<pre><code class="language-go">type testInt func(int) bool  // 声明了一个函数类型
</code></pre>
<pre><code class="language-go">// 声明的函数类型在这个地方当做了一个参数
func filter(slice []int, f testInt) []int {
    var result []int
    for _, value := range slice {
        if f(value) {
            result = append(result, value)
        }
    }
    return result
}
</code></pre>
<p>函数作为参数传递，在使用上较为灵活，在一些通用接口的开发上也非常有效</p>
<h2 id="指针"><a class="header-anchor" href="#指针"></a>指针</h2>
<p>用法与C中的指针差不多</p>
<p><code>&amp;</code>用于取地址</p>
<p><code>*</code>获取指针指向的值</p>
<h2 id="结构体"><a class="header-anchor" href="#结构体"></a>结构体</h2>
<h3 id="定义结构体"><a class="header-anchor" href="#定义结构体"></a>定义结构体</h3>
<pre><code class="language-go">type struct_variable_type struct {
   member definition;
   member definition;
   ...
   member definition;
}
</code></pre>
<h3 id="访问结构体成员"><a class="header-anchor" href="#访问结构体成员"></a>访问结构体成员</h3>
<p>结构体变量或结构体指针都使用<code>.</code>操作符访问结构体成员</p>
<h3 id="method"><a class="header-anchor" href="#method"></a>method</h3>
<p>在定义函数的时候可以为其指定一个<code>receiver</code>，即该函数属于某一个结构体</p>
<pre><code class="language-go">type struct1 struct {

}
func (s1 struct1) test() {
   fmt.Printf(&quot;ahh&quot;)
}

func main() {
   var str1 struct1
   str1.test()   //输出&quot;ahh&quot;
}
</code></pre>
<p><code>struct</code>+<code>method</code>==<code>class</code></p>
<p>method不止能用于结构体，还能用于任何其他的自定义类型,比如：</p>
<pre><code class="language-go">type months map[string]int
func (mon months) test() {
   fmt.Printf(&quot;ahh&quot;)
}
</code></pre>
<h2 id="接口"><a class="header-anchor" href="#接口"></a>接口</h2>
<p>定义方法</p>
<pre><code class="language-go">/* 定义接口 */
type interface_name interface {
   method_name1 [return_type]
   method_name2 [return_type]
   method_name3 [return_type]
   //...
   method_namen [return_type]
}

/* 定义结构体 */
type struct_name struct {
   /* variables */
}

/* 实现接口方法 */
func (struct_name_variable struct_name) method_name1() [return_type] {
   /* 方法实现 */
}
//...
func (struct_name_variable struct_name) method_namen() [return_type] {
   /* 方法实现*/
}
</code></pre>
<p>实例如下</p>
<pre><code class="language-go">type interface1 interface{
   test()
}
type struct1 struct {

}
func (s1 struct1) test() {
   fmt.Printf(&quot;ahh&quot;)
}

func main() {
   var inter interface1
   inter = new(struct1)
   inter.test()
}
</code></pre>
<p>通过接口，我们就可以使用一个接口来调用多个不同的方法</p>
<h2 id="特性"><a class="header-anchor" href="#特性"></a>特性</h2>
<h3 id="defer"><a class="header-anchor" href="#defer"></a>defer</h3>
<p>defer 语句在函数结束前执行，常用于资源回收</p>
<p>当有多个 defer 语句时，由后向前执行</p>
<pre><code class="language-go">func ReadWrite() bool {
    file.Open(&quot;file&quot;)
    defer file.Close()
    if failureX {
        return false
    }
    if failureY {
        return false
    }
    return true
}
</code></pre>
<h3 id="Panic和Recover"><a class="header-anchor" href="#Panic和Recover"></a>Panic和Recover</h3>
<p>panic用于产生一个异常，recover()位于defer语句中，用于捕获异常信息并从异常中恢复</p>
<pre><code class="language-go">func main() {
   defer func() {
      err := recover()
      if err != nil {
         fmt.Println(&quot;程序运行中出现异常：&quot;, err)
      }
   }()
   panic(&quot;test panic&quot;)

}
</code></pre>
<h3 id="error"><a class="header-anchor" href="#error"></a>error</h3>
<p><code>error</code>是系统自带的一个接口类型的自定义类型，<code>errors</code> 包中包含了一个实现了 <code>error</code> 这个接口的结构体类型 <code>errorString</code>，我们可以直接使用包中的方法来自定义一些错误，从而返回我们希望被上层代码处理的错误信息</p>
<pre><code class="language-go">package main

import (
    &quot;errors&quot;
    &quot;fmt&quot;
)

func main() {
    t, err := divide(2, 0)
    if err != nil {
        fmt.Println(err)
    } else {
        fmt.Println(t)
    }
}

func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New(&quot;除数不能为0&quot;)
    }
    return a / b, nil
}
</code></pre>

        </div>

    </div>

    

    

    

    

    

    
<nav class="article-nav">
  
    <a href="/2021/07/17/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/Go%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-caption">下一篇</div>
      <div class="article-nav-title">
        
          golang项目结构
        
      </div>
    </a>
  
  
    <a href="/2021/07/14/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/Go%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-caption">上一篇</div>
      <div class="article-nav-title">golang的安装配置</div>
    </a>
  
</nav>


    <section class="share">
        <div class="share-title">分享</div>
        <a class="share-item" target="_blank"
            href="https://twitter.com/share?text=golang语言基础 - Dawnyh's Blog&url=http%3A%2F%2Fdawnyh99.github.io%2F2021%2F07%2F15%2F%25E7%25BC%2596%25E7%25A8%258B%25E8%25AF%25AD%25E8%25A8%2580%2Fgo%2FGo%25E8%25AF%25AD%25E8%25A8%2580%25E5%259F%25BA%25E7%25A1%2580%2F">
            <ion-icon name="logo-twitter"></ion-icon>
        </a>
        <a class="share-item" target="_blank"
            href="https://www.facebook.com/sharer.php?title=golang语言基础 - Dawnyh's Blog&u=http%3A%2F%2Fdawnyh99.github.io%2F2021%2F07%2F15%2F%25E7%25BC%2596%25E7%25A8%258B%25E8%25AF%25AD%25E8%25A8%2580%2Fgo%2FGo%25E8%25AF%25AD%25E8%25A8%2580%25E5%259F%25BA%25E7%25A1%2580%2F">
            <ion-icon name="logo-facebook"></ion-icon>
        </a>
        <!-- <a class="share-item" target="_blank"
            href="https://service.weibo.com/share/share.php?title=golang语言基础 - Dawnyh's Blog&url=http://dawnyh99.github.io/2021/07/15/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/&pic=">
            <div class="n-icon n-icon-weibo"></div>
        </a> -->
    </section>

</article>
















</div>
                </section>
            </section>

            
            <aside class="sidebar ">
                


<div class="widget" id="widget">
    
      
  <div class="widget-wrap">
    <div class="widget-inner">
      <div class="toc post-toc-html"></div>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-cate">
    <div class="widget-title"><span>Categories</span></div>
    <div class="widget-inner">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CTF/">CTF</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/CTF/web/">web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CTF/%E6%9D%82%E9%A1%B9/">杂项</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/">专业课</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%BD%91/">计网</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/Markdown/">Markdown</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/docker/">docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E8%AE%B0/">杂记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B8%97%E9%80%8F/">渗透</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">环境配置</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/">go</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%BB%B4/">运维</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/" rel="tag">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GUI/" rel="tag">GUI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Misc/" rel="tag">Misc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSH/" rel="tag">SSH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XSS/" rel="tag">XSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/" rel="tag">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/" rel="tag">kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kali/" rel="tag">kali</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/" rel="tag">sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sqli/" rel="tag">sqli</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" rel="tag">代码审计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%9E%E9%AA%8C/" rel="tag">实验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" rel="tag">密码学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" rel="tag">文件上传</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/" rel="tag">文件包含</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BC%8F%E6%B4%9E/" rel="tag">漏洞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" rel="tag">环境配置</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%90%E7%BB%B4/" rel="tag">运维</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/2022/12/27/%E5%B7%A5%E5%85%B7/redis/">Redis笔记</a>
          </li>
        
          <li>
            <a href="/2022/11/03/%E6%9D%82%E8%AE%B0/%E5%B7%B2%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F%EF%BC%88%E6%9C%8D%E5%8A%A1%EF%BC%89%E7%9A%84%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F/">已安装程序（服务）的运行方式</a>
          </li>
        
          <li>
            <a href="/2022/07/13/%E6%BC%8F%E6%B4%9E/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/">漏洞/Java反序列化漏洞</a>
          </li>
        
          <li>
            <a href="/2021/08/09/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/">密码算法</a>
          </li>
        
          <li>
            <a href="/2021/07/26/%E5%B7%A5%E5%85%B7/git/">git笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <!-- Please do not remove this -->
    <!-- 开源不易，请勿删除 -->
    <div class="footer-wrap">
        <div class="footer-inner"> 
            Dawnyh&#39;s Blog &copy; 2022<br>
            Powered By Hexo · Theme By <a href="https://linhong.me/" target="_blank">Aomori</a> · <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Github</a>
        </div>
    </div>

</footer>

<script type="module" src="https://unpkg.com/ionicons@6.0.2/dist/ionicons/ionicons.esm.js"></script>






<script src="/dist/build.js?1654266144177.js"></script>


<script src="/dist/custom.js?1654266144177.js"></script>













</body>

</html>