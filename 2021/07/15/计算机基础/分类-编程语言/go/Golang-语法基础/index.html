<!DOCTYPE html>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">

    

    <!-- 渲染优化 -->
    <meta name="renderer" content="webkit">
    <meta name="force-rendering" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="HandheldFriendly" content="True" >
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!--icon-->

    
        <link rel="shortcut icon" href="/images/favicon.ico">
    
    
        <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
    
    
        <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
    
    
        <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
    
    
        <link rel="mask-icon" href="/images/safari-pinned-tab.svg">
    


    <!-- meta -->


<title>Golang-语法基础 | Dawnyh&#39;s Blog</title>


    <meta name="keywords" content="golang">




    <!-- OpenGraph -->


    
<link rel="stylesheet" href="/css/style/main.css">
 

    
    
    
        <link rel="stylesheet" id="hl-default-theme" href="https://cdn.jsdelivr.net/npm/highlight.js@10.1.2/styles/github.min.css" media="none" onload="this.media='all'">
        
    

    

    

     

    <!-- custom head -->

<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Dawnyh's Blog" type="application/atom+xml">
</head>

    <body>
        <div id="app" tabindex="-1">
            <header class="header">
    <div class="header__left">
        <a href="/" class="button">
            <span class="logo__text">Dawnyh&#39;s Blog</span>
        </a>
    </div>
    <div class="header__right">
        
            <div class="navbar__menus">
                
                    <a href="/" class="navbar-menu button">首页</a>
                
                    <a href="/tags/" class="navbar-menu button">标签</a>
                
                    <a href="/archives/" class="navbar-menu button">归档</a>
                
                    <a href="/friends/" class="navbar-menu button">友链</a>
                
            </div>
        
        
        
    <a href="/search/" id="btn-search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="24" height="24" fill="currentColor" stroke="currentColor" stroke-width="32"><path d="M192 448c0-141.152 114.848-256 256-256s256 114.848 256 256-114.848 256-256 256-256-114.848-256-256z m710.624 409.376l-206.88-206.88A318.784 318.784 0 0 0 768 448c0-176.736-143.264-320-320-320S128 271.264 128 448s143.264 320 320 320a318.784 318.784 0 0 0 202.496-72.256l206.88 206.88 45.248-45.248z"></path></svg>
    </a>


        
        

        
            <a class="dropdown-icon button" id="btn-dropdown" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width='24' height='24' fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round"><path fill="currentColor" d="M3.314,4.8h13.372c0.41,0,0.743-0.333,0.743-0.743c0-0.41-0.333-0.743-0.743-0.743H3.314c-0.41,0-0.743,0.333-0.743,0.743C2.571,4.467,2.904,4.8,3.314,4.8z M16.686,15.2H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,15.2,16.686,15.2z M16.686,9.257H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,9.257,16.686,9.257z"></path></svg></a>
            <div class="dropdown-menus" id="dropdown-menus">
                
                    <a href="/" class="dropdown-menu button">首页</a>
                
                    <a href="/tags/" class="dropdown-menu button">标签</a>
                
                    <a href="/archives/" class="dropdown-menu button">归档</a>
                
                    <a href="/friends/" class="dropdown-menu button">友链</a>
                
            </div>
        
    </div>
</header>


            <main class="main">
    

<div class="post-title">
    <h1 class="post-title__text">
        Golang-语法基础
    </h1>
    <div class="post-title__meta">
        <a href="/archives/2021/07/" class="post-meta__date button">2021-07-15</a>
        
    <span class="separate-dot"></span><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="button">计算机基础</a>

 
        
    
    


 

 
    </div>
</div>


    <aside class="post-side">
        <div class="post-side__toc">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#变量"><span class="toc-number">1.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义变量"><span class="toc-number">1.1.</span> <span class="toc-text">定义变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量类型"><span class="toc-number">1.2.</span> <span class="toc-text">变量类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Boolean"><span class="toc-number">1.2.1.</span> <span class="toc-text">Boolean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数值型"><span class="toc-number">1.2.2.</span> <span class="toc-text">数值型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串"><span class="toc-number">1.2.3.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#错误类型"><span class="toc-number">1.2.4.</span> <span class="toc-text">错误类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类型转换"><span class="toc-number">1.2.5.</span> <span class="toc-text">类型转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常量"><span class="toc-number">1.3.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分组声明"><span class="toc-number">1.4.</span> <span class="toc-text">分组声明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运算符"><span class="toc-number">2.</span> <span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#array、slice、map"><span class="toc-number">3.</span> <span class="toc-text">array、slice、map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#array"><span class="toc-number">3.1.</span> <span class="toc-text">array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slice"><span class="toc-number">3.2.</span> <span class="toc-text">slice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map"><span class="toc-number">3.3.</span> <span class="toc-text">map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历"><span class="toc-number">3.4.</span> <span class="toc-text">遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分配存储空间"><span class="toc-number">4.</span> <span class="toc-text">分配存储空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#make"><span class="toc-number">4.1.</span> <span class="toc-text">make</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new"><span class="toc-number">4.2.</span> <span class="toc-text">new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#零值"><span class="toc-number">4.3.</span> <span class="toc-text">零值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#流程控制"><span class="toc-number">5.</span> <span class="toc-text">流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#条件判断"><span class="toc-number">5.1.</span> <span class="toc-text">条件判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#循环控制"><span class="toc-number">5.2.</span> <span class="toc-text">循环控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无条件跳转"><span class="toc-number">5.3.</span> <span class="toc-text">无条件跳转</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#import"><span class="toc-number">6.</span> <span class="toc-text">import</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数"><span class="toc-number">7.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#变参"><span class="toc-number">7.1.</span> <span class="toc-text">变参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数作为值、类型"><span class="toc-number">7.2.</span> <span class="toc-text">函数作为值、类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指针"><span class="toc-number">8.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结构体"><span class="toc-number">9.</span> <span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义结构体"><span class="toc-number">9.1.</span> <span class="toc-text">定义结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问结构体成员"><span class="toc-number">9.2.</span> <span class="toc-text">访问结构体成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#method"><span class="toc-number">9.3.</span> <span class="toc-text">method</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口"><span class="toc-number">10.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#特性"><span class="toc-number">11.</span> <span class="toc-text">特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#defer"><span class="toc-number">11.1.</span> <span class="toc-text">defer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Panic和Recover"><span class="toc-number">11.2.</span> <span class="toc-text">Panic和Recover</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#error"><span class="toc-number">11.3.</span> <span class="toc-text">error</span></a></li></ol></li></ol>
        </div>
    </aside>
    <a class="btn-toc button" id="btn-toc" tabindex="0">
        <svg viewBox="0 0 1024 1024" width="32" height="32" xmlns="http://www.w3.org/2000/svg">
            <path d="M128 256h64V192H128zM320 256h576V192H320zM128 544h64v-64H128zM320 544h576v-64H320zM128 832h64v-64H128zM320 832h576v-64H320z" fill="currentColor"></path>
        </svg>
    </a>
    <div class="toc-menus" id="toc-menus">
        <div class="toc-title">文章目录</div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#变量"><span class="toc-number">1.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义变量"><span class="toc-number">1.1.</span> <span class="toc-text">定义变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量类型"><span class="toc-number">1.2.</span> <span class="toc-text">变量类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Boolean"><span class="toc-number">1.2.1.</span> <span class="toc-text">Boolean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数值型"><span class="toc-number">1.2.2.</span> <span class="toc-text">数值型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串"><span class="toc-number">1.2.3.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#错误类型"><span class="toc-number">1.2.4.</span> <span class="toc-text">错误类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类型转换"><span class="toc-number">1.2.5.</span> <span class="toc-text">类型转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常量"><span class="toc-number">1.3.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分组声明"><span class="toc-number">1.4.</span> <span class="toc-text">分组声明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运算符"><span class="toc-number">2.</span> <span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#array、slice、map"><span class="toc-number">3.</span> <span class="toc-text">array、slice、map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#array"><span class="toc-number">3.1.</span> <span class="toc-text">array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slice"><span class="toc-number">3.2.</span> <span class="toc-text">slice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map"><span class="toc-number">3.3.</span> <span class="toc-text">map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历"><span class="toc-number">3.4.</span> <span class="toc-text">遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分配存储空间"><span class="toc-number">4.</span> <span class="toc-text">分配存储空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#make"><span class="toc-number">4.1.</span> <span class="toc-text">make</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new"><span class="toc-number">4.2.</span> <span class="toc-text">new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#零值"><span class="toc-number">4.3.</span> <span class="toc-text">零值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#流程控制"><span class="toc-number">5.</span> <span class="toc-text">流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#条件判断"><span class="toc-number">5.1.</span> <span class="toc-text">条件判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#循环控制"><span class="toc-number">5.2.</span> <span class="toc-text">循环控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无条件跳转"><span class="toc-number">5.3.</span> <span class="toc-text">无条件跳转</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#import"><span class="toc-number">6.</span> <span class="toc-text">import</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数"><span class="toc-number">7.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#变参"><span class="toc-number">7.1.</span> <span class="toc-text">变参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数作为值、类型"><span class="toc-number">7.2.</span> <span class="toc-text">函数作为值、类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指针"><span class="toc-number">8.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结构体"><span class="toc-number">9.</span> <span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义结构体"><span class="toc-number">9.1.</span> <span class="toc-text">定义结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问结构体成员"><span class="toc-number">9.2.</span> <span class="toc-text">访问结构体成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#method"><span class="toc-number">9.3.</span> <span class="toc-text">method</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口"><span class="toc-number">10.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#特性"><span class="toc-number">11.</span> <span class="toc-text">特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#defer"><span class="toc-number">11.1.</span> <span class="toc-text">defer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Panic和Recover"><span class="toc-number">11.2.</span> <span class="toc-text">Panic和Recover</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#error"><span class="toc-number">11.3.</span> <span class="toc-text">error</span></a></li></ol></li></ol>
    </div>


<article class="post post__with-toc content-card">
    <div class="post__header"></div>
    <div class="post__content">
        <h2 id="变量"><a class="header-anchor" href="#变量"></a>变量</h2>
<h3 id="定义变量"><a class="header-anchor" href="#定义变量"></a>定义变量</h3>
<pre><code class="hljs go"><span class="hljs-comment">//定义一个名称为“variableName”，类型为"type"的变量</span>
<span class="hljs-keyword">var</span> variableName <span class="hljs-keyword">type</span>

<span class="hljs-comment">//定义三个类型都是“type”的变量</span>
<span class="hljs-keyword">var</span> vname1, vname2, vname3 <span class="hljs-keyword">type</span>

<span class="hljs-comment">//初始化“variableName”的变量为“value”值，类型是“type”</span>
<span class="hljs-keyword">var</span> variableName <span class="hljs-keyword">type</span> = value

<span class="hljs-comment">/*</span>
<span class="hljs-comment">    定义三个类型都是"type"的变量,并且分别初始化为相应的值</span>
<span class="hljs-comment">    vname1为v1，vname2为v2，vname3为v3</span>
<span class="hljs-comment">*/</span>
<span class="hljs-keyword">var</span> vname1, vname2, vname3 <span class="hljs-keyword">type</span> = v1, v2, v3

<span class="hljs-comment">/*</span>
<span class="hljs-comment">    定义三个变量，它们分别初始化为相应的值</span>
<span class="hljs-comment">    vname1为v1，vname2为v2，vname3为v3</span>
<span class="hljs-comment">    然后Go会根据其相应值的类型来帮你初始化它们</span>
<span class="hljs-comment">*/</span>
<span class="hljs-keyword">var</span> vname1, vname2, vname3 = v1, v2, v3

<span class="hljs-comment">/*</span>
<span class="hljs-comment">    :=这个符号直接取代了var和type,这种形式叫做简短声明。不过它有一个限制，那就是它只能用     在函数内部；在函数外部使用则会无法编译通过，所以一般用var方式来定义全局变量</span>
<span class="hljs-comment">*/</span>
vname1, vname2, vname3 := v1, v2, v3

<span class="hljs-comment">/*</span>
<span class="hljs-comment">	_（下划线）是个特殊的变量名，任何赋予它的值都会被丢弃。在这个例子中，我们将值35赋予     b，并同时丢弃34：</span>
<span class="hljs-comment">*/</span>
_, b := <span class="hljs-number">34</span>, <span class="hljs-number">35</span></code></pre>
<p>Go对于已声明但未使用的变量会在编译阶段报错</p>
<h3 id="变量类型"><a class="header-anchor" href="#变量类型"></a>变量类型</h3>
<h4 id="Boolean"><a class="header-anchor" href="#Boolean"></a>Boolean</h4>
<p>在Go中，布尔值的类型为<code>bool</code>，值是<code>true</code>或<code>false</code>，默认为<code>false</code></p>
<pre><code class="hljs go"><span class="hljs-comment">//示例代码</span>
<span class="hljs-keyword">var</span> isActive <span class="hljs-keyword">bool</span>  <span class="hljs-comment">// 全局变量声明</span>
<span class="hljs-keyword">var</span> enabled, disabled = <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>  <span class="hljs-comment">// 忽略类型的声明</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;
    <span class="hljs-keyword">var</span> available <span class="hljs-keyword">bool</span>  <span class="hljs-comment">// 一般声明</span>
    valid := <span class="hljs-literal">false</span>      <span class="hljs-comment">// 简短声明</span>
    available = <span class="hljs-literal">true</span>    <span class="hljs-comment">// 赋值操作</span>
&#125;</code></pre>
<h4 id="数值型"><a class="header-anchor" href="#数值型"></a>数值型</h4>
<p>整数类型有无符号和带符号两种。Go同时支持<code>int</code>和<code>uint</code>，这两种类型的长度相同，但具体长度取决于不同编译器的实现。Go里面也有直接定义好位数的类型：<code>rune</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>和<code>byte</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>。其中<code>rune</code>是<code>int32</code>的别称，<code>byte</code>是<code>uint8</code>的别称。</p>
<blockquote>
<p>需要注意的一点是，这些类型的变量之间不允许互相赋值或操作，不然会在编译时引起编译器报错</p>
<p>另外，尽管int的长度是32 bit, 但int 与 int32并不可以互用。</p>
</blockquote>
<p>浮点数的类型有<code>float32</code>和<code>float64</code>两种（没有<code>float</code>类型），默认是<code>float64</code></p>
<h4 id="字符串"><a class="header-anchor" href="#字符串"></a>字符串</h4>
<p>Go中的字符串都是采用<code>UTF-8</code>字符集编码。字符串是用一对双引号（&quot;&quot;）或反引号（``）括起来定义，它的类型是<code>string</code></p>
<p>在Go中字符串是不可变的，例如下面的代码编译时会报错：cannot assign to s[0]</p>
<pre><code class="hljs go"><span class="hljs-keyword">var</span> s <span class="hljs-keyword">string</span> = <span class="hljs-string">"hello"</span>
s[<span class="hljs-number">0</span>] = <span class="hljs-string">'c'</span></code></pre>
<p>如果真的想要修改怎么办呢？下面的代码可以实现</p>
<pre><code class="hljs go">s := <span class="hljs-string">"hello"</span>
c := []<span class="hljs-keyword">byte</span>(s)  <span class="hljs-comment">// 将字符串 s 转换为 []byte 类型</span>
c[<span class="hljs-number">0</span>] = <span class="hljs-string">'c'</span>
s2 := <span class="hljs-keyword">string</span>(c)  <span class="hljs-comment">// 再转换回 string 类型</span>
fmt.Printf(<span class="hljs-string">"%s\n"</span>, s2)</code></pre>
<p>Go中可以使用<code>+</code>操作符来连接两个字符串</p>
<p>修改字符串也可写为：</p>
<pre><code class="hljs go">s := <span class="hljs-string">"hello"</span>
s = <span class="hljs-string">"c"</span> + s[<span class="hljs-number">1</span>:] <span class="hljs-comment">// 字符串虽不能更改，但可进行切片操作</span>
fmt.Printf(<span class="hljs-string">"%s\n"</span>, s)</code></pre>
<p>如果要声明一个多行的字符串怎么办？可以通过反引号（``）来声明：</p>
<pre><code class="hljs go">m := <span class="hljs-string">`hello</span>
<span class="hljs-string">    world`</span></code></pre>
<p>(``) 括起的字符串为Raw字符串，即字符串在代码中的形式就是打印时的形式，它没有字符转义，换行也将原样输出。例如本例中会输出：</p>
<pre><code class="hljs plain">hello
    world</code></pre>
<h4 id="错误类型"><a class="header-anchor" href="#错误类型"></a>错误类型</h4>
<p>Go内置有一个<code>error</code>类型，专门用来处理错误信息，Go的<code>package</code>里面还专门有一个包<code>errors</code>来处理错误</p>
<pre><code class="hljs go">err := errors.New(<span class="hljs-string">"emit macho dwarf: elf header corrupted"</span>)
<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;  <span class="hljs-comment">//nil 是 map、slice、pointer、channel、func、interface 的零值</span>
    fmt.Print(err)
&#125;</code></pre>
<h4 id="类型转换"><a class="header-anchor" href="#类型转换"></a>类型转换</h4>
<pre><code class="hljs go"><span class="hljs-comment">// type_name(expression) 将 expression 转化为 type_name 类型</span>
<span class="hljs-keyword">var</span> sum <span class="hljs-keyword">int</span> = <span class="hljs-number">17</span>
<span class="hljs-keyword">var</span> count <span class="hljs-keyword">int</span> =<span class="hljs-number">5</span>
<span class="hljs-keyword">var</span> mean <span class="hljs-keyword">float32</span>
mean = <span class="hljs-keyword">float32</span>(sum)/<span class="hljs-keyword">float32</span>(count)
fmt.Printf(<span class="hljs-string">"mean 的值为：%f\n"</span>,mean)</code></pre>
<h3 id="常量"><a class="header-anchor" href="#常量"></a>常量</h3>
<p>常量也就是在程序编译阶段就确定下来的值，而程序在运行时无法改变该值。在Go程序中，常量可定义为数值、布尔值或字符串等类型。</p>
<pre><code class="hljs go"><span class="hljs-keyword">const</span> constantName = value
<span class="hljs-comment">//如果需要，也可以明确指定常量的类型：</span>
<span class="hljs-keyword">const</span> Pi <span class="hljs-keyword">float32</span> = <span class="hljs-number">3.1415926</span></code></pre>
<h3 id="分组声明"><a class="header-anchor" href="#分组声明"></a>分组声明</h3>
<p>在Go语言中，同时声明多个常量、变量，或者导入多个包时，可采用分组的方式进行声明</p>
<p>例如下面的代码：</p>
<pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">"os"</span>

<span class="hljs-keyword">const</span> i = <span class="hljs-number">100</span>
<span class="hljs-keyword">const</span> pi = <span class="hljs-number">3.1415</span>
<span class="hljs-keyword">const</span> prefix = <span class="hljs-string">"Go_"</span>

<span class="hljs-keyword">var</span> i <span class="hljs-keyword">int</span>
<span class="hljs-keyword">var</span> pi <span class="hljs-keyword">float32</span>
<span class="hljs-keyword">var</span> prefix <span class="hljs-keyword">string</span></code></pre>
<p>可以分组写成如下形式：</p>
<pre><code class="hljs go"><span class="hljs-keyword">import</span>(
    <span class="hljs-string">"fmt"</span>
    <span class="hljs-string">"os"</span>
)

<span class="hljs-keyword">const</span>(
    i = <span class="hljs-number">100</span>
    pi = <span class="hljs-number">3.1415</span>
    prefix = <span class="hljs-string">"Go_"</span>
)

<span class="hljs-keyword">var</span>(
    i <span class="hljs-keyword">int</span>
    pi <span class="hljs-keyword">float32</span>
    prefix <span class="hljs-keyword">string</span>
)</code></pre>
<h2 id="运算符"><a class="header-anchor" href="#运算符"></a>运算符</h2>
<p>go的运算符和C相同</p>
<p>算术运算符</p>
<p>关系运算符</p>
<p>逻辑运算符</p>
<p>位运算符——<code>&amp;</code>（与）、<code>|</code>（或）、<code>^</code>（异或）</p>
<h2 id="array、slice、map"><a class="header-anchor" href="#array、slice、map"></a>array、slice、map</h2>
<h3 id="array"><a class="header-anchor" href="#array"></a>array</h3>
<p><code>array</code>就是数组，它的定义方式如下：</p>
<pre><code class="hljs go"><span class="hljs-keyword">var</span> arr [n]<span class="hljs-keyword">type</span></code></pre>
<p>在<code>[n]type</code>中，<code>n</code>表示数组的长度，<code>type</code>表示存储元素的类型。对数组的操作和其它语言类似，都是通过<code>[]</code>来进行读取或赋值：</p>
<pre><code class="hljs go"><span class="hljs-keyword">var</span> arr [<span class="hljs-number">10</span>]<span class="hljs-keyword">int</span>  <span class="hljs-comment">// 声明了一个int类型的数组</span>
arr[<span class="hljs-number">0</span>] = <span class="hljs-number">42</span>      <span class="hljs-comment">// 数组下标是从0开始的</span>
arr[<span class="hljs-number">1</span>] = <span class="hljs-number">13</span>      <span class="hljs-comment">// 赋值操作</span>
fmt.Printf(<span class="hljs-string">"The first element is %d\n"</span>, arr[<span class="hljs-number">0</span>])  <span class="hljs-comment">// 获取数据，返回42</span>
fmt.Printf(<span class="hljs-string">"The last element is %d\n"</span>, arr[<span class="hljs-number">9</span>]) <span class="hljs-comment">//返回未赋值的最后一个元素，默认返回0</span></code></pre>
<p>由于长度也是数组类型的一部分，因此<code>[3]int</code>与<code>[4]int</code>是不同的类型，数组也就不能改变长度。数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该数组的副本，而不是它的指针。如果要使用指针，那么就需要用到后面介绍的<code>slice</code>类型了。</p>
<p>数组同样可以使用<code>:=</code>进行简短声明</p>
<pre><code class="hljs go">a := [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125; <span class="hljs-comment">// 声明了一个长度为3的int数组</span>

b := [<span class="hljs-number">10</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125; <span class="hljs-comment">// 声明了一个长度为10的int数组，其中前三个元素初始化为1、2、3，其它默认为0</span>

c := [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125; <span class="hljs-comment">// 可以省略长度而采用`...`的方式，Go会自动根据元素个数来计算长度</span></code></pre>
<pre><code class="hljs go"><span class="hljs-comment">// 声明了一个二维数组，该数组以两个数组作为元素，其中每个数组中又有4个int类型的元素</span>
doubleArray := [<span class="hljs-number">2</span>][<span class="hljs-number">4</span>]<span class="hljs-keyword">int</span>&#123;[<span class="hljs-number">4</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;, [<span class="hljs-number">4</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;&#125;

<span class="hljs-comment">// 上面的声明可以简化，直接忽略内部的类型</span>
easyArray := [<span class="hljs-number">2</span>][<span class="hljs-number">4</span>]<span class="hljs-keyword">int</span>&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;&#125;</code></pre>
<p><img src="/2021/07/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%88%86%E7%B1%BB-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/Golang-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/2.2.array.png" class="lazy" data-srcset="/2021/07/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%88%86%E7%B1%BB-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/Golang-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/2.2.array.png" srcset="/images/loadingImage.gif" alt="img"></p>
<h3 id="slice"><a class="header-anchor" href="#slice"></a>slice</h3>
<p>在很多应用场景中，数组并不能满足我们的需求。在初始定义数组时，我们并不知道需要多大的数组，因此我们就需要“动态数组”。在Go里面这种数据结构叫<code>slice</code></p>
<p><code>slice</code>并不是真正意义上的动态数组，而是一个引用类型。<code>slice</code>总是指向一个底层<code>array</code>，<code>slice</code>的声明也可以像<code>array</code>一样，只是不需要长度。</p>
<pre><code class="hljs go"><span class="hljs-comment">// 和声明array一样，只是少了长度</span>
<span class="hljs-keyword">var</span> fslice []<span class="hljs-keyword">int</span></code></pre>
<p><code>slice</code>可以从一个数组或一个已经存在的<code>slice</code>中再次声明。<code>slice</code>通过<code>array[i:j]</code>来获取，其中<code>i</code>是数组的开始位置，<code>j</code>是结束位置，但不包含<code>array[j]</code>，它的长度是<code>j-i</code>。</p>
<pre><code class="hljs go"><span class="hljs-comment">// 声明一个含有10个元素元素类型为byte的数组</span>
<span class="hljs-keyword">var</span> ar = [<span class="hljs-number">10</span>]<span class="hljs-keyword">byte</span> &#123;<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'f'</span>, <span class="hljs-string">'g'</span>, <span class="hljs-string">'h'</span>, <span class="hljs-string">'i'</span>, <span class="hljs-string">'j'</span>&#125;

<span class="hljs-comment">// 声明两个含有byte的slice</span>
<span class="hljs-keyword">var</span> a, b []<span class="hljs-keyword">byte</span>

<span class="hljs-comment">// a指向数组的第3个元素开始，并到第五个元素结束，</span>
a = ar[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>]
<span class="hljs-comment">//现在a含有的元素: ar[2]、ar[3]和ar[4]</span>

<span class="hljs-comment">// b是数组ar的另一个slice</span>
b = ar[<span class="hljs-number">3</span>:<span class="hljs-number">5</span>]
<span class="hljs-comment">// b的元素是：ar[3]和ar[4]</span></code></pre>
<p><img src="/2021/07/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%88%86%E7%B1%BB-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/Golang-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/2.2.slice.png" class="lazy" data-srcset="/2021/07/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%88%86%E7%B1%BB-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/Golang-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/2.2.slice.png" srcset="/images/loadingImage.gif" alt="img"></p>
<blockquote>
<p>注意<code>slice</code>和数组在声明时的区别：声明数组时，方括号内写明了数组的长度或使用<code>...</code>自动计算长度，而声明<code>slice</code>时，方括号内没有任何字符。</p>
</blockquote>
<p><code>slice</code>是引用类型，所以当引用改变其中元素的值时，其它的所有引用都会改变该值，例如上面的<code>aSlice</code>和<code>bSlice</code>，如果修改了<code>bSlice</code>中元素的值，那么<code>aSlice</code>相对应的值也会改变。</p>
<p>对于<code>slice</code>有几个有用的内置函数：</p>
<ul>
<li><code>len</code> 获取<code>slice</code>的长度</li>
<li><code>cap</code> 获取<code>slice</code>的最大容量</li>
<li><code>append</code> 向<code>slice</code>里面追加一个或者多个元素，然后返回一个和<code>slice</code>一样类型的<code>slice</code></li>
<li><code>copy</code> 函数<code>copy</code>从源<code>slice</code>的<code>src</code>中复制元素到目标<code>dst</code>，并且返回复制的元素的个数</li>
</ul>
<pre><code class="hljs go">leng := <span class="hljs-built_in">len</span>(slice_a)
slice_b := <span class="hljs-built_in">append</span>(slice_a, <span class="hljs-string">'l'</span>)</code></pre>
<p>注：<code>append</code>函数会改变<code>slice</code>所引用的数组的内容，从而影响到引用同一数组的其它<code>slice</code>。 但当<code>slice</code>中没有剩余空间（即<code>(cap-len) == 0</code>）时，此时将动态分配新的数组空间。返回的<code>slice</code>数组指针将指向这个空间，而原数组的内容将保持不变；其它引用此数组的<code>slice</code>则不受影响。</p>
<h3 id="map"><a class="header-anchor" href="#map"></a>map</h3>
<p><code>map</code>也就是Python中字典的概念，它的格式为<code>map[keyType]valueType</code></p>
<p>我们看下面的代码，<code>map</code>的读取和设置也类似<code>slice</code>一样，通过<code>key</code>来操作，只是<code>slice</code>的<code>index</code>只能是<code>int</code>类型，而<code>map</code>多了很多类型，可以是<code>int</code>，可以是<code>string</code>及所有完全定义了<code>==</code>与<code>!=</code>操作的类型。</p>
<pre><code class="hljs go"><span class="hljs-comment">// 声明一个key是字符串，值为int的字典,这种方式的声明需要在使用之前使用make初始化</span>
<span class="hljs-keyword">var</span> numbers <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>
numbers = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)

<span class="hljs-comment">// 另一种map的声明方式</span>
numbers := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)
numbers[<span class="hljs-string">"one"</span>] = <span class="hljs-number">1</span>  <span class="hljs-comment">//赋值</span>
numbers[<span class="hljs-string">"ten"</span>] = <span class="hljs-number">10</span> <span class="hljs-comment">//赋值</span>
numbers[<span class="hljs-string">"three"</span>] = <span class="hljs-number">3</span>

fmt.Println(<span class="hljs-string">"第三个数字是: "</span>, numbers[<span class="hljs-string">"three"</span>]) <span class="hljs-comment">// 读取数据</span>
<span class="hljs-comment">// 打印出来如:第三个数字是: 3</span></code></pre>
<p>这个<code>map</code>就像我们平常看到的表格一样，左边列是<code>key</code>，右边列是值</p>
<p>使用map过程中需要注意的几点：</p>
<ul>
<li><code>map</code>是无序的，每次打印出来的<code>map</code>都会不一样，它不能通过<code>index</code>获取，而必须通过<code>key</code>获取</li>
<li><code>map</code>的长度是不固定的，也就是和<code>slice</code>一样，也是一种引用类型</li>
<li>内置的<code>len</code>函数同样适用于<code>map</code>，返回<code>map</code>拥有的<code>key</code>的数量</li>
<li><code>map</code>的值可以很方便的修改，通过<code>numbers[&quot;one&quot;]=11</code>可以很容易的把key为<code>one</code>的字典值改为<code>11</code></li>
<li><code>map</code>和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制</li>
</ul>
<p><code>map</code>的初始化可以通过<code>key:val</code>的方式初始化值，同时<code>map</code>内置有判断是否存在<code>key</code>的方式</p>
<p>通过<code>delete</code>删除<code>map</code>的元素：</p>
<pre><code class="hljs go"><span class="hljs-comment">// 初始化一个字典</span>
rating := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">float32</span>&#123;<span class="hljs-string">"C"</span>:<span class="hljs-number">5</span>, <span class="hljs-string">"Go"</span>:<span class="hljs-number">4.5</span>, <span class="hljs-string">"Python"</span>:<span class="hljs-number">4.5</span>, <span class="hljs-string">"C++"</span>:<span class="hljs-number">2</span> &#125;
<span class="hljs-comment">// map有两个返回值，第二个返回值，如果不存在key，那么ok为false，如果存在ok为true</span>
csharpRating, ok := rating[<span class="hljs-string">"C#"</span>]
<span class="hljs-keyword">if</span> ok &#123;
    fmt.Println(<span class="hljs-string">"C## is in the map and its rating is "</span>, csharpRating)
&#125; <span class="hljs-keyword">else</span> &#123;
    fmt.Println(<span class="hljs-string">"We have no rating associated with C## in the map"</span>)
&#125;

<span class="hljs-built_in">delete</span>(rating, <span class="hljs-string">"C"</span>)  <span class="hljs-comment">// 删除key为C的元素</span></code></pre>
<p>上面说过了，<code>map</code>也是一种引用类型，如果两个<code>map</code>同时指向一个底层，那么一个改变，另一个也相应的改变：</p>
<pre><code class="hljs go">m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>)
m[<span class="hljs-string">"Hello"</span>] = <span class="hljs-string">"Bonjour"</span>
m1 := m
m1[<span class="hljs-string">"Hello"</span>] = <span class="hljs-string">"Salut"</span>  <span class="hljs-comment">// 现在m["hello"]的值已经是Salut了</span></code></pre>
<h3 id="遍历"><a class="header-anchor" href="#遍历"></a>遍历</h3>
<p>Go语言中<code>range</code>关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。返回索引值和索引对应位置的值</p>
<h2 id="分配存储空间"><a class="header-anchor" href="#分配存储空间"></a>分配存储空间</h2>
<p><code>make</code>用于内建类型（<code>map</code>、<code>slice</code> 和<code>channel</code>）的内存分配。<code>new</code>用于各种类型的内存分配。</p>
<h3 id="make"><a class="header-anchor" href="#make"></a>make</h3>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">make</span><span class="hljs-params">(t Type, size ...IntegerType)</span> <span class="hljs-title">Type</span></span></code></pre>
<p><code>make</code>返回一个<code>Type</code>类型的值，返回值取决于<code>Type</code></p>
<pre><code class="hljs go"><span class="hljs-comment">//如下声明一个slice，得到一个length为0，cap为10的slice</span>
slice1 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>)
<span class="hljs-comment">//此时需要我们自行使用 append 向 slice1 中添加数据</span></code></pre>
<h3 id="new"><a class="header-anchor" href="#new"></a>new</h3>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">new</span><span class="hljs-params">(Type)</span> *<span class="hljs-title">Type</span></span></code></pre>
<p><code>new</code>返回的是<code>*Type</code>类型指针，指针指向由零值填充的<code>Type</code>类型的内存空间</p>
<h3 id="零值"><a class="header-anchor" href="#零值"></a>零值</h3>
<p>“零值”所指并非空值，而是一种“变量未填充前”的默认值，通常为0。 此处罗列部分类型的“零值”</p>
<pre><code class="hljs plain">int     0
int8    0
int32   0
int64   0
uint    0x0
rune    0 &#x2F;&#x2F;rune的实际类型是 int32
byte    0x0 &#x2F;&#x2F; byte的实际类型是 uint8
float32 0 &#x2F;&#x2F;长度为 4 byte
float64 0 &#x2F;&#x2F;长度为 8 byte
bool    false
string  &quot;&quot;</code></pre>
<h2 id="流程控制"><a class="header-anchor" href="#流程控制"></a>流程控制</h2>
<h3 id="条件判断"><a class="header-anchor" href="#条件判断"></a>条件判断</h3>
<p>Go里面<code>if</code>条件判断语句中不需要括号，如下代码所示</p>
<pre><code class="hljs go"><span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">10</span> &#123;
    fmt.Println(<span class="hljs-string">"x is greater than 10"</span>)
&#125; <span class="hljs-keyword">else</span> &#123;
    fmt.Println(<span class="hljs-string">"x is less than 10"</span>)
&#125;</code></pre>
<p>多个条件的时候如下所示：</p>
<pre><code class="hljs go"><span class="hljs-keyword">if</span> integer == <span class="hljs-number">3</span> &#123;
    fmt.Println(<span class="hljs-string">"The integer is equal to 3"</span>)
&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> integer &lt; <span class="hljs-number">3</span> &#123;
    fmt.Println(<span class="hljs-string">"The integer is less than 3"</span>)
&#125; <span class="hljs-keyword">else</span> &#123;
    fmt.Println(<span class="hljs-string">"The integer is greater than 3"</span>)
&#125;</code></pre>
<p>Go中也有<code>switch-case</code>，特别之处是Go默认每个case后带有一个<code>break</code>，所以不需要我们自己添加<code>break</code>，但是可以使用<code>fallthrough</code>强制执行后面的case代码；</p>
<p>另外，case 后的表达式非常灵活，可以为数值、字符串或者其他表达式</p>
<pre><code class="hljs go"><span class="hljs-keyword">switch</span> sExpr &#123;
<span class="hljs-keyword">case</span> expr1:
    some instructions
    <span class="hljs-keyword">fallthrough</span>
<span class="hljs-keyword">case</span> expr2:
    some other instructions
<span class="hljs-keyword">case</span> expr3:
    some other instructions
<span class="hljs-keyword">default</span>:
    other code
&#125;</code></pre>
<h3 id="循环控制"><a class="header-anchor" href="#循环控制"></a>循环控制</h3>
<p>Go里面最强大的一个控制逻辑就是<code>for</code>，它即可以用来循环读取数据，又可以当作<code>while</code>来控制逻辑，还能迭代操作。它的语法如下：</p>
<pre><code class="hljs go"><span class="hljs-keyword">for</span> expression1; expression2; expression3 &#123;
    <span class="hljs-comment">//...</span>
&#125;</code></pre>
<p><code>expression1</code>、<code>expression2</code>和<code>expression3</code>都是表达式，其中<code>expression1</code>和<code>expression3</code>是变量声明或者函数调用返回值之类的，<code>expression2</code>是用来条件判断，<code>expression1</code>在循环开始之前调用，<code>expression3</code>在每轮循环结束之时调用。</p>
<p>一个例子比上面讲那么多更有用，那么我们看看下面的例子吧：</p>
<pre><code class="hljs go"><span class="hljs-keyword">package</span> main
<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;
    sum := <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> index:=<span class="hljs-number">0</span>; index &lt; <span class="hljs-number">10</span> ; index++ &#123;
        sum += index
    &#125;
    fmt.Println(<span class="hljs-string">"sum is equal to "</span>, sum)
&#125;
<span class="hljs-comment">// 输出：sum is equal to 45</span></code></pre>
<p>有些时候需要进行多个赋值操作，由于Go里面没有<code>,</code>操作符，那么可以使用平行赋值<code>i, j = i+1, j-1</code></p>
<p>有些时候如果我们忽略<code>expression1</code>和<code>expression3</code>：</p>
<pre><code class="hljs go">sum := <span class="hljs-number">1</span>
<span class="hljs-keyword">for</span> ; sum &lt; <span class="hljs-number">1000</span>;  &#123;
    sum += sum
&#125;</code></pre>
<p>其中<code>;</code>也可以省略，那么就变成如下的代码了，是不是似曾相识？对，这就是<code>while</code>的功能。</p>
<pre><code class="hljs go">sum := <span class="hljs-number">1</span>
<span class="hljs-keyword">for</span> sum &lt; <span class="hljs-number">1000</span> &#123;
    sum += sum
&#125;</code></pre>
<p>在循环里面有两个关键操作<code>break</code>和<code>continue</code> ,<code>break</code>操作是跳出当前循环，<code>continue</code>是跳过本次循环。当嵌套过深的时候，<code>break</code>和<code>continue</code>还可以跟着标号，配合标签使用，即跳转至标签所指定的位置，详细参考如下例子：</p>
<pre><code class="hljs go"><span class="hljs-keyword">for</span> index := <span class="hljs-number">10</span>; index&gt;<span class="hljs-number">0</span>; index-- &#123;
    <span class="hljs-keyword">if</span> index == <span class="hljs-number">5</span>&#123;
        <span class="hljs-keyword">break</span> <span class="hljs-comment">// 或者continue</span>
    &#125;
    fmt.Println(index)
&#125;
<span class="hljs-comment">// break打印出来10、9、8、7、6</span>
<span class="hljs-comment">// continue打印出来10、9、8、7、6、4、3、2、1</span></code></pre>
<p><code>for</code>配合<code>range</code>可以用于读取<code>slice</code>和<code>map</code>的数据：</p>
<pre><code class="hljs go"><span class="hljs-keyword">for</span> k,v:=<span class="hljs-keyword">range</span> <span class="hljs-keyword">map</span> &#123;
    fmt.Println(<span class="hljs-string">"map's key:"</span>,k)
    fmt.Println(<span class="hljs-string">"map's val:"</span>,v)
&#125;</code></pre>
<p>由于 Go 支持 “多值返回”, 而对于“声明而未被调用”的变量, 编译器会报错, 在这种情况下, 可以使用<code>_</code>来丢弃不需要的返回值 例如</p>
<pre><code class="hljs go"><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> <span class="hljs-keyword">map</span>&#123;
    fmt.Println(<span class="hljs-string">"map's val:"</span>, v)
&#125;</code></pre>
<h3 id="无条件跳转"><a class="header-anchor" href="#无条件跳转"></a>无条件跳转</h3>
<p>Go有<code>goto</code>语句，可以用<code>goto</code>跳转到必须在当前函数内定义的标签。例如假设这样一个循环：</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunc</span><span class="hljs-params">()</span></span> &#123;
    i := <span class="hljs-number">0</span>
Here:   <span class="hljs-comment">//这行的第一个词，以冒号结束作为标签</span>
    <span class="hljs-built_in">println</span>(i)
    i++
    <span class="hljs-keyword">goto</span> Here   <span class="hljs-comment">//跳转到Here去</span>
&#125;</code></pre>
<blockquote>
<p>标签名是大小写敏感的。</p>
</blockquote>
<h2 id="import"><a class="header-anchor" href="#import"></a>import</h2>
<p>我们在写Go代码的时候经常用到import这个命令用来导入包文件，而我们经常看到的方式参考如下：</p>
<pre><code class="hljs plain">import(
    &quot;fmt&quot;
)</code></pre>
<p>然后我们代码里面可以通过如下的方式调用</p>
<pre><code class="hljs plain">fmt.Println(&quot;hello world&quot;)</code></pre>
<p>上面这个fmt是Go语言的标准库，其实是去<code>GOROOT</code>环境变量指定目录下去加载该模块，当然Go的import还支持如下两种方式来加载自己写的模块：</p>
<p>1.相对路径</p>
<p>import “./myModule” //当前文件同一目录的myModule目录，但是不建议这种方式来import</p>
<p>2.绝对路径</p>
<p>import “shorturl/model” //加载gopath/src/shorturl/model模块</p>
<p>上面展示了一些import常用的几种方式，但是还有一些特殊的import，让很多新手很费解，下面我们来一一讲解一下到底是怎么一回事</p>
<p>1.点操作</p>
<p>我们有时候会看到如下的方式导入包</p>
   <pre><code class="hljs go"><span class="hljs-keyword">import</span>(
    . <span class="hljs-string">"fmt"</span>
)</code></pre>
<p>这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名，也就是前面你调用的fmt.Println(“hello world”)可以省略的写成Println(“hello world”)</p>
<p>2.别名操作</p>
<p>别名操作顾名思义我们可以把包命名成另一个我们用起来容易记忆的名字</p>
   <pre><code class="hljs go"><span class="hljs-keyword">import</span>(
    f <span class="hljs-string">"fmt"</span>
)</code></pre>
<p>别名操作的话调用包函数时前缀变成了我们的前缀，即f.Println(“hello world”)</p>
<p>3._操作</p>
<p>这个操作经常是让很多人费解的一个操作符，请看下面这个import</p>
   <pre><code class="hljs go"><span class="hljs-keyword">import</span> (
    <span class="hljs-string">"database/sql"</span>
    _ <span class="hljs-string">"github.com/ziutek/mymysql/godrv"</span>
)</code></pre>
<p>_操作其实是引入该包，而不直接使用包里面的函数，而是调用了该包里面的init函数。</p>
<h2 id="函数"><a class="header-anchor" href="#函数"></a>函数</h2>
<p>函数声明</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">funcName</span><span class="hljs-params">(input1 type1, input2 type2)</span> <span class="hljs-params">(output1 type1, output2 type2)</span></span> &#123;
    <span class="hljs-comment">//这里是处理逻辑代码</span>
    <span class="hljs-comment">//返回多个值</span>
    <span class="hljs-comment">//output1 和 output2 已在上方定义，这里可以省略，只写return</span>
    <span class="hljs-keyword">return</span> output1,output2
&#125;</code></pre>
<blockquote>
<p>golang 的函数可以返回多个值</p>
<p>input 的 type1 和 type2 相同时，可以只写一个</p>
<p>output 可以省略变量名，只写类型</p>
<p>只有一个 output 时可以省略括号</p>
<p>没有output时就直接省略最后的返回信息</p>
</blockquote>
<h3 id="变参"><a class="header-anchor" href="#变参"></a>变参</h3>
<p>Go函数支持变参。接受变参的函数是有着不定数量的参数的。为了做到这点，首先需要定义函数使其接受变参</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myfunc</span><span class="hljs-params">(arg ...<span class="hljs-keyword">int</span>)</span></span> &#123;&#125;</code></pre>
<p><code>arg ...int</code>告诉Go这个函数接受不定数量的参数。注意，这些参数的类型全部是<code>int</code>。在函数体中，变量<code>arg</code>是一个<code>int</code>的<code>slice</code></p>
<pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myfunc</span><span class="hljs-params">(arg ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>)</span></span> &#123;
	sum := <span class="hljs-number">0</span>
	<span class="hljs-keyword">for</span> _,a:=<span class="hljs-keyword">range</span> arg &#123;
		sum += a
		fmt.Printf(<span class="hljs-string">"a is %d,sum is %d\n"</span>,a,sum)
	&#125;
	<span class="hljs-keyword">return</span> sum, <span class="hljs-number">1</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">var</span> slice1 []<span class="hljs-keyword">int</span>
	slice1 = <span class="hljs-built_in">append</span>(slice1,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>)
	sum,_ := myfunc(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>)
	fmt.Printf(<span class="hljs-string">"sum from 1 to 10 is %d\n"</span>, sum)
&#125;</code></pre>
<h3 id="函数作为值、类型"><a class="header-anchor" href="#函数作为值、类型"></a>函数作为值、类型</h3>
<pre><code class="hljs go"><span class="hljs-keyword">type</span> testInt <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span>  // 声明了一个函数类型</span></code></pre>
<pre><code class="hljs go"><span class="hljs-comment">// 声明的函数类型在这个地方当做了一个参数</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">filter</span><span class="hljs-params">(slice []<span class="hljs-keyword">int</span>, f testInt)</span> []<span class="hljs-title">int</span></span> &#123;
    <span class="hljs-keyword">var</span> result []<span class="hljs-keyword">int</span>
    <span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> slice &#123;
        <span class="hljs-keyword">if</span> f(value) &#123;
            result = <span class="hljs-built_in">append</span>(result, value)
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> result
&#125;</code></pre>
<p>函数作为参数传递，在使用上较为灵活，在一些通用接口的开发上也非常有效</p>
<h2 id="指针"><a class="header-anchor" href="#指针"></a>指针</h2>
<p>用法与C中的指针差不多</p>
<p><code>&amp;</code>用于取地址</p>
<p><code>*</code>获取指针指向的值</p>
<h2 id="结构体"><a class="header-anchor" href="#结构体"></a>结构体</h2>
<h3 id="定义结构体"><a class="header-anchor" href="#定义结构体"></a>定义结构体</h3>
<pre><code class="hljs go"><span class="hljs-keyword">type</span> struct_variable_type <span class="hljs-keyword">struct</span> &#123;
   member definition;
   member definition;
   ...
   member definition;
&#125;</code></pre>
<h3 id="访问结构体成员"><a class="header-anchor" href="#访问结构体成员"></a>访问结构体成员</h3>
<p>结构体变量或结构体指针都使用<code>.</code>操作符访问结构体成员</p>
<h3 id="method"><a class="header-anchor" href="#method"></a>method</h3>
<p>在定义函数的时候可以为其指定一个<code>receiver</code>，即该函数属于某一个结构体</p>
<pre><code class="hljs go"><span class="hljs-keyword">type</span> struct1 <span class="hljs-keyword">struct</span> &#123;

&#125;
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s1 struct1)</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;
   fmt.Printf(<span class="hljs-string">"ahh"</span>)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
   <span class="hljs-keyword">var</span> str1 struct1
   str1.test()   <span class="hljs-comment">//输出"ahh"</span>
&#125;</code></pre>
<p><code>struct</code>+<code>method</code>==<code>class</code></p>
<p>method不止能用于结构体，还能用于任何其他的自定义类型,比如：</p>
<pre><code class="hljs go"><span class="hljs-keyword">type</span> months <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(mon months)</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;
   fmt.Printf(<span class="hljs-string">"ahh"</span>)
&#125;</code></pre>
<h2 id="接口"><a class="header-anchor" href="#接口"></a>接口</h2>
<p>定义方法</p>
<pre><code class="hljs go"><span class="hljs-comment">/* 定义接口 */</span>
<span class="hljs-keyword">type</span> interface_name <span class="hljs-keyword">interface</span> &#123;
   method_name1 [return_type]
   method_name2 [return_type]
   method_name3 [return_type]
   <span class="hljs-comment">//...</span>
   method_namen [return_type]
&#125;

<span class="hljs-comment">/* 定义结构体 */</span>
<span class="hljs-keyword">type</span> struct_name <span class="hljs-keyword">struct</span> &#123;
   <span class="hljs-comment">/* variables */</span>
&#125;

<span class="hljs-comment">/* 实现接口方法 */</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(struct_name_variable struct_name)</span> <span class="hljs-title">method_name1</span><span class="hljs-params">()</span> [<span class="hljs-title">return_type</span>]</span> &#123;
   <span class="hljs-comment">/* 方法实现 */</span>
&#125;
<span class="hljs-comment">//...</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(struct_name_variable struct_name)</span> <span class="hljs-title">method_namen</span><span class="hljs-params">()</span> [<span class="hljs-title">return_type</span>]</span> &#123;
   <span class="hljs-comment">/* 方法实现*/</span>
&#125;</code></pre>
<p>实例如下</p>
<pre><code class="hljs go"><span class="hljs-keyword">type</span> interface1 <span class="hljs-keyword">interface</span>&#123;
   test()
&#125;
<span class="hljs-keyword">type</span> struct1 <span class="hljs-keyword">struct</span> &#123;

&#125;
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s1 struct1)</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;
   fmt.Printf(<span class="hljs-string">"ahh"</span>)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
   <span class="hljs-keyword">var</span> inter interface1
   inter = <span class="hljs-built_in">new</span>(struct1)
   inter.test()
&#125;</code></pre>
<p>通过接口，我们就可以使用一个接口来调用多个不同的方法</p>
<h2 id="特性"><a class="header-anchor" href="#特性"></a>特性</h2>
<h3 id="defer"><a class="header-anchor" href="#defer"></a>defer</h3>
<p>defer 语句在函数结束前执行，常用于资源回收</p>
<p>当有多个 defer 语句时，由后向前执行</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadWrite</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;
    file.Open(<span class="hljs-string">"file"</span>)
    <span class="hljs-keyword">defer</span> file.Close()
    <span class="hljs-keyword">if</span> failureX &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    &#125;
    <span class="hljs-keyword">if</span> failureY &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
&#125;</code></pre>
<h3 id="Panic和Recover"><a class="header-anchor" href="#Panic和Recover"></a>Panic和Recover</h3>
<p>panic用于产生一个异常，recover()位于defer语句中，用于捕获异常信息并从异常中恢复</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
   <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
      err := <span class="hljs-built_in">recover</span>()
      <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
         fmt.Println(<span class="hljs-string">"程序运行中出现异常："</span>, err)
      &#125;
   &#125;()
   <span class="hljs-built_in">panic</span>(<span class="hljs-string">"test panic"</span>)

&#125;</code></pre>
<h3 id="error"><a class="header-anchor" href="#error"></a>error</h3>
<p><code>error</code>是系统自带的一个接口类型的自定义类型，<code>errors</code> 包中包含了一个实现了 <code>error</code> 这个接口的结构体类型 <code>errorString</code>，我们可以直接使用包中的方法来自定义一些错误，从而返回我们希望被上层代码处理的错误信息</p>
<pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"errors"</span>
    <span class="hljs-string">"fmt"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
    t, err := divide(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
        fmt.Println(err)
    &#125; <span class="hljs-keyword">else</span> &#123;
        fmt.Println(t)
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">divide</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span> &#123;
    <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span> &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.New(<span class="hljs-string">"除数不能为0"</span>)
    &#125;
    <span class="hljs-keyword">return</span> a / b, <span class="hljs-literal">nil</span>
&#125;</code></pre>

    </div>
     
    <div class="post-footer__meta"><p>更新于 2023-01-14</p></div> 
    <div class="post-entry__tags"><a href="/tags/golang/" class="post-tags__link button"># golang</a></div> 
</article>


    <div class="nav">
        <div class="nav__prev">
            
                <a href="/2021/07/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%88%86%E7%B1%BB-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/Golang-%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/" class="nav__link">
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M589.088 790.624L310.464 512l278.624-278.624 45.248 45.248L400.96 512l233.376 233.376z" fill="#808080"></path></svg>
                    </div>
                    <div>
                        <div class="nav__label">
                            上一篇
                        </div>
                        <div class="nav__title">
                            Golang-项目结构
                        </div>
                    </div>
                </a>
            
        </div>
        <div class="nav__next">
            
                <a href="/2021/07/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%88%86%E7%B1%BB-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/Golang-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/" class="nav__link">
                    <div>
                        <div class="nav__label">
                            下一篇
                        </div>
                        <div class="nav__title">
                            Golang-安装配置
                        </div>
                    </div>
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M434.944 790.624l-45.248-45.248L623.04 512l-233.376-233.376 45.248-45.248L713.568 512z" fill="#808080"></path></svg>
                    </div>
                </a>
            
        </div>
    </div>





</main>

            <footer class="footer">
     
    <a href="#" class="button" id="b2t" aria-label="回到顶部" title="回到顶部">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M233.376 722.752L278.624 768 512 534.624 745.376 768l45.248-45.248L512 444.128zM192 352h640V288H192z" fill="currentColor"></path>
        </svg>
    </a>

    


    
     
 

 
    
    
    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/ChrAlpha/hexo-theme-cards" target="_blank">Cards</a></p>
</footer>

        </div>
        
    <script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
    <script>
        window.lazyLoadOptions = {
            elements_selector: ".lazy",
            threshold: 0
        };
    </script>
 

 

 

 

 



 



 


    
 


    
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>

    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.4.1/dist/jquery.fancybox.min.css">

    
<script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.4.1/dist/jquery.fancybox.min.js"></script>

    <script>
        let lazyloadT = Boolean('true'),
            auto_fancybox = Boolean('false')
        if (auto_fancybox) {
            $(".post__content").find('img').each(function () {
                var element = document.createElement("a");
                $(element).attr("data-fancybox", "gallery");
                $(element).attr("href", $(this).attr("src"));
                if (lazyloadT) {
                    $(element).attr("href", $(this).attr("data-srcset"));
                }
                $(this).wrap(element);
            });
        } else {
            $(".post__content").find("fancybox").find('img').each(function () {
                var element = document.createElement("a");
                $(element).attr("data-fancybox", "gallery");
                $(element).attr("href", $(this).attr("src"));
                if (lazyloadT) {
                    $(element).attr("href", $(this).attr("data-srcset"));
                }
                $(this).wrap(element);
            });
        }
    </script>
 

 

 

 

 




    </body>
</html>
