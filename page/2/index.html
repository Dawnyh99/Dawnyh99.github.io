<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    
    <title>Dawnyh&#39;s Blog</title>

    <meta name="description" content="Dawnyh&#39;s Blog">
    <meta name="keywords" content="">

    



    <meta property="og:type" content="website"/>
    <meta property="og:title" content=""/>
    <meta property="og:description" content=""/>
    <meta property="og:locale" content="zh-CN" />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="http://dawnyh99.github.io/page/2/index.html" />
    <meta property="og:site_name" content="Dawnyh" />
    <meta property="article:publisher" content="" />
    <script type="application/ld+json">
        {
            "@context": "https://schema.org",
            "@type": "WebPage",
            "name": "",
            "description": "",
            "publisher": {
                "@type": "Organization",
                "name": "Dawnyh"
            },
        }
    </script>


    

    

    

    

    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1654266144177.css">


    
<link rel="stylesheet" href="/dist/custom.css?v=1654266144177.css">


    <script>
        window.isPost = false
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = true
        window.aomori_search_algolia = false

    </script>

<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Dawnyh's Blog" type="application/atom+xml">
</head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-avatar avatar avatar-sm">
                <img src="/images/avatar.jpg" alt="Dawnyh">
            </div>
            
            <div class="header-type-inner">
                
                    <div id="typed-strings" style="display:none">
                        <p>Dawnyh&#39;s Blog</p>
                    </div>
                    <a class="header-type-title" id="typed" href="/"></a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
                <a href="/">Home</a>
                
                <a href="/archives">Archives</a>
                
            </div>
            <div class="header-menu-social">
                
            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                    <a href="/">Home</a>
                    
                    <a href="/archives">Archives</a>
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="index">
  
    
      <article
id="post-编程语言/go/Go语言基础"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2021/07/15/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/">golang语言基础</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="变量"><a class="header-anchor" href="#变量"></a>变量</h2>
<h3 id="定义变量"><a class="header-anchor" href="#定义变量"></a>定义变量</h3>
<pre><code class="language-go">//定义一个名称为“variableName”，类型为&quot;type&quot;的变量
var variableName type

//定义三个类型都是“type”的变量
var vname1, vname2, vname3 type

//初始化“variableName”的变量为“value”值，类型是“type”
var variableName type = value

/*
    定义三个类型都是&quot;type&quot;的变量,并且分别初始化为相应的值
    vname1为v1，vname2为v2，vname3为v3
*/
var vname1, vname2, vname3 type = v1, v2, v3

/*
    定义三个变量，它们分别初始化为相应的值
    vname1为v1，vname2为v2，vname3为v3
    然后Go会根据其相应值的类型来帮你初始化它们
*/
var vname1, vname2, vname3 = v1, v2, v3

/*
    :=这个符号直接取代了var和type,这种形式叫做简短声明。不过它有一个限制，那就是它只能用     在函数内部；在函数外部使用则会无法编译通过，所以一般用var方式来定义全局变量
*/
vname1, vname2, vname3 := v1, v2, v3

/*
	_（下划线）是个特殊的变量名，任何赋予它的值都会被丢弃。在这个例子中，我们将值35赋予     b，并同时丢弃34：
*/
_, b := 34, 35

</code></pre>
<p>Go对于已声明但未使用的变量会在编译阶段报错</p>
<h3 id="变量类型"><a class="header-anchor" href="#变量类型"></a>变量类型</h3>
<h4 id="Boolean"><a class="header-anchor" href="#Boolean"></a>Boolean</h4>
<p>在Go中，布尔值的类型为<code>bool</code>，值是<code>true</code>或<code>false</code>，默认为<code>false</code></p>
<pre><code class="language-go">//示例代码
var isActive bool  // 全局变量声明
var enabled, disabled = true, false  // 忽略类型的声明
func test() {
    var available bool  // 一般声明
    valid := false      // 简短声明
    available = true    // 赋值操作
}
</code></pre>
<h4 id="数值型"><a class="header-anchor" href="#数值型"></a>数值型</h4>
<p>整数类型有无符号和带符号两种。Go同时支持<code>int</code>和<code>uint</code>，这两种类型的长度相同，但具体长度取决于不同编译器的实现。Go里面也有直接定义好位数的类型：<code>rune</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>和<code>byte</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>。其中<code>rune</code>是<code>int32</code>的别称，<code>byte</code>是<code>uint8</code>的别称。</p>
<blockquote>
<p>需要注意的一点是，这些类型的变量之间不允许互相赋值或操作，不然会在编译时引起编译器报错</p>
<p>另外，尽管int的长度是32 bit, 但int 与 int32并不可以互用。</p>
</blockquote>
<p>浮点数的类型有<code>float32</code>和<code>float64</code>两种（没有<code>float</code>类型），默认是<code>float64</code></p>
<h4 id="字符串"><a class="header-anchor" href="#字符串"></a>字符串</h4>
<p>Go中的字符串都是采用<code>UTF-8</code>字符集编码。字符串是用一对双引号（&quot;&quot;）或反引号（``）括起来定义，它的类型是<code>string</code></p>
<p>在Go中字符串是不可变的，例如下面的代码编译时会报错：cannot assign to s[0]</p>
<pre><code class="language-go">var s string = &quot;hello&quot;
s[0] = 'c'
</code></pre>
<p>如果真的想要修改怎么办呢？下面的代码可以实现</p>
<pre><code class="language-go">s := &quot;hello&quot;
c := []byte(s)  // 将字符串 s 转换为 []byte 类型
c[0] = 'c'
s2 := string(c)  // 再转换回 string 类型
fmt.Printf(&quot;%s\n&quot;, s2)
</code></pre>
<p>Go中可以使用<code>+</code>操作符来连接两个字符串</p>
<p>修改字符串也可写为：</p>
<pre><code class="language-go">s := &quot;hello&quot;
s = &quot;c&quot; + s[1:] // 字符串虽不能更改，但可进行切片操作
fmt.Printf(&quot;%s\n&quot;, s)
</code></pre>
<p>如果要声明一个多行的字符串怎么办？可以通过反引号（``）来声明：</p>
<pre><code class="language-go">m := `hello
    world`
</code></pre>
<p>(``) 括起的字符串为Raw字符串，即字符串在代码中的形式就是打印时的形式，它没有字符转义，换行也将原样输出。例如本例中会输出：</p>
<pre><code>hello
    world
</code></pre>
<h4 id="错误类型"><a class="header-anchor" href="#错误类型"></a>错误类型</h4>
<p>Go内置有一个<code>error</code>类型，专门用来处理错误信息，Go的<code>package</code>里面还专门有一个包<code>errors</code>来处理错误</p>
<pre><code class="language-go">err := errors.New(&quot;emit macho dwarf: elf header corrupted&quot;)
if err != nil {  //nil 是 map、slice、pointer、channel、func、interface 的零值
    fmt.Print(err)
}
</code></pre>
<h4 id="类型转换"><a class="header-anchor" href="#类型转换"></a>类型转换</h4>
<pre><code class="language-go">// type_name(expression) 将 expression 转化为 type_name 类型
var sum int = 17
var count int =5
var mean float32
mean = float32(sum)/float32(count)
fmt.Printf(&quot;mean 的值为：%f\n&quot;,mean)
</code></pre>
<h3 id="常量"><a class="header-anchor" href="#常量"></a>常量</h3>
<p>常量也就是在程序编译阶段就确定下来的值，而程序在运行时无法改变该值。在Go程序中，常量可定义为数值、布尔值或字符串等类型。</p>
<pre><code class="language-go">const constantName = value
//如果需要，也可以明确指定常量的类型：
const Pi float32 = 3.1415926
</code></pre>
<h3 id="分组声明"><a class="header-anchor" href="#分组声明"></a>分组声明</h3>
<p>在Go语言中，同时声明多个常量、变量，或者导入多个包时，可采用分组的方式进行声明</p>
<p>例如下面的代码：</p>
<pre><code class="language-go">import &quot;fmt&quot;
import &quot;os&quot;

const i = 100
const pi = 3.1415
const prefix = &quot;Go_&quot;

var i int
var pi float32
var prefix string
</code></pre>
<p>可以分组写成如下形式：</p>
<pre><code class="language-go">import(
    &quot;fmt&quot;
    &quot;os&quot;
)

const(
    i = 100
    pi = 3.1415
    prefix = &quot;Go_&quot;
)

var(
    i int
    pi float32
    prefix string
)
</code></pre>
<h2 id="运算符"><a class="header-anchor" href="#运算符"></a>运算符</h2>
<p>go的运算符和C相同</p>
<p>算术运算符</p>
<p>关系运算符</p>
<p>逻辑运算符</p>
<p>位运算符——<code>&amp;</code>（与）、<code>|</code>（或）、<code>^</code>（异或）</p>
<h2 id="array、slice、map"><a class="header-anchor" href="#array、slice、map"></a>array、slice、map</h2>
<h3 id="array"><a class="header-anchor" href="#array"></a>array</h3>
<p><code>array</code>就是数组，它的定义方式如下：</p>
<pre><code class="language-go">var arr [n]type
</code></pre>
<p>在<code>[n]type</code>中，<code>n</code>表示数组的长度，<code>type</code>表示存储元素的类型。对数组的操作和其它语言类似，都是通过<code>[]</code>来进行读取或赋值：</p>
<pre><code class="language-go">var arr [10]int  // 声明了一个int类型的数组
arr[0] = 42      // 数组下标是从0开始的
arr[1] = 13      // 赋值操作
fmt.Printf(&quot;The first element is %d\n&quot;, arr[0])  // 获取数据，返回42
fmt.Printf(&quot;The last element is %d\n&quot;, arr[9]) //返回未赋值的最后一个元素，默认返回0
</code></pre>
<p>由于长度也是数组类型的一部分，因此<code>[3]int</code>与<code>[4]int</code>是不同的类型，数组也就不能改变长度。数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该数组的副本，而不是它的指针。如果要使用指针，那么就需要用到后面介绍的<code>slice</code>类型了。</p>
<p>数组同样可以使用<code>:=</code>进行简短声明</p>
<pre><code class="language-go">a := [3]int{1, 2, 3} // 声明了一个长度为3的int数组

b := [10]int{1, 2, 3} // 声明了一个长度为10的int数组，其中前三个元素初始化为1、2、3，其它默认为0

c := [...]int{4, 5, 6} // 可以省略长度而采用`...`的方式，Go会自动根据元素个数来计算长度
</code></pre>
<pre><code class="language-go">// 声明了一个二维数组，该数组以两个数组作为元素，其中每个数组中又有4个int类型的元素
doubleArray := [2][4]int{[4]int{1, 2, 3, 4}, [4]int{5, 6, 7, 8}}

// 上面的声明可以简化，直接忽略内部的类型
easyArray := [2][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}}
</code></pre>
<p><img src="/2021/07/15/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/2.2.array.png" alt="img"></p>
<h3 id="slice"><a class="header-anchor" href="#slice"></a>slice</h3>
<p>在很多应用场景中，数组并不能满足我们的需求。在初始定义数组时，我们并不知道需要多大的数组，因此我们就需要“动态数组”。在Go里面这种数据结构叫<code>slice</code></p>
<p><code>slice</code>并不是真正意义上的动态数组，而是一个引用类型。<code>slice</code>总是指向一个底层<code>array</code>，<code>slice</code>的声明也可以像<code>array</code>一样，只是不需要长度。</p>
<pre><code class="language-go">// 和声明array一样，只是少了长度
var fslice []int
</code></pre>
<p><code>slice</code>可以从一个数组或一个已经存在的<code>slice</code>中再次声明。<code>slice</code>通过<code>array[i:j]</code>来获取，其中<code>i</code>是数组的开始位置，<code>j</code>是结束位置，但不包含<code>array[j]</code>，它的长度是<code>j-i</code>。</p>
<pre><code class="language-go">// 声明一个含有10个元素元素类型为byte的数组
var ar = [10]byte {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}

// 声明两个含有byte的slice
var a, b []byte

// a指向数组的第3个元素开始，并到第五个元素结束，
a = ar[2:5]
//现在a含有的元素: ar[2]、ar[3]和ar[4]

// b是数组ar的另一个slice
b = ar[3:5]
// b的元素是：ar[3]和ar[4]
</code></pre>
<p><img src="/2021/07/15/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/2.2.slice.png" alt="img"></p>
<blockquote>
<p>注意<code>slice</code>和数组在声明时的区别：声明数组时，方括号内写明了数组的长度或使用<code>...</code>自动计算长度，而声明<code>slice</code>时，方括号内没有任何字符。</p>
</blockquote>
<p><code>slice</code>是引用类型，所以当引用改变其中元素的值时，其它的所有引用都会改变该值，例如上面的<code>aSlice</code>和<code>bSlice</code>，如果修改了<code>bSlice</code>中元素的值，那么<code>aSlice</code>相对应的值也会改变。</p>
<p>对于<code>slice</code>有几个有用的内置函数：</p>
<ul>
<li><code>len</code> 获取<code>slice</code>的长度</li>
<li><code>cap</code> 获取<code>slice</code>的最大容量</li>
<li><code>append</code> 向<code>slice</code>里面追加一个或者多个元素，然后返回一个和<code>slice</code>一样类型的<code>slice</code></li>
<li><code>copy</code> 函数<code>copy</code>从源<code>slice</code>的<code>src</code>中复制元素到目标<code>dst</code>，并且返回复制的元素的个数</li>
</ul>
<pre><code class="language-go">leng := len(slice_a)
slice_b := append(slice_a, 'l')
</code></pre>
<p>注：<code>append</code>函数会改变<code>slice</code>所引用的数组的内容，从而影响到引用同一数组的其它<code>slice</code>。 但当<code>slice</code>中没有剩余空间（即<code>(cap-len) == 0</code>）时，此时将动态分配新的数组空间。返回的<code>slice</code>数组指针将指向这个空间，而原数组的内容将保持不变；其它引用此数组的<code>slice</code>则不受影响。</p>
<h3 id="map"><a class="header-anchor" href="#map"></a>map</h3>
<p><code>map</code>也就是Python中字典的概念，它的格式为<code>map[keyType]valueType</code></p>
<p>我们看下面的代码，<code>map</code>的读取和设置也类似<code>slice</code>一样，通过<code>key</code>来操作，只是<code>slice</code>的<code>index</code>只能是<code>int</code>类型，而<code>map</code>多了很多类型，可以是<code>int</code>，可以是<code>string</code>及所有完全定义了<code>==</code>与<code>!=</code>操作的类型。</p>
<pre><code class="language-go">// 声明一个key是字符串，值为int的字典,这种方式的声明需要在使用之前使用make初始化
var numbers map[string]int
numbers = make(map[string]int)

// 另一种map的声明方式
numbers := make(map[string]int)
numbers[&quot;one&quot;] = 1  //赋值
numbers[&quot;ten&quot;] = 10 //赋值
numbers[&quot;three&quot;] = 3

fmt.Println(&quot;第三个数字是: &quot;, numbers[&quot;three&quot;]) // 读取数据
// 打印出来如:第三个数字是: 3
</code></pre>
<p>这个<code>map</code>就像我们平常看到的表格一样，左边列是<code>key</code>，右边列是值</p>
<p>使用map过程中需要注意的几点：</p>
<ul>
<li><code>map</code>是无序的，每次打印出来的<code>map</code>都会不一样，它不能通过<code>index</code>获取，而必须通过<code>key</code>获取</li>
<li><code>map</code>的长度是不固定的，也就是和<code>slice</code>一样，也是一种引用类型</li>
<li>内置的<code>len</code>函数同样适用于<code>map</code>，返回<code>map</code>拥有的<code>key</code>的数量</li>
<li><code>map</code>的值可以很方便的修改，通过<code>numbers[&quot;one&quot;]=11</code>可以很容易的把key为<code>one</code>的字典值改为<code>11</code></li>
<li><code>map</code>和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制</li>
</ul>
<p><code>map</code>的初始化可以通过<code>key:val</code>的方式初始化值，同时<code>map</code>内置有判断是否存在<code>key</code>的方式</p>
<p>通过<code>delete</code>删除<code>map</code>的元素：</p>
<pre><code class="language-go">// 初始化一个字典
rating := map[string]float32{&quot;C&quot;:5, &quot;Go&quot;:4.5, &quot;Python&quot;:4.5, &quot;C++&quot;:2 }
// map有两个返回值，第二个返回值，如果不存在key，那么ok为false，如果存在ok为true
csharpRating, ok := rating[&quot;C#&quot;]
if ok {
    fmt.Println(&quot;C# is in the map and its rating is &quot;, csharpRating)
} else {
    fmt.Println(&quot;We have no rating associated with C# in the map&quot;)
}

delete(rating, &quot;C&quot;)  // 删除key为C的元素
</code></pre>
<p>上面说过了，<code>map</code>也是一种引用类型，如果两个<code>map</code>同时指向一个底层，那么一个改变，另一个也相应的改变：</p>
<pre><code class="language-go">m := make(map[string]string)
m[&quot;Hello&quot;] = &quot;Bonjour&quot;
m1 := m
m1[&quot;Hello&quot;] = &quot;Salut&quot;  // 现在m[&quot;hello&quot;]的值已经是Salut了
</code></pre>
<h3 id="遍历"><a class="header-anchor" href="#遍历"></a>遍历</h3>
<p>Go语言中<code>range</code>关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。返回索引值和索引对应位置的值</p>
<h2 id="分配存储空间"><a class="header-anchor" href="#分配存储空间"></a>分配存储空间</h2>
<p><code>make</code>用于内建类型（<code>map</code>、<code>slice</code> 和<code>channel</code>）的内存分配。<code>new</code>用于各种类型的内存分配。</p>
<h3 id="make"><a class="header-anchor" href="#make"></a>make</h3>
<pre><code class="language-go">func make(t Type, size ...IntegerType) Type
</code></pre>
<p><code>make</code>返回一个<code>Type</code>类型的值，返回值取决于<code>Type</code></p>
<pre><code class="language-go">//如下声明一个slice，得到一个length为0，cap为10的slice
slice1 := make([]int, 0, 10)
//此时需要我们自行使用 append 向 slice1 中添加数据
</code></pre>
<h3 id="new"><a class="header-anchor" href="#new"></a>new</h3>
<pre><code class="language-go">func new(Type) *Type
</code></pre>
<p><code>new</code>返回的是<code>*Type</code>类型指针，指针指向由零值填充的<code>Type</code>类型的内存空间</p>
<h3 id="零值"><a class="header-anchor" href="#零值"></a>零值</h3>
<p>“零值”所指并非空值，而是一种“变量未填充前”的默认值，通常为0。 此处罗列部分类型的“零值”</p>
<pre><code>int     0
int8    0
int32   0
int64   0
uint    0x0
rune    0 //rune的实际类型是 int32
byte    0x0 // byte的实际类型是 uint8
float32 0 //长度为 4 byte
float64 0 //长度为 8 byte
bool    false
string  &quot;&quot;
</code></pre>
<h2 id="流程控制"><a class="header-anchor" href="#流程控制"></a>流程控制</h2>
<h3 id="条件判断"><a class="header-anchor" href="#条件判断"></a>条件判断</h3>
<p>Go里面<code>if</code>条件判断语句中不需要括号，如下代码所示</p>
<pre><code class="language-go">if x &gt; 10 {
    fmt.Println(&quot;x is greater than 10&quot;)
} else {
    fmt.Println(&quot;x is less than 10&quot;)
}
</code></pre>
<p>多个条件的时候如下所示：</p>
<pre><code class="language-go">if integer == 3 {
    fmt.Println(&quot;The integer is equal to 3&quot;)
} else if integer &lt; 3 {
    fmt.Println(&quot;The integer is less than 3&quot;)
} else {
    fmt.Println(&quot;The integer is greater than 3&quot;)
}
</code></pre>
<p>Go中也有<code>switch-case</code>，特别之处是Go默认每个case后带有一个<code>break</code>，所以不需要我们自己添加<code>break</code>，但是可以使用<code>fallthrough</code>强制执行后面的case代码；</p>
<p>另外，case 后的表达式非常灵活，可以为数值、字符串或者其他表达式</p>
<pre><code class="language-go">switch sExpr {
case expr1:
    some instructions
    fallthrough
case expr2:
    some other instructions
case expr3:
    some other instructions
default:
    other code
}
</code></pre>
<h3 id="循环控制"><a class="header-anchor" href="#循环控制"></a>循环控制</h3>
<p>Go里面最强大的一个控制逻辑就是<code>for</code>，它即可以用来循环读取数据，又可以当作<code>while</code>来控制逻辑，还能迭代操作。它的语法如下：</p>
<pre><code class="language-go">for expression1; expression2; expression3 {
    //...
}
</code></pre>
<p><code>expression1</code>、<code>expression2</code>和<code>expression3</code>都是表达式，其中<code>expression1</code>和<code>expression3</code>是变量声明或者函数调用返回值之类的，<code>expression2</code>是用来条件判断，<code>expression1</code>在循环开始之前调用，<code>expression3</code>在每轮循环结束之时调用。</p>
<p>一个例子比上面讲那么多更有用，那么我们看看下面的例子吧：</p>
<pre><code class="language-go">package main
import &quot;fmt&quot;

func main(){
    sum := 0;
    for index:=0; index &lt; 10 ; index++ {
        sum += index
    }
    fmt.Println(&quot;sum is equal to &quot;, sum)
}
// 输出：sum is equal to 45
</code></pre>
<p>有些时候需要进行多个赋值操作，由于Go里面没有<code>,</code>操作符，那么可以使用平行赋值<code>i, j = i+1, j-1</code></p>
<p>有些时候如果我们忽略<code>expression1</code>和<code>expression3</code>：</p>
<pre><code class="language-go">sum := 1
for ; sum &lt; 1000;  {
    sum += sum
}
</code></pre>
<p>其中<code>;</code>也可以省略，那么就变成如下的代码了，是不是似曾相识？对，这就是<code>while</code>的功能。</p>
<pre><code class="language-go">sum := 1
for sum &lt; 1000 {
    sum += sum
}
</code></pre>
<p>在循环里面有两个关键操作<code>break</code>和<code>continue</code> ,<code>break</code>操作是跳出当前循环，<code>continue</code>是跳过本次循环。当嵌套过深的时候，<code>break</code>和<code>continue</code>还可以跟着标号，配合标签使用，即跳转至标签所指定的位置，详细参考如下例子：</p>
<pre><code class="language-go">for index := 10; index&gt;0; index-- {
    if index == 5{
        break // 或者continue
    }
    fmt.Println(index)
}
// break打印出来10、9、8、7、6
// continue打印出来10、9、8、7、6、4、3、2、1
</code></pre>
<p><code>for</code>配合<code>range</code>可以用于读取<code>slice</code>和<code>map</code>的数据：</p>
<pre><code class="language-go">for k,v:=range map {
    fmt.Println(&quot;map's key:&quot;,k)
    fmt.Println(&quot;map's val:&quot;,v)
}
</code></pre>
<p>由于 Go 支持 “多值返回”, 而对于“声明而未被调用”的变量, 编译器会报错, 在这种情况下, 可以使用<code>_</code>来丢弃不需要的返回值 例如</p>
<pre><code class="language-go">for _, v := range map{
    fmt.Println(&quot;map's val:&quot;, v)
}
</code></pre>
<h3 id="无条件跳转"><a class="header-anchor" href="#无条件跳转"></a>无条件跳转</h3>
<p>Go有<code>goto</code>语句，可以用<code>goto</code>跳转到必须在当前函数内定义的标签。例如假设这样一个循环：</p>
<pre><code class="language-go">func myFunc() {
    i := 0
Here:   //这行的第一个词，以冒号结束作为标签
    println(i)
    i++
    goto Here   //跳转到Here去
}
</code></pre>
<blockquote>
<p>标签名是大小写敏感的。</p>
</blockquote>
<h2 id="import"><a class="header-anchor" href="#import"></a>import</h2>
<p>我们在写Go代码的时候经常用到import这个命令用来导入包文件，而我们经常看到的方式参考如下：</p>
<pre><code>import(
    &quot;fmt&quot;
)
</code></pre>
<p>然后我们代码里面可以通过如下的方式调用</p>
<pre><code>fmt.Println(&quot;hello world&quot;)
</code></pre>
<p>上面这个fmt是Go语言的标准库，其实是去<code>GOROOT</code>环境变量指定目录下去加载该模块，当然Go的import还支持如下两种方式来加载自己写的模块：</p>
<p>1.相对路径</p>
<p>import “./myModule” //当前文件同一目录的myModule目录，但是不建议这种方式来import</p>
<p>2.绝对路径</p>
<p>import “shorturl/model” //加载gopath/src/shorturl/model模块</p>
<p>上面展示了一些import常用的几种方式，但是还有一些特殊的import，让很多新手很费解，下面我们来一一讲解一下到底是怎么一回事</p>
<p>1.点操作</p>
<p>我们有时候会看到如下的方式导入包</p>
<pre><code class="language-go">  import(
      . &quot;fmt&quot;
  )
</code></pre>
<p>这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名，也就是前面你调用的fmt.Println(“hello world”)可以省略的写成Println(“hello world”)</p>
<p>2.别名操作</p>
<p>别名操作顾名思义我们可以把包命名成另一个我们用起来容易记忆的名字</p>
<pre><code class="language-go">  import(
      f &quot;fmt&quot;
  )
</code></pre>
<p>别名操作的话调用包函数时前缀变成了我们的前缀，即f.Println(“hello world”)</p>
<p>3._操作</p>
<p>这个操作经常是让很多人费解的一个操作符，请看下面这个import</p>
<pre><code class="language-go">  import (
      &quot;database/sql&quot;
      _ &quot;github.com/ziutek/mymysql/godrv&quot;
  )
</code></pre>
<p>_操作其实是引入该包，而不直接使用包里面的函数，而是调用了该包里面的init函数。</p>
<h2 id="函数"><a class="header-anchor" href="#函数"></a>函数</h2>
<p>函数声明</p>
<pre><code class="language-go">func funcName(input1 type1, input2 type2) (output1 type1, output2 type2) {
    //这里是处理逻辑代码
    //返回多个值
    //output1 和 output2 已在上方定义，这里可以省略，只写return
    return output1,output2
}
</code></pre>
<blockquote>
<p>golang 的函数可以返回多个值</p>
<p>input 的 type1 和 type2 相同时，可以只写一个</p>
<p>output 可以省略变量名，只写类型</p>
<p>只有一个 output 时可以省略括号</p>
<p>没有output时就直接省略最后的返回信息</p>
</blockquote>
<h3 id="变参"><a class="header-anchor" href="#变参"></a>变参</h3>
<p>Go函数支持变参。接受变参的函数是有着不定数量的参数的。为了做到这点，首先需要定义函数使其接受变参</p>
<pre><code class="language-go">func myfunc(arg ...int) {}
</code></pre>
<p><code>arg ...int</code>告诉Go这个函数接受不定数量的参数。注意，这些参数的类型全部是<code>int</code>。在函数体中，变量<code>arg</code>是一个<code>int</code>的<code>slice</code></p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

func myfunc(arg ...int) (int,int) {
	sum := 0
	for _,a:=range arg {
		sum += a
		fmt.Printf(&quot;a is %d,sum is %d\n&quot;,a,sum)
	}
	return sum, 1
}

func main() {
	var slice1 []int
	slice1 = append(slice1,1,2,3,4,5,6,7)
	sum,_ := myfunc(1,2,3,4,5,6,7,8,9,10)
	fmt.Printf(&quot;sum from 1 to 10 is %d\n&quot;, sum)
}
</code></pre>
<h3 id="函数作为值、类型"><a class="header-anchor" href="#函数作为值、类型"></a>函数作为值、类型</h3>
<pre><code class="language-go">type testInt func(int) bool  // 声明了一个函数类型
</code></pre>
<pre><code class="language-go">// 声明的函数类型在这个地方当做了一个参数
func filter(slice []int, f testInt) []int {
    var result []int
    for _, value := range slice {
        if f(value) {
            result = append(result, value)
        }
    }
    return result
}
</code></pre>
<p>函数作为参数传递，在使用上较为灵活，在一些通用接口的开发上也非常有效</p>
<h2 id="指针"><a class="header-anchor" href="#指针"></a>指针</h2>
<p>用法与C中的指针差不多</p>
<p><code>&amp;</code>用于取地址</p>
<p><code>*</code>获取指针指向的值</p>
<h2 id="结构体"><a class="header-anchor" href="#结构体"></a>结构体</h2>
<h3 id="定义结构体"><a class="header-anchor" href="#定义结构体"></a>定义结构体</h3>
<pre><code class="language-go">type struct_variable_type struct {
   member definition;
   member definition;
   ...
   member definition;
}
</code></pre>
<h3 id="访问结构体成员"><a class="header-anchor" href="#访问结构体成员"></a>访问结构体成员</h3>
<p>结构体变量或结构体指针都使用<code>.</code>操作符访问结构体成员</p>
<h3 id="method"><a class="header-anchor" href="#method"></a>method</h3>
<p>在定义函数的时候可以为其指定一个<code>receiver</code>，即该函数属于某一个结构体</p>
<pre><code class="language-go">type struct1 struct {

}
func (s1 struct1) test() {
   fmt.Printf(&quot;ahh&quot;)
}

func main() {
   var str1 struct1
   str1.test()   //输出&quot;ahh&quot;
}
</code></pre>
<p><code>struct</code>+<code>method</code>==<code>class</code></p>
<p>method不止能用于结构体，还能用于任何其他的自定义类型,比如：</p>
<pre><code class="language-go">type months map[string]int
func (mon months) test() {
   fmt.Printf(&quot;ahh&quot;)
}
</code></pre>
<h2 id="接口"><a class="header-anchor" href="#接口"></a>接口</h2>
<p>定义方法</p>
<pre><code class="language-go">/* 定义接口 */
type interface_name interface {
   method_name1 [return_type]
   method_name2 [return_type]
   method_name3 [return_type]
   //...
   method_namen [return_type]
}

/* 定义结构体 */
type struct_name struct {
   /* variables */
}

/* 实现接口方法 */
func (struct_name_variable struct_name) method_name1() [return_type] {
   /* 方法实现 */
}
//...
func (struct_name_variable struct_name) method_namen() [return_type] {
   /* 方法实现*/
}
</code></pre>
<p>实例如下</p>
<pre><code class="language-go">type interface1 interface{
   test()
}
type struct1 struct {

}
func (s1 struct1) test() {
   fmt.Printf(&quot;ahh&quot;)
}

func main() {
   var inter interface1
   inter = new(struct1)
   inter.test()
}
</code></pre>
<p>通过接口，我们就可以使用一个接口来调用多个不同的方法</p>
<h2 id="特性"><a class="header-anchor" href="#特性"></a>特性</h2>
<h3 id="defer"><a class="header-anchor" href="#defer"></a>defer</h3>
<p>defer 语句在函数结束前执行，常用于资源回收</p>
<p>当有多个 defer 语句时，由后向前执行</p>
<pre><code class="language-go">func ReadWrite() bool {
    file.Open(&quot;file&quot;)
    defer file.Close()
    if failureX {
        return false
    }
    if failureY {
        return false
    }
    return true
}
</code></pre>
<h3 id="Panic和Recover"><a class="header-anchor" href="#Panic和Recover"></a>Panic和Recover</h3>
<p>panic用于产生一个异常，recover()位于defer语句中，用于捕获异常信息并从异常中恢复</p>
<pre><code class="language-go">func main() {
   defer func() {
      err := recover()
      if err != nil {
         fmt.Println(&quot;程序运行中出现异常：&quot;, err)
      }
   }()
   panic(&quot;test panic&quot;)

}
</code></pre>
<h3 id="error"><a class="header-anchor" href="#error"></a>error</h3>
<p><code>error</code>是系统自带的一个接口类型的自定义类型，<code>errors</code> 包中包含了一个实现了 <code>error</code> 这个接口的结构体类型 <code>errorString</code>，我们可以直接使用包中的方法来自定义一些错误，从而返回我们希望被上层代码处理的错误信息</p>
<pre><code class="language-go">package main

import (
    &quot;errors&quot;
    &quot;fmt&quot;
)

func main() {
    t, err := divide(2, 0)
    if err != nil {
        fmt.Println(err)
    } else {
        fmt.Println(t)
    }
}

func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New(&quot;除数不能为0&quot;)
    }
    return a / b, nil
}
</code></pre>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2021-07-14T16:00:00.000Z" itemprop="datePublished">2021-07-15</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
        </div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go/" rel="tag">go</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-编程语言/go/Go的安装配置"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2021/07/14/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/Go%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/">golang的安装配置</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="下载安装"><a class="header-anchor" href="#下载安装"></a>下载安装</h2>
<p>下载地址：<a href="https://golang.google.cn/">https://golang.google.cn/</a></p>
<p>安装后会自动添加环境变量</p>
<p>运行安装程序完成后查看go版本，验证是否已正确安装</p>
<pre><code class="language-shell">go version    #查看版本
</code></pre>
<h2 id="配置"><a class="header-anchor" href="#配置"></a>配置</h2>
<h3 id="env配置"><a class="header-anchor" href="#env配置"></a>env配置</h3>
<pre><code class="language-shell">go env    #查看go环境变量
go env -w [环境变量名]=[变量值]    #写入环境变量（go version &gt; 1.13）
</code></pre>
<p><img src="/2021/07/14/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/Go%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/image-20210709091726706.png" alt="image-20210709091726706"></p>
<p>主要需要配置GOPATH（项目工作目录）、GOPROXY（go获取依赖包的代理服务器，proxy可以设置多个，⽤逗号<code>,</code>分隔，其中<code>direct</code>为直连）、GOPRIVATE（go get通过代理服务拉取私有仓库时，匹配那些不⾛代理的私有仓库）</p>
<pre><code>GOPROXY=&quot;https://goproxy.cn,https://goproxy.io,direct&quot;
GOPRIVATE=&quot;*.gitlab.com,*.gitee.com&quot;
</code></pre>
<h3 id="IDE配置"><a class="header-anchor" href="#IDE配置"></a>IDE配置</h3>
<h4 id="goland"><a class="header-anchor" href="#goland"></a>goland</h4>
<p>goland:<a href="https://www.jetbrains.com/go/">https://www.jetbrains.com/go/</a></p>
<p>Activation code:<a href="http://vrg123.com/">http://vrg123.com/</a></p>
<h4 id="VSCode"><a class="header-anchor" href="#VSCode"></a>VSCode</h4>
<p>配置步骤：<a href="https://m.imooc.com/wiki/golesson-vscodeinstall?ishidefooter=true">https://m.imooc.com/wiki/golesson-vscodeinstall?ishidefooter=true</a></p>
<p>更多配置：<a href="http://c.biancheng.net/view/6170.html">http://c.biancheng.net/view/6170.html</a></p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2021-07-13T16:00:00.000Z" itemprop="datePublished">2021-07-14</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
        </div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go/" rel="tag">go</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" rel="tag">环境配置</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-杂记/代理设置"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2021/07/08/%E6%9D%82%E8%AE%B0/%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/">网络代理设置</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="cmd-PowerShell代理设置"><a class="header-anchor" href="#cmd-PowerShell代理设置"></a>cmd/PowerShell代理设置</h2>
<p>设置命令行代理（设置环境变量,命令行关闭后则失效）</p>
<pre><code class="language-shell">set HTTP_PROXY=127.0.0.1:10809
set HTTPS_PROXY=127.0.0.1:10809
</code></pre>
<blockquote>
<p>ps：测试是否设置成功不要ping google，因为ping命令用的是ICMP协议；正确做法是</p>
<p>curl <a href="http://www.google.com">www.google.com</a></p>
</blockquote>
<h2 id="git代理设置"><a class="header-anchor" href="#git代理设置"></a>git代理设置</h2>
<p>设置永久有效</p>
<pre><code class="language-shell">git config --global https.proxy http://127.0.0.1:10809	
git config --global https.proxy https://127.0.0.1:10809
git config --global http.proxy 'socks5://127.0.0.1:10808'
git config --global https.proxy 'socks5://127.0.0.1:10808'
git config --global --list	#查询代理设置
</code></pre>
<h2 id="go代理设置"><a class="header-anchor" href="#go代理设置"></a>go代理设置</h2>
<p>方法1.配置命令行环境变量（临时）</p>
<p><strong>Bash (Linux or macOS)</strong></p>
<pre><code class="language-shell">export GOPROXY=https://goproxy.io,direct
</code></pre>
<p><strong>PowerShell (Windows)</strong></p>
<pre><code class="language-shell">$env:GOPROXY = &quot;https://goproxy.io,direct&quot;
</code></pre>
<p>方法2.配置用户环境变量</p>
<p><strong>Mac/Linux</strong></p>
<pre><code class="language-shell"># 设置你的 bash 环境变量
echo &quot;export GOPROXY=https://goproxy.io,direct&quot; &gt;&gt; ~/.profile &amp;&amp; source ~/.profile

# 如果你的终端是 zsh，使用以下命令
echo &quot;export GOPROXY=https://goproxy.io,direct&quot; &gt;&gt; ~/.zshrc &amp;&amp; source ~/.zshrc
</code></pre>
<p><strong>Windows</strong></p>
<pre><code class="language-text">1. 右键 我的电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量
2. 在 “[你的用户名]的用户变量” 中点击 ”新建“ 按钮
3. 在 “变量名” 输入框并新增 “GOPROXY”
4. 在对应的 “变量值” 输入框中新增 “https://goproxy.io,direct”
5. 最后点击 “确定” 按钮保存设置
</code></pre>
<p>参考：<a href="https://blog.csdn.net/xiaobai_ol/article/details/106426199">https://blog.csdn.net/xiaobai_ol/article/details/106426199</a></p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2021-07-07T16:00:00.000Z" itemprop="datePublished">2021-07-08</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/%E6%9D%82%E8%AE%B0/">杂记</a>
        </div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-专业课/计网/TCP&amp;IP"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2021/03/14/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%BD%91/TCP&IP/">TCP&amp;IP</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="TCP"><a class="header-anchor" href="#TCP"></a>TCP</h2>
<h3 id="三次握手和四次挥手"><a class="header-anchor" href="#三次握手和四次挥手"></a>三次握手和四次挥手</h3>
<p>TCP是可靠的，面向连接的传输层协议，端到端之间要进行TCP通信首先就要建立起TCP连接，当通信结束时断开TCP连接。这里TCP连接的建立与断开过程就分别由<code>三次握手</code>和<code>四次挥手</code>来完成。</p>
<ul>
<li>
<p>三次握手</p>
<p>TCP连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。具体过程如下图所示。</p>
<p><img src="/2021/03/14/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%BD%91/TCP&IP/image-20210316191610581.png" alt="image-20210316191610581"></p>
<p><strong>第一次握手：</strong> 建立连接。客户端发送连接请求报文段，SYN位置为1，Sequence Number为随机数<code>i</code>；然后，客户端进入SYN_SENT状态，等待服务器的确认；</p>
<p><strong>第二次握手：</strong> 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为<code>i+1</code> ( Sequence Number+1 )；同时，自己自己还要发送SYN请求信息，SYN设置为1，Sequence Number为<code>j</code>；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RCVD状态；</p>
<p><strong>第三次握手：</strong> 客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为<code>j+1</code>，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p>
<p>在wireshark中可以分别查看<code>ACK</code>和<code>Seq</code>的实际值和相对值，第一个包的Seq相对值为0。</p>
<p><strong><code>Seq</code>的相对值为当前端已发送的TCP总段长，<code>ACK</code>的相对值为当前端已接收的TCP总段长（单位：字节），</strong><code>SYN</code>标志位和<code>FIN</code>标志位也要占1字节（其他标志位如ACK不占）。</p>
</li>
<li>
<p>四次挥手</p>
<img src="/2021/03/14/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%BD%91/TCP&IP/image-20210316213743223.png" style="zoom:50%;">
<p><strong>中断连接端可以是Client端，也可以是Server端。</strong></p>
<p>假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说&quot;我Client端没有数据要发给你了&quot;，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，“告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，“告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，&quot;就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，“就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p>
</li>
</ul>
<h3 id="TCP-UDP"><a class="header-anchor" href="#TCP-UDP"></a>TCP/UDP</h3>
<p>有连接/无连接（可靠/不可靠）</p>
<p>有拆分合并/无拆分合并</p>
<p>有拥塞控制/无拥塞控制（发送速率的调整）</p>
<p>单播/多播</p>
<h3 id="滑动窗口和流量控制"><a class="header-anchor" href="#滑动窗口和流量控制"></a>滑动窗口和流量控制</h3>
<h3 id="拥塞控制"><a class="header-anchor" href="#拥塞控制"></a>拥塞控制</h3>
<h2 id="http-https"><a class="header-anchor" href="#http-https"></a>http/https</h2>
<h3 id="http各版本区别"><a class="header-anchor" href="#http各版本区别"></a>http各版本区别</h3>
<p>http1.0 vs http1.1</p>
<p>http1.1开始，默认使用长连接（HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。）</p>
<p>http1.1增加了一些错误状态码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>
<h3 id="SSL-TLS"><a class="header-anchor" href="#SSL-TLS"></a>SSL/TLS</h3>
<ul>
<li>首先由客户端发送Client Hello 消息到服务器，消息中主要包含了客户端支持的<code>ciphersuites</code>， TLS 版本信息和客户端随机数。<strong>注意此时是明文传输</strong></li>
<li>服务器接收到消息后，返回自己支持的<code>ciphersuites</code>， TLS 版本，<strong>自己的数字证书</strong>和服务器端生成的随机数。<strong>注意此时是明文传输</strong></li>
<li>客户端开始验证数字证书，可能会不断往上追溯 CA、CA 的 CA、CA 的 CA 的 CA，直到一个受信的 CA。验证完证书之后生成一个新的<code>pre-master key</code>，再使用证书中的公钥来对<code>pre-master key</code>进行加密，然后发送给服务器。<strong>注意此时是非对称加密传输</strong></li>
<li>服务器接收到客户端发送过来的非对称加密的密文，使用自己的私钥进行解密，获得了<code>pre-master key</code>。<strong>注意此时是非对称加密传输</strong></li>
<li>到这里为止，服务器和客户端都有三组数字，**分别是客户端的随机数、服务器的随机数和pre-master key。**其中由于客户端的随机数和服务器的随机数都是使用明文传输，所以这两个数字是有被暴露的风险的，但是由于<code>pre-master key</code>是使用非对称加密传输，十分安全，所以将这三者结合，使用之前协商好的特定的算法就可以生成一个密钥，这个密钥称为<code>shared secert</code>。也就是之后用来对称加密的密钥。</li>
<li>客户端在计算出对称加密的密钥之后，使用该密钥进行对称加密通信，告知服务器之后都使用该密钥进行对称加密。<strong>注意此时是对称加密传输</strong></li>
<li>服务器接收到密文后，使用之前计算出的密钥来进行对称解密，解密成功之后，再使用该密钥进行对称加密通信。告知客户端密钥确认无误，可以使用该密钥进行通信。<strong>注意此时是对称加密传输</strong></li>
<li>至此，整个TLS的握手过程完整，之后就可以开始对称加密的通信了。</li>
</ul>
<h2 id="参考文章"><a class="header-anchor" href="#参考文章"></a>参考文章</h2>
<ul>
<li><a href="https://blog.csdn.net/whuslei/article/details/6667471">TCP协议中的三次握手和四次挥手(图解)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/72587882">关于 TCP/IP，必知必会的10个问题</a></li>
</ul>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2021-03-13T16:00:00.000Z" itemprop="datePublished">2021-03-14</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/">专业课</a>
        </div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-运维/应急响应&amp;Linux入侵检测"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2021/03/08/%E8%BF%90%E7%BB%B4/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94&Linux%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/">应急响应&amp;Linux入侵检测</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="思路"><a class="header-anchor" href="#思路"></a>思路</h2>
<h3 id="准备"><a class="header-anchor" href="#准备"></a>准备</h3>
<p>准备检测工具和人员</p>
<h3 id="检测与分析"><a class="header-anchor" href="#检测与分析"></a>检测与分析</h3>
<p>紧急事件监测，包括防火墙、系统、web服务器、IDS/WAF/SIEM中的日志，不正常或者是执行了越权操作的用户</p>
<p>甚至还有管理员的报告(收到的邮件和短信)， 从这些数据中判断出受灾面积和攻击者入侵的点</p>
<h3 id="抑制缓解"><a class="header-anchor" href="#抑制缓解"></a>抑制缓解</h3>
<p>首先先控制受害范围，不要让攻击的影响继续蔓延到其他的IT资产和业务环境，切记不要直接一股脑的投入全部精力到封堵后门。</p>
<h3 id="攻击根除"><a class="header-anchor" href="#攻击根除"></a>攻击根除</h3>
<p>紧接着要做的是去寻找根源原因，彻底解决，封堵攻击源，把业务恢复到正常水平</p>
<h3 id="业务恢复"><a class="header-anchor" href="#业务恢复"></a>业务恢复</h3>
<h3 id="事件跟踪"><a class="header-anchor" href="#事件跟踪"></a>事件跟踪</h3>
<p>根据各种监控去确定没有其他的攻击行为和攻击向量，紧接着就是开会反省此次事件，写报告，持续改进工作流程</p>
<h2 id="入侵排查"><a class="header-anchor" href="#入侵排查"></a>入侵排查</h2>
<h3 id="Linux常用检查命令"><a class="header-anchor" href="#Linux常用检查命令"></a>Linux常用检查命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>last</td>
<td>显示的是目前与过去登入系统的用户相关信息</td>
</tr>
<tr>
<td>lastlog</td>
<td>显示所有用户的登录情况</td>
</tr>
<tr>
<td>lastb</td>
<td>显示用户错误的登录列表</td>
</tr>
<tr>
<td>who</td>
<td>显示的是当前登录的用户</td>
</tr>
<tr>
<td>w</td>
<td>比who显示多一些内容，比如用户当前执行的命令，cpu信息</td>
</tr>
<tr>
<td>history</td>
<td>查看历史命令记录</td>
</tr>
</tbody>
</table>
<h3 id="排查过程"><a class="header-anchor" href="#排查过程"></a>排查过程</h3>
<ul>
<li>
<p>检查账号及登录情况</p>
<p>见这篇文章：<a href="https://dawnyh99.github.io/2021/03/07/%E8%BF%90%E7%BB%B4/Linux%E7%B3%BB%E7%BB%9F%E5%8A%A0%E5%9B%BA/">Linux系统加固</a></p>
</li>
<li>
<p>检查历史命令</p>
</li>
</ul>
<pre><code class="language-bash">cat ~/bash_history &gt;&gt; history.txt
</code></pre>
<ul>
<li>检查网络连接/开放端口</li>
</ul>
<pre><code class="language-bash">netstat -antlp | more

#查看 PID 所对应的进程文件路径
file /proc/$PID/exe
</code></pre>
<ul>
<li>检查异常进程</li>
</ul>
<pre><code class="language-bash">ps aux | grep pid
</code></pre>
<p><img src="/2021/03/08/%E8%BF%90%E7%BB%B4/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94&Linux%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/image-20210313142418258.png" alt="image-20210313142418258"></p>
<ul>
<li>检查开机启动项</li>
</ul>
<pre><code class="language-bash">ls /etc/init.d/

ls -l /etc/rc3.d/
ls -l /etc/rc5.d/
</code></pre>
<ul>
<li>检查定时任务</li>
</ul>
<pre><code class="language-bash">ls -al /var/spool/cron/* 
cat /etc/crontab
/etc/cron.d/*
/etc/cron.daily/* 
/etc/cron.hourly/* 
/etc/cron.monthly/*
/etc/cron.weekly/

#查看目录下所有文件
more /etc/cron.d/*

/etc/anacrontab
/var/spool/anacron/*
</code></pre>
<ul>
<li>检查服务</li>
</ul>
<pre><code class="language-bash">#CentOS
chkconfig  --list  #查看服务自启动状态，可以看到所有的RPM包安装的服务
#Debian
service --status-all
systemctl list-units
#源码包安装的服务位置
/usr/local/
</code></pre>
<ul>
<li>
<p>检查异常文件</p>
<ul>
<li>查看敏感目录，如/tmp目录下的文件，同时注意隐藏文件夹，以“…”为名的文件夹具有隐藏属性</li>
<li>针对可疑文件可以使用<code>stat</code>查看创建修改时间</li>
<li>发现WebShell、远控木马的创建时间</li>
</ul>
<p>找出同一时间范围内创建的文件？</p>
</li>
</ul>
<pre><code class="language-bash">find ./ -iname &quot;*&quot; -atime 1 -type f 
#找出 ./ 下一天前访问过的文件
</code></pre>
<ul>
<li>检查日志文件</li>
</ul>
<p>日志默认存放位置：/var/log/</p>
<p>查看日志配置情况：more /etc/rsyslog.conf</p>
<table>
<thead>
<tr>
<th style="text-align:center">日志文件</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/var/log/cron</td>
<td style="text-align:center">记录系统定时任务相关的日志</td>
</tr>
<tr>
<td style="text-align:center">/var/log/message</td>
<td style="text-align:center">记录Linux操作系统常见的系统和服务错误信息(首要检查对象)</td>
</tr>
<tr>
<td style="text-align:center">/var/log/syslog</td>
<td style="text-align:center">只记录警告信息，常常是系统出问题的信息</td>
</tr>
<tr>
<td style="text-align:center">/var/log/btmp</td>
<td style="text-align:center">记录<strong>错误登录（登陆失败）<strong>日志；使用</strong>lastb</strong>命令查看</td>
</tr>
<tr>
<td style="text-align:center"><strong>/var/log/lastlog</strong></td>
<td style="text-align:center">记录系统中所有用户最后一次成功登录时间，使用<strong>lastlog</strong>命令查看</td>
</tr>
<tr>
<td style="text-align:center"><strong>/var/log/wtmp</strong></td>
<td style="text-align:center">永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件；用<strong>last</strong>命令来查看</td>
</tr>
<tr>
<td style="text-align:center"><strong>/var/log/utmp</strong></td>
<td style="text-align:center">只记录<strong>当前登录用户</strong>的信息；使用<strong>w,who,users</strong>等命令来查询</td>
</tr>
<tr>
<td style="text-align:center">/var/log/secure</td>
<td style="text-align:center">记录验证和授权方面的信息，如SSH登录，su切换用户，sudo授权，甚至添加用户和修改用户密码</td>
</tr>
<tr>
<td style="text-align:center">/var/log/apache2/error.log</td>
<td style="text-align:center">apache错误日志，如果安装有modsecurity那么其攻击拦截日志也存在这里</td>
</tr>
</tbody>
</table>
<h3 id="Webshell排查"><a class="header-anchor" href="#Webshell排查"></a>Webshell排查</h3>
<p>排查工具：河马 - - <a href="https://www.shellpub.com/">https://www.shellpub.com/</a></p>
<p>除了使用排查工具扫描，还是要手动查看Web目录下的可解析执行文件</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2021-03-07T16:00:00.000Z" itemprop="datePublished">2021-03-08</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/%E8%BF%90%E7%BB%B4/">运维</a>
        </div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BF%90%E7%BB%B4/" rel="tag">运维</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-运维/Linux系统加固"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2021/03/07/%E8%BF%90%E7%BB%B4/Linux%E7%B3%BB%E7%BB%9F%E5%8A%A0%E5%9B%BA/">Linux系统加固</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="账号安全"><a class="header-anchor" href="#账号安全"></a>账号安全</h2>
<p><strong>账号相关文件</strong></p>
<pre><code class="language-bash">/etc/passwd    -- 记录了系统中各用户的一些基本属性，root可写，所有用户可读
/etc/shadow    -- 记录了所有用户的密码
/etc/group     -- 记录了用户组属性

1、检查是否存在除root之外UID为0的用户：
awk -F ':' '($3==0){print $1}' /etc/passwd

2、查询可以远程登录的帐号信息
awk '/\$1|\$6/{print $1}' /etc/shadow

3、除root帐号外，其他帐号是否存在sudo权限。如非管理需要，普通帐号应删除sudo权限
more /etc/sudoers | grep -v &quot;^#\|^$&quot; | grep &quot;ALL=(ALL)&quot;

4、禁用或删除多余及可疑的帐号
usermod -L user    #禁用帐号，帐号无法登录，/etc/shadow第二栏为!开头
userdel -r user    #将删除user用户，并且将/home目录下的user目录一并删除
</code></pre>
<p><strong>修改密码策略</strong></p>
<p>vim /etc/login.defs</p>
<pre><code>PASS_MAX_DAYS      90               密码最长有效期
PASS_MIN_DAYS      10               密码修改之间最小的天数
PASS_MIN_LEN       8                密码长度
PASS_WARN_AGE      7                口令失效前多少天开始通知用户修改密码
</code></pre>
<p><strong>设置密码强度</strong></p>
<p>vim  /etc/pam.d/common-password</p>
<p>将原本的</p>
<pre><code>password requisite  pam_cracklib.so
</code></pre>
<p>修改为至少包含一个数字、一个小写字母、一个大写字母、一个特殊字符、且密码长度&gt;=8:</p>
<pre><code>password requisite  pam_cracklib.so try_first_pass retry=3 dcredit=-1 lcredit=-1 ucredit=-1 ocredit=-1 minlen=8  
</code></pre>
<p><strong>限制用户登陆</strong></p>
<p>vim  /etc/hosts.deny，若禁止192.168.0.1对服务器进行ssh的登陆，添加如下内容</p>
<pre><code>sshd : 192.168.0.1  
</code></pre>
<p><strong>限制登陆次数</strong></p>
<p>应对暴力破解，我们可以限制登陆次数为5，超过5次登陆失败就锁定**。**vim /etc/pam.d/sshd，在 #%PAM-1.0 的下面，加入下面的内容，表示当密码输入错误达到3次，就锁定用户150秒，如果root用户输入密码错误达到3次，锁定300秒。</p>
<pre><code>auth required pam_tally2.so deny=3 unlock_time=150 even_deny_root root_unlock_time300
</code></pre>
<p>锁定用户的管理：</p>
<pre><code>pam_tally2                             查看被锁定的用户

pam_tally2  --reset  -u  username      将被锁定的用户解锁
</code></pre>
<h2 id="目录-文件权限"><a class="header-anchor" href="#目录-文件权限"></a>目录&amp;文件权限</h2>
<p><strong>存储用户信息的文件</strong></p>
<p>在用户登陆中非常重要的三个文件</p>
<p>/etc/passwd 必须所有用户都可读，root用户可写 –rw-r—r— 权限值为644</p>
<p>/etc/shadow 只有root可读 –r-------- 权限值为400</p>
<p>/etc/group 必须所有用户都可读，root用户可写 –rw-r—r— 权限值为644</p>
<pre><code>chmod 644 /etc/passwd
chmod 400 /etc/shadow
chmod 644 /etc/group
</code></pre>
<p><strong>文件缺省权限设置</strong></p>
<pre><code class="language-bash">cp /etc/profile /etc/profile.bak
vim   /etc/profile
#添加以下内容
umask 022	#umask与文件创建后的默认所有权限异或结果即为初始权限
			#root创建的文件默认所有权限为666，666~022=644 (root可读可写，其他用户只可读)

#执行/etc/profile中的shell命令，直接执行umask命令设置的话重启失效
source  /etc/profile
</code></pre>
<h2 id="应用安全设置"><a class="header-anchor" href="#应用安全设置"></a>应用安全设置</h2>
<p><strong>FTP</strong></p>
<p>禁止匿名FTP</p>
<p>vim  /etc/vsftpd/vsftpd.conf</p>
<pre><code>anonymous_enable=NO    #如果存在anonymous_enable则修改,如果不存在则手动增加
</code></pre>
<p><strong>SSH</strong></p>
<ol>
<li>在sshd_config禁止root访问和使用sshv2来让ssh更加安全</li>
</ol>
<p>vim /etc/ssh/sshd_config</p>
<pre><code>PermitRootLogin    no
</code></pre>
<ol start="2">
<li>设置SSH空闲超时退出时间,可降低未授权用户访问其他用户ssh会话的风险</li>
</ol>
<p>编辑/etc/ssh/sshd_config，将ClientAliveInterval 设置为300到900，即5-15分钟，将ClientAliveCountMax设置为0-3之间。</p>
<pre><code>ClientAliveInterval 600
ClientAliveCountMax 2
</code></pre>
<ol start="3">
<li>设置较低的Max AuthTrimes参数将降低SSH服务器被暴力攻击成功的风险</li>
</ol>
<p>在/etc/ssh/sshd_config中取消MaxAuthTries注释符号#，设置最大密码尝试失败次数3-6，建议为4：</p>
<pre><code>MaxAuthTries 4
</code></pre>
<p><strong>TELNET</strong></p>
<p>Telnet使用明文传输数据，存在安全隐患，应该避免使用</p>
<p>执行如下语句，查看telnet服务是否在运行</p>
<pre><code class="language-bash">netstat -na | grep &quot;:23&quot;
</code></pre>
<p>若正在运行则关闭Telnet服务，在/etc/xinetd.d/telnet中进行配置</p>
<pre><code>disable=yes
</code></pre>
<h2 id="网络设置"><a class="header-anchor" href="#网络设置"></a>网络设置</h2>
<p><strong>IPTABLES</strong></p>
<p>根据需求合理配置防火墙</p>
<p>比如将<code>INPUT</code>链默认规则设为<code>DROP</code>，再添加规则将需要开放的端口设置为<code>ACCEPT</code></p>
<pre><code class="language-bash">#将INPUT链默认规则设置为DROP
iptables -P INPUT DROP

#按需添加规则使得开放端口能够接收数据包
#开放SSH
iptables -A INPUT -p tcp --dport 22 -j ACCEPT
#开放80端口
iptables -A INPUT -p tcp --dport 80 -j ACCEPT
#...
</code></pre>
<p><strong>TCP SYN保护机制</strong></p>
<pre><code class="language-bash">echo“1”&gt;/proc/sys/net/ipv4/tcp_syncookies //默认为1，一般不用设置
</code></pre>
<p>表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2021-03-06T16:00:00.000Z" itemprop="datePublished">2021-03-07</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/%E8%BF%90%E7%BB%B4/">运维</a>
        </div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BF%90%E7%BB%B4/" rel="tag">运维</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-渗透/渗透测试基础"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2021/03/04/%E6%B8%97%E9%80%8F/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/">渗透测试基础</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="渗透思路-流程"><a class="header-anchor" href="#渗透思路-流程"></a>渗透思路/流程</h2>
<p><strong>信息收集</strong></p>
<p>a、获取域名的whois信息,获取注册者邮箱姓名电话等，丢社工库里看看有没有泄露密码，然后尝试用泄露的密码进行登录后台。用邮箱做关键词进行丢进搜索引擎。利用搜索到的关联信息找出其他邮箱进而得到常用社交账号。社工找出社交账号，里面或许会找出管理员设置密码的习惯 。利用已有信息生成专用字典。</p>
<p>b、查询服务器旁站以及子域名站点，因为主站一般比较难，所以先看看旁站有没有通用性的cms或者其他漏洞。</p>
<p>c、查看服务器操作系统版本，web中间件，看看是否存在已知的漏洞，比如IIS，APACHE,NGINX的解析漏洞</p>
<p>d、查看IP，进行IP地址端口扫描，对响应的端口进行漏洞探测，比如 rsync,心脏出血，mysql,ftp,ssh弱口令等。</p>
<p>e、扫描网站目录结构，看看是否可以遍历目录，或者敏感文件泄漏，比如php探针</p>
<p>f、google hack 进一步探测网站的信息，后台，敏感文件</p>
<p><strong>漏洞扫描</strong></p>
<p>开始检测漏洞，如XSS,XSRF,sql注入，代码执行，命令执行，越权访问，目录读取，任意文件读取，下载，文件包含，远程命令执行，弱口令，上传，编辑器漏洞，暴力破解等</p>
<p><strong>漏洞利用</strong></p>
<p>利用以上的方式拿到webshell，或者其他权限</p>
<p><strong>权限提升</strong></p>
<p>提权服务器，比如windows下mysql的udf提权，serv-u提权，windows低版本的漏洞，如iis6,pr,巴西烤肉，linux脏牛漏洞，linux内核版本漏洞提权，linux下的mysql system提权以及oracle低权限提权</p>
<p><strong>日志清理</strong></p>
<p>总结报告及修复方案</p>
<h2 id="资产搜集"><a class="header-anchor" href="#资产搜集"></a>资产搜集</h2>
<h3 id="子域名搜集"><a class="header-anchor" href="#子域名搜集"></a>子域名搜集</h3>
<ul>
<li>工具1：Layer子域名挖掘机5.0
<ul>
<li>支持服务接口、暴力搜索、同服挖掘三种模式</li>
<li>支持打开网站、复制域名、复制IP、复制CDN</li>
<li>支持导出检测结果等功能</li>
</ul>
</li>
<li>工具2：SubdomainsBurte
<ul>
<li><a href="https://github.com/y1ng1996/lijiejie_subDomainsBrute">https://github.com/y1ng1996/lijiejie_subDomainsBrute</a></li>
<li>暴力枚举，速度快</li>
</ul>
</li>
<li>网站：SSL证书查询\网络空间搜索引擎
<ul>
<li><a href="https://censys.io">censys</a></li>
<li><a href="https://crt.sh">crt.sh</a></li>
<li><a href="https://dnsdumpster.com/">dnsdumpster</a></li>
<li><a href="https://www.shodan.io/">shodan</a></li>
<li><a href="https://fofa.so/">fofa</a></li>
</ul>
</li>
</ul>
<h3 id="绕过CDN找真实IP"><a class="header-anchor" href="#绕过CDN找真实IP"></a>绕过CDN找真实IP</h3>
<ul>
<li>网络空间搜索引擎
<ul>
<li><a href="https://www.zoomeye.org/">钟馗之眼</a></li>
<li><a href="https://www.webscan.cc/">webscan</a></li>
<li><a href="https://censys.io">censys</a></li>
<li><a href="https://www.shodan.io/">shodan</a></li>
<li><a href="https://www.dnsdb.io/zh-cn">全球DNS搜索引擎</a></li>
<li><a href="https://fofa.so/">fofa</a></li>
<li><a href="http://lookahead.surfwax.com/">Surfwax元搜索</a></li>
<li><a href="https://archive.org/web/">Way Back Machine</a></li>
</ul>
</li>
<li>让目标主动连接我们
<ul>
<li>RSS订阅</li>
<li>邮件服务器</li>
</ul>
</li>
</ul>
<h3 id="IP段整理"><a class="header-anchor" href="#IP段整理"></a>IP段整理</h3>
<ul>
<li>通过<a href="http://ipwhois.cnnic.net.cn/">中国互联网络信息中心</a>查询</li>
<li>纯真IP数据库</li>
</ul>
<h3 id="C段查询、旁站查询"><a class="header-anchor" href="#C段查询、旁站查询"></a>C段查询、旁站查询</h3>
<ul>
<li><a href="https://www.webscan.cc/">webscan</a></li>
</ul>
<h2 id="端口扫描及利用"><a class="header-anchor" href="#端口扫描及利用"></a>端口扫描及利用</h2>
<table>
<thead>
<tr>
<th>端口号</th>
<th>对应服务</th>
<th>端口号</th>
<th>对应服务</th>
</tr>
</thead>
<tbody>
<tr>
<td>21</td>
<td>ftp</td>
<td>2601 2604</td>
<td>zebra路由</td>
</tr>
<tr>
<td>22</td>
<td>ssh</td>
<td>3306</td>
<td>MySQL</td>
</tr>
<tr>
<td>23</td>
<td>telnet</td>
<td>3312</td>
<td>kangle主机管理系统</td>
</tr>
<tr>
<td>80</td>
<td>http</td>
<td>3389</td>
<td>远程桌面</td>
</tr>
<tr>
<td>80-89</td>
<td>web</td>
<td>4440</td>
<td>rundeck</td>
</tr>
<tr>
<td>161</td>
<td>snmp</td>
<td>5432</td>
<td>PostgreSQL</td>
</tr>
<tr>
<td>389</td>
<td>LDAP</td>
<td>5900</td>
<td>vnc</td>
</tr>
<tr>
<td>443</td>
<td>https（心脏滴血）</td>
<td>6379</td>
<td>redis未授权</td>
</tr>
<tr>
<td>445</td>
<td>SMB（永恒之蓝）</td>
<td>7001 7002</td>
<td>WebLogic默认弱口令，反序列</td>
</tr>
<tr>
<td>512 513 514</td>
<td>Rexec</td>
<td>8080</td>
<td>tomcat</td>
</tr>
<tr>
<td>873</td>
<td>Rsync未授权</td>
<td>8080 8089 9090</td>
<td>JBOSS</td>
</tr>
<tr>
<td>1025</td>
<td>NFS</td>
<td>8161</td>
<td>activemq未授权访问</td>
</tr>
<tr>
<td>1433</td>
<td>MSSQL</td>
<td>27017 27018</td>
<td>Mongodb未授权访问</td>
</tr>
<tr>
<td>1521</td>
<td>Oracle</td>
<td>50000</td>
<td>SAP命令执行</td>
</tr>
</tbody>
</table>
<p><strong>利用 nmap+脚本快速捡洞和检洞</strong></p>
<pre><code class="language-shell">系统漏洞检测：nmap --script smb-check-vulns.nse -p 192.168.1.1
数据库密码检测：nmap --script=brute 192.168.1.1
收集应用服务信息：nmap -sC 192.168.1.1
检测常见漏洞：nmap --script=vuln 192.168.1.1
检测部分应用的弱口令：nmap --script=auth 192.168.1.1
</code></pre>
<h2 id="指纹搜集"><a class="header-anchor" href="#指纹搜集"></a>指纹搜集</h2>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2021-03-03T16:00:00.000Z" itemprop="datePublished">2021-03-04</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/%E6%B8%97%E9%80%8F/">渗透</a>
        </div>
    
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-杂记/蓝队基础"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2021/03/04/%E6%9D%82%E8%AE%B0/%E8%93%9D%E9%98%9F%E5%9F%BA%E7%A1%80/">蓝队基础</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="基础知识"><a class="header-anchor" href="#基础知识"></a>基础知识</h2>
<h3 id="漏洞原理"><a class="header-anchor" href="#漏洞原理"></a>漏洞原理</h3>
<h4 id="XSS"><a class="header-anchor" href="#XSS"></a>XSS</h4>
<ul>
<li>
<p>原理</p>
<p>应用程序或API包括未经验证和未经转义的用户输入，作为HTML输出的一部分</p>
</li>
<li>
<p>危害</p>
<p>一个成功的攻击可以让攻击者在受害者的浏览器中执行任意的HTML和JavaScript。攻击者可以获取受害者的cookie等</p>
<p>JavaScript脚本可以跨域访问，<code>&lt;script&gt;</code>标签可以请求外部的js脚本，并且外部js脚本请求来之后是被认为与被攻击服务器同源的，所以可以访问当前服务器的cookie，所以反射型XSS的利用方式：构造恶意链接，将请求恶意js脚本的<code>&lt;script&gt;</code>作为参数传给服务器，在我们的恶意js脚本中可以使用加载图片的方式，将cookie作为参数传给我们的接收服务器</p>
</li>
</ul>
<p>获取cookie：<a href="https://blog.csdn.net/l31299/article/details/72792613">https://blog.csdn.net/l31299/article/details/72792613</a></p>
<pre><code>document.cookie
</code></pre>
<ul>
<li>
<p>三种类型比较</p>
<p>反射型 XSS 一般是攻击者通过特定手法（如电子邮件），诱使用户去访问一个包含恶意代码的 URL，当受害者点击这些专门设计的链接的时候，恶意代码会直接在受害者主机上的浏览器执行。此类 XSS 通常出现在网站的搜索栏、用户登录口等地方，常用来窃取客户端 Cookies 或进行钓鱼欺骗。</p>
<p>客户端的脚本程序可以动态地检查和修改页面内容，而不依赖于服务器端的数据。例如客户端如从 URL 中提取数据并在本地执行，如果用户在客户端输入的数据包含了恶意的 JavaScript 脚本，而这些脚本没有经过适当的过滤和转义，那么应用程序就可能受到 DOM-based XSS 攻击。需要特别注意以下的用户输入源 document.URL、 location.hash、 location.search、 document.referrer 等。</p>
<p>存储型XSS攻击即攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。这就意味着只要访问了这个页面的访客，都有可能会执行这段恶意脚本，因此储存型XSS的危害会更大。存储型 XSS 一般出现在网站留言、评论、博客日志等交互处，恶意脚本存储到客户端或者服务端的数据库中。</p>
</li>
<li>
<p>防御方法</p>
<p>过滤输入和转义处理</p>
<p>第一、在输入方面对所有用户提交内容进行输入验证，提交内容包括URL、查询关键字、http头、post数据等</p>
<p>第二、在输出方面，使用<code>htmlentities()</code>函数进行转义标签内的内容不会解释，直接显示。</p>
</li>
</ul>
<h4 id="CSRF"><a class="header-anchor" href="#CSRF"></a>CSRF</h4>
<ul>
<li>
<p>防御方法</p>
<p>检查referer：敏感操作来源不能为本站点之外</p>
<p>设置token：用以检查请求来自当前页面</p>
</li>
<li>
<p>referer检测绕过</p>
<p>http头不包含referer：使用<code>data:</code>协议</p>
<pre><code class="language-html">&lt;html&gt;
    &lt;body&gt;
       &lt;iframe src=&quot;data:text/html;base64,PGZvcm0gbWV0aG9kPXBvc3QgYWN0aW9uPWh0dHA6Ly9hLmIuY29tL2Q+PGlucHV0IHR5cGU9dGV4dCBuYW1lPSdpZCcgdmFsdWU9JzEyMycvPjwvZm9ybT48c2NyaXB0PmRvY3VtZW50LmZvcm1zWzBdLnN1Ym1pdCgpOzwvc2NyaXB0Pg==&quot;&gt;
    &lt;/body&gt; 
&lt;/html&gt;
</code></pre>
<p>非空referer</p>
<p>不断尝试，如果后端只验证referer中是否存在指定关键字，那么我们通过新建文件夹使文件夹名为该域名，文件夹下存放csrf攻击代码即可</p>
</li>
</ul>
<h4 id="SSRF"><a class="header-anchor" href="#SSRF"></a>SSRF</h4>
<ul>
<li>
<p>XXE漏洞</p>
<p>SSRF（服务器端请求伪造）是一种攻击模式</p>
<p>XXE（XML External Entity XML外部实体）则是一种攻击手法</p>
<p>XXE漏洞利用了SSRF，让服务器向其他服务器应用请求XML外部实体（DTD文件）。</p>
</li>
<li>
<p>RFI</p>
<p>RFI（远程文件包含）也是SSRF的一种形式。</p>
</li>
</ul>
<h4 id="SQLI"><a class="header-anchor" href="#SQLI"></a>SQLI</h4>
<p>报错注入函数</p>
<pre><code>floor()
extractvalue()
updatexml()
exp()
</code></pre>
<p><strong>order by 注入</strong></p>
<p>有些排序功能通过sql里的order by语句来实现，我们可以利用这一点，控制order by后面的内容</p>
<p>order by配合union进行盲注：通过排序结果逐字符比较得到结果</p>
<h3 id="端口号"><a class="header-anchor" href="#端口号"></a>端口号</h3>
<table>
<thead>
<tr>
<th>端口号</th>
<th>对应服务</th>
<th>端口号</th>
<th>对应服务</th>
</tr>
</thead>
<tbody>
<tr>
<td>21</td>
<td>ftp</td>
<td>2601 2604</td>
<td>zebra路由</td>
</tr>
<tr>
<td>22</td>
<td>ssh</td>
<td>3306</td>
<td>MySQL</td>
</tr>
<tr>
<td>23</td>
<td>telnet</td>
<td>3312</td>
<td>kangle主机管理系统</td>
</tr>
<tr>
<td>80</td>
<td>http</td>
<td>3389</td>
<td>远程桌面</td>
</tr>
<tr>
<td>80-89</td>
<td>web</td>
<td>4440</td>
<td>rundeck</td>
</tr>
<tr>
<td>161</td>
<td>snmp</td>
<td>5432</td>
<td>PostgreSQL</td>
</tr>
<tr>
<td>389</td>
<td>LDAP</td>
<td>5900</td>
<td>vnc</td>
</tr>
<tr>
<td>443</td>
<td>https（心脏滴血）</td>
<td>6379</td>
<td>redis未授权</td>
</tr>
<tr>
<td>445</td>
<td>SMB（永恒之蓝）</td>
<td>7001 7002</td>
<td>WebLogic默认弱口令，反序列</td>
</tr>
<tr>
<td>512 513 514</td>
<td>Rexec</td>
<td>8080</td>
<td>tomcat</td>
</tr>
<tr>
<td>873</td>
<td>Rsync未授权</td>
<td>8080 8089 9090</td>
<td>JBOSS</td>
</tr>
<tr>
<td>1025</td>
<td>NFS</td>
<td>8161</td>
<td>activemq未授权访问</td>
</tr>
<tr>
<td>1433</td>
<td>MSSQL</td>
<td>27017 27018</td>
<td>Mongodb未授权访问</td>
</tr>
<tr>
<td>1521</td>
<td>Oracle</td>
<td>50000</td>
<td>SAP命令执行</td>
</tr>
</tbody>
</table>
<h2 id="安全工具"><a class="header-anchor" href="#安全工具"></a>安全工具</h2>
<h3 id="扫描工具"><a class="header-anchor" href="#扫描工具"></a>扫描工具</h3>
<ul>
<li>
<p>AWVS</p>
</li>
<li>
<p>NESSUS</p>
</li>
</ul>
<pre><code class="language-shell">#启动nessus
service nessusd start
firefox https://localhost:8834

#找回用户名密码
cd /opt/nessus/sbin/
./nessuscli lsuser
./nessuscli chpasswd [username]
</code></pre>
<ul>
<li>nmap</li>
</ul>
<pre><code>//扫描C段
nmap 192.168.233.1/24
//根据IP地址范围扫描
nmap 192.168.1-10.128-140
//扫描多个目标
nmap 192,168.233.1 192.168.23.128

//参数
-p(小写)	指定端口
-O、-A	探测操作系统
-T	超时时间
</code></pre>
<ul>
<li>sqlmap</li>
</ul>
<pre><code>sqlmap.py -u &quot;http://......&quot; -p 可变的参数（如id等） --cookie &quot;......&quot; 

//当前用户 --current-user
//当前数据库 --current-db
sqlmap.py -u &quot;http://127.0.0.1/DVWA-1.9/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; -p &quot;id&quot; --cookie &quot;security=low;PHPSESSID=ke78jnt9j7mts8te23v69u4nh4&quot; --current-user --current-db

//-D指定数据库 然后--tables查询表
sqlmap.py -u &quot;http://127.0.0.1/DVWA-1.9/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; -p &quot;id&quot; --cookie &quot;security=low;PHPSESSID=ke78jnt9j7mts8te23v69u4nh4&quot; -D &quot;dvwa&quot; --tables

//-D -T指定数据库和表 然后--columns查询列
sqlmap.py -u &quot;http://127.0.0.1/DVWA-1.9/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; -p &quot;id&quot; --cookie &quot;security=low;PHPSESSID=ke78jnt9j7mts8te23v69u4nh4&quot; -D &quot;dvwa&quot; -T &quot;users&quot; --columns

//-C指定列然后--dump出结果
sqlmap.py -u &quot;http://127.0.0.1/DVWA-1.9/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; -p &quot;id&quot; --cookie &quot;security=low;PHPSESSID=ke78jnt9j7mts8te23v69u4nh4&quot; -D &quot;dvwa&quot; -T &quot;users&quot; -C &quot;user,password&quot; --dump

//get WebShell
sqlmap.py -u &quot;http://127.0.0.1/DVWA-1.9/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; -p &quot;id&quot; --cookie &quot;security=low;PHPSESSID=ke78jnt9j7mts8te23v69u4nh4&quot; -D &quot;dvwa&quot; -T &quot;users&quot; -C &quot;user,password&quot; --os-shell
</code></pre>
<h2 id="安全设备"><a class="header-anchor" href="#安全设备"></a>安全设备</h2>
<h3 id="WAF"><a class="header-anchor" href="#WAF"></a>WAF</h3>
<ul>
<li>本地WAF
<ul>
<li>modSecurity
<ul>
<li>作为nginx的模块，需要编译安装</li>
</ul>
</li>
<li>…</li>
</ul>
</li>
<li>云WAF
<ul>
<li>无需用户更新</li>
<li>成本低</li>
<li>可能被绕过（网站的真实IP被获取</li>
<li>阿里云WAF…</li>
</ul>
</li>
<li>部署方式
<ul>
<li>反向代理
<ul>
<li>正向代理隐藏真实客户端，反向代理隐藏真实服务端</li>
</ul>
</li>
<li>步骤
<ul>
<li>购买阿里云WAF产品</li>
<li>在阿里云WAF中添加域名</li>
<li>在服务器中设置防火墙放行来自WAF的流量</li>
<li>在拥有域名的DNS服务商处修改DNS解析</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="蜜罐"><a class="header-anchor" href="#蜜罐"></a>蜜罐</h3>
<p>Github 开源蜜罐 —— HFish</p>
<p>安装包https://github.com/hacklcx/HFish/releases</p>
<p>安装成功后启动服务即可</p>
<p>蜜罐的作用</p>
<ul>
<li>获取攻击者IP、攻击过程等信息</li>
<li>溯源取证（jsonp获取攻击者cookie…</li>
</ul>
<h3 id="态势感知平台"><a class="header-anchor" href="#态势感知平台"></a>态势感知平台</h3>
<p>多种防护系统、流量监测系统的接入整合及可视化，监控全局流量，攻击事件报警等</p>
<h3 id="IPS-IDS"><a class="header-anchor" href="#IPS-IDS"></a>IPS/IDS</h3>
<p>入侵防御系统 / 入侵检测系统。IDS工作在网络层旁路，IPS则可旁路可串结（出口/入口）。IDS只能检测，IPS则是具备截断能力的IDS。</p>
<p>IPS的旁路防护原理很简单，其经典代表如开源的Snort，就是在网络上分析流量，发现符合规则的流量则冒充服务端回包响应客户端实现阻断或者替换的目的，这是一种典型的链路劫持手法。</p>
<p><strong>绕过方法</strong></p>
<p>TCP分片、IP分片等</p>
<h2 id="攻防技术"><a class="header-anchor" href="#攻防技术"></a>攻防技术</h2>
<h3 id="常用渗透方法"><a class="header-anchor" href="#常用渗透方法"></a>常用渗透方法</h3>
<ul>
<li>利用弱口令以及通用口令</li>
<li>利用互联网边界渗透内网</li>
<li>利用通用产品组件漏洞</li>
<li>利用安全产品0Day漏洞</li>
<li>利用社工钓鱼</li>
<li>…</li>
</ul>
<h3 id="应急响应-入侵检测技术"><a class="header-anchor" href="#应急响应-入侵检测技术"></a>应急响应&amp;入侵检测技术</h3>
<p>详见这篇博客：<a href="https://dawnyh99.github.io/2021/03/08/%E8%BF%90%E7%BB%B4/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94&amp;Linux%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/">应急响应&amp;Linux入侵检测</a></p>
<h3 id="CDN"><a class="header-anchor" href="#CDN"></a>CDN</h3>
<p>CDN是一个分布式边缘网络，网站A使用了CDN，用户根据域名访问网站A时，如果用户本地DNS没有网站A的路由信息，则向DNS授权服务器请求网站A的IP地址，而DNS授权服务器则根据用户的位置，选择速度最快的CDN加速节点的IP地址传回给用户，那么用户即访问了该CDN节点，而非源站。当CDN节点中没有缓存源站的部分内容时，则会向源站请求。</p>
<p><strong>判断目标网站是否使用CDN</strong></p>
<ul>
<li>使用多地ping该网站域名，若得到的IP不同，则其可能使用了CDN</li>
<li>nslookup返回的域名解析对应多个IP多半是使用了CDN</li>
</ul>
<p><strong>绕过CDN获取网站真实IP</strong></p>
<ul>
<li>DNS缓存历史查询网站</li>
<li>网络空间搜索引擎
<ul>
<li>fofa</li>
<li>钟馗之眼</li>
<li>…</li>
</ul>
</li>
<li>查询子域名IP，可能子站并没有做CDN，可能与主站处于同一C段</li>
</ul>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2021-03-03T16:00:00.000Z" itemprop="datePublished">2021-03-04</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/%E6%9D%82%E8%AE%B0/">杂记</a>
        </div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-编程语言/Python/Python实战篇"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2021/01/31/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/Python%E5%AE%9E%E6%88%98%E7%AF%87/">Python实战</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="Python爬虫"><a class="header-anchor" href="#Python爬虫"></a>Python爬虫</h2>
<p>从<a href="http://www.csu.edu.cn/index/xndh.htm">中南大学校内导航</a>中爬取校内网站名称和对应的链接。</p>
<p>爬虫程序主要分为html页面获取和数据提取两个部分，接下来分别说明其实现方法。</p>
<h3 id="获取网页"><a class="header-anchor" href="#获取网页"></a>获取网页</h3>
<p>使用requests库来获取网站的html页面</p>
<pre><code class="language-python">import requests
url = &quot;http://www.csu.edu.cn/index/xndh.htm&quot;
try:
    r = requests.get(url)
    r.raise_for_status()				#检查r的状态码是否为200，若不是则抛出异常
    r.encoding = r.apparent_encoding	#设置编码方式为从内容中分析出的编码方式
except:
    print(&quot;error!&quot;)
</code></pre>
<p><img src="/2021/01/31/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/Python%E5%AE%9E%E6%88%98%E7%AF%87/20200225122713475.png" alt="img"></p>
<p>encoding是从http中的header中的charset字段中提取的编码方式，若header中没有charset字段则默认为ISO-8859-1编码模式，则无法解析中文，产生乱码</p>
<h3 id="提取内容"><a class="header-anchor" href="#提取内容"></a>提取内容</h3>
<p>利用BeautifulSoup库可以很方便地对从HTML或XML文档中提取我们想要的数据。</p>
<pre><code class="language-python">from bs4 import BeautifulSoup
html = r.text
soup = BeautifulSoup(html,'html.parser')		#将html解析成BeautifulSoup对象

#BeautifulSoup类的find_all()函数可以从文档树中找到特定的标签（tag）
#这里获得所有的a标签
for i in soup.find_all('a'):
    #tag的属性值可直接用 tag_name['属性名'] 的方式获得
    #判断链接地址是否为一个网站
    if not i['href'].find('http'):
        # 构造输出
        # tag_name.string 即 &lt;tag_name&gt;xxx&lt;/tag_name&gt; 中的xxx
        str1 = &quot;网址：&quot; + str(i['href']) + &quot;   名称：&quot; + str(i.string) + '\n'
		# 输出一条链接的地址及名称
        print(str1)
</code></pre>
<p>利用以上代码就可以实现一个简单的爬虫程序了。</p>
<p>爬虫的原理比较简单，关键在于如何对爬取到的数据进行筛选的过程。</p>
<p>之后可以尝试对网页中的链接进行递归爬取等</p>
<h3 id="链接去重"><a class="header-anchor" href="#链接去重"></a>链接去重</h3>
<h3 id="并发爬取"><a class="header-anchor" href="#并发爬取"></a>并发爬取</h3>
<h2 id="爬虫框架"><a class="header-anchor" href="#爬虫框架"></a>爬虫框架</h2>
<h3 id="scrapy"><a class="header-anchor" href="#scrapy"></a>scrapy</h3>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2021-01-30T16:00:00.000Z" itemprop="datePublished">2021-01-31</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
        </div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  
    
      <article
id="post-编程语言/Python/Python基础篇"
class="article article-type-post"
>



<div class="article-inner">
    

    <div class="article-body">
    <header class="article-title">
        <a href="/2021/01/30/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/Python%E5%9F%BA%E7%A1%80%E7%AF%87/">Python基础</a>
    </header>
    <div class="article-entry post-inner-html">
        
        <h2 id="输入输出"><a class="header-anchor" href="#输入输出"></a>输入输出</h2>
<p><strong>输出</strong></p>
<pre><code class="language-python">print('%d,%d'%(i,j),end=&quot;&quot;) # print格式化字符串
param = 'hello'
print(f'{param}') # f字符串输出参数

# 浮点数保留精度
a = 2.345
print('%.2f'%a) # 2.35 ,四舍五入
print(round(a,2)) # 2.34 ，五舍六入
</code></pre>
<p><strong>输入</strong></p>
<pre><code class="language-python">a = input(&quot;input a number!\n&quot;)
</code></pre>
<h2 id="常用字符串函数"><a class="header-anchor" href="#常用字符串函数"></a>常用字符串函数</h2>
<pre><code class="language-python"># 1.字母处理：
.upper()    # 全部大写
.lower()    # 全部小写
.swapcase()    # 大小写互换
.capitalize()    # 首字母大写，其余小写
.title()    # 首字母大写

# 2.格式化相关
.ljust(width)     # 获取固定长度，左对齐，右边不够用空格补齐
.rjust(width)     # 获取固定长度，右对齐，左边不够用空格补齐
.center(width)  # 获取固定长度，中间对齐，两边不够用空格补齐
.zfill(width)      # 获取固定长度，右对齐，左边不足用0补齐

# 3.字符串搜索相关
.find()    # 搜索指定字符串，找到则返回对应下标，没有则返回-1
.index()    # 同上，但是找不到会报错
.rfind()    # 从右边开始查找
.count()    # 统计指定的字符串出现的次数

# 4.字符串处理
.split(&quot;分割符(串)&quot;,[分割次数])	# 分割字符串，得到一个子串列表
.replace(&quot;原子串&quot;,&quot;新子串&quot;)	# 子串替换
</code></pre>
<h2 id="常用数据结构"><a class="header-anchor" href="#常用数据结构"></a>常用数据结构</h2>
<p><strong>list-列表</strong></p>
<pre><code class="language-python">a = []
a.append('a')	#在列表最后加入一个元素'a'
a.pop(0)		#删除列表中索引为0的元素
a.insert(0,'b')	#在列表索引为0的位置插入元素'b',原本该位置及以后的元素后移一位
a.index('b')	#返回元素'b'在列表中第一次出现的位置
a.count('b')	#元素'b'在列表中出现的次数
a.__len__()		#返回列表的长度
</code></pre>
<p><strong>tuple-元祖</strong></p>
<pre><code class="language-python"># 元组和列表的区别是：元组中的元素不可变；共同点是都可以使用“[]”进行取值
a = ('a','b','c')	# 创建元组
b = a[2]		# ‘c’
</code></pre>
<p><strong>dict-字典</strong></p>
<pre><code class="language-python">dict1 = {} # 创建dict
dict1['a'] = 100 # 添加元素
key_list = list(i.keys()) # 获取key列表
del dict1 # 清空dict
del dict1['a'] # 删除键值对 ———— 'a':100
</code></pre>
<p><strong>set-集合</strong></p>
<pre><code class="language-python">set1 = {1,2} # 创建set1
set1.add(3) # 新增元素，set1为 {1,2,3}
set1.add(2) # 添加set中已存在的元素，不改变set，仍为 {1,2,3}
set1.add([1,2]) # 报错，不可add可变对象
set1.remove(1) # 从set1中删去元素 1，set1变为 {2,3}
set1.remove(4) # 从set1中删去元素 4，报错，因为set1中不存在元素 4
set1.discard(3) # 从set1中删去元素 3，set1变为 {2}
set1.discard(5) # 从set1中删去元素 5，set1中不存在元素5，set1仍为 {2}，不报错

set2 = {2,3} # 创建set2
set3 = set2.uniom(set1) # 并集
set3 = set2.intersection(set1) # 交集
set3 = set2.difference(set1) # 差集
</code></pre>
<h2 id="类型转换函数"><a class="header-anchor" href="#类型转换函数"></a>类型转换函数</h2>
<pre><code class="language-python">bool()		# 根据传入的参数的逻辑值创建一个新的布尔值
int()		# 根据传入的参数创建一个新的整数
float()		# 根据传入的参数创建一个新的浮点数

bin()		# 将整数转换成2进制字符串
oct()		# 将整数转化成8进制数字符串
hex()		# 将整数转换成16进制字符串

ord()		# 返回Unicode字符对应的整数
chr()		# 返回整数所对应的Unicode字符
str()		# 返回一个对象的字符串表现形式

tuple()		# 根据传入的参数创建一个新的元组
list()		# 根据传入的参数创建一个新的列表
dict()		# 根据传入的参数创建一个新的字典
set()		# 根据传入的参数创建一个新的集合
</code></pre>
<h2 id="文件操作"><a class="header-anchor" href="#文件操作"></a>文件操作</h2>
<h3 id="文件读写"><a class="header-anchor" href="#文件读写"></a>文件读写</h3>
<pre><code class="language-python">file1 = open(&quot;file_name&quot;,&quot;${mode}&quot;)
file1.write()
file1.close
</code></pre>
<p>mode如下表所示</p>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">含义</th>
<th>文件不存在时</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>r</code></td>
<td style="text-align:center">打开文件以阅读（默认模式）</td>
<td>报错</td>
</tr>
<tr>
<td style="text-align:center"><code>w</code></td>
<td style="text-align:center">打开文件以写入，覆盖原文件</td>
<td>创建</td>
</tr>
<tr>
<td style="text-align:center"><code>a</code></td>
<td style="text-align:center">打开写入，追加到文件末尾</td>
<td>创建</td>
</tr>
<tr>
<td style="text-align:center"><code>b</code></td>
<td style="text-align:center">二进制模式，与<code>r</code> <code>w</code>一起使用</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"><code>t</code></td>
<td style="text-align:center">文本模式（默认就有，不用自己写）</td>
<td></td>
</tr>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center">打开文件进行更新（读取和写入）</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="常用方法"><a class="header-anchor" href="#常用方法"></a>常用方法</h3>
<pre><code class="language-python">__file__ # 当前文件的路径（可能为相对路径，取决于python文件执行的方式）
os.path.realpath(__file__) # 获取当前文件的绝对路径
os.path.dirname(os.path.realpath(__file__)) # 获取当前文件所在目录（不包含文件名）
os.path.join(path,&quot;test.yaml&quot;) # 由目录和文件名结合成为新的文件绝对路径
</code></pre>
<h2 id="import-的使用"><a class="header-anchor" href="#import-的使用"></a>import 的使用</h2>
<p>​	一个<code>.py</code>文件可以看作是一个模块（module），使用<code>import</code>命令将一个模块引入当前python文件，则可以在当前文件使用引入模块中定义的变量，函数等。</p>
<pre><code class="language-python">import module_name	#module_name.py文件可以在sys.path中或者当前文件所在文件夹中
import module_name as mod #引入module_name并设置别名为 mod
from module_name import xxx		#从module_name.py中引入xxx变量或者xxx函数
#从系统目录或当前目录的package_name包里找到module_name.py并引入
from package_name import module_name
</code></pre>
<p>一个包（package）是模块或包的集合，其本质是一个含有<code>__init__.py</code>的文件夹，且<code>__init__.py</code>可以为空。</p>
<h2 id="序列化和反序列化"><a class="header-anchor" href="#序列化和反序列化"></a>序列化和反序列化</h2>
<p>序列化</p>
<pre><code class="language-python">import json

dict1 = {&quot;name&quot;:&quot;Dawnyh&quot;, &quot;age&quot;:20, &quot;id&quot;:&quot;2333&quot;}
json_str = json.dumps(dict1) # 将dict1转为json格式的字符串
dict2 = json.loads(json_str) # 把字符串反序列化为一个新的dict

with open(&quot;file1.json&quot;,&quot;w&quot;) as f:
    json.dump(dict1, f) # 序列化后保存到文件
with open(&quot;file1.json&quot;,&quot;w&quot;) as f:
    dict3 = json.load(f) # 从文件反序列化为dict
</code></pre>
<h2 id="HTTP"><a class="header-anchor" href="#HTTP"></a>HTTP</h2>
<h3 id="发起请求"><a class="header-anchor" href="#发起请求"></a>发起请求</h3>
<p>要在python程序中访问外部网站，可以使用<code>requests</code>模块，这是一个功能强大的http请求工具</p>
<pre><code class="language-python">import requests
url = &quot;http://example.com&quot;
#获取响应包
r = requests.get(url)
try:
	#判断相应包状态码，若不为200则抛出异常
	r.raise_for_status()
	#设置编码方式为从内容中分析出的编码方式
	r.encoding = r.apparent_encoding
except:
	print(&quot;error!&quot;)

#获取响应包内容
print(r.text)
</code></pre>
<h3 id="处理请求"><a class="header-anchor" href="#处理请求"></a>处理请求</h3>
<pre><code class="language-python">import socket

HOST,PORT = '0.0.0.0',18080

# 创建socket，AF_INET表示使用IPv4协议，SOCK_STREAM表示采用TCP协议通信
listen_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
# SO_REUSEADDR允许单个进程捆绑同一端口到多个套接字上
listen_socket.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
listen_socket.bind((HOST,PORT)) # 绑定IP和端口
listen_socket.listen(1)
print('Serving HTTP on port %s ...' % PORT)
while True:
	client_connection,client_address = listen_socket.accept()
	request = client_connection.recv(1024)
	# 输出请求内容
    print(request)
	
    # 返回响应内容
	http_response = b&quot;&quot;&quot;
	HTTP/1.1 200 OK\r\n
	\r\n
	Hello,world!
	&quot;&quot;&quot;
	client_connection.send(http_response)
	client_connection.close()
</code></pre>
<h2 id="函数装饰器"><a class="header-anchor" href="#函数装饰器"></a>函数装饰器</h2>
<p>在python中，一切皆对象，包括函数。所以我们可以把函数赋值给变量，也可以把函数作为另一个函数的参数或者返回值，这就是python函数装饰器的基础。python中的装饰器也是一个函数，这个函数的作用是为其他函数增加一些流程或者说行为，也就是装饰。</p>
<p>python函数装饰器常用于权限认证以及记录日志</p>
<h2 id="并发"><a class="header-anchor" href="#并发"></a>并发</h2>
<h3 id="多进程"><a class="header-anchor" href="#多进程"></a>多进程</h3>
<p>考虑到跨平台编程的需求，使用multiprocessing模块中的Process类进行子进程的创建和启动</p>
<pre><code class="language-python">from multiprocessing import Process
from os import getpid
from random import randint
from time import time, sleep


def download_task(filename):
    print('启动下载进程，进程号[%d].' % getpid())
    print('开始下载%s...' % filename)
    time_to_download = randint(5, 10) # 5到10之间的随机整数
    sleep(time_to_download)
    print('%s下载完成! 耗费了%d秒' % (filename, time_to_download))


def main():
    start = time()
    # 创建进程对象p1，执行函数download_task，传入参数('Python从入门到住院.pdf', )
    p1 = Process(target=download_task, args=('Python从入门到住院.pdf', ))
    p1.start() # 启动进程
    p2 = Process(target=download_task, args=('Peking Hot.avi', ))
    p2.start()
    p1.join() # 等待进程执行结束
    p2.join()
    end = time()
    print('总共耗费了%.2f秒.' % (end - start))


if __name__ == '__main__':
    main()
</code></pre>
<p>在多个进程进行同步时，则需要用到进程间通信</p>
<pre><code class="language-python">from multiprocessing import Process,Queue

def print_pingpong(queue,str1):
	while queue.qsize() &lt; 10: # 判断队列中的元素个数
		print(queue.qsize())
		queue.put(1) # 将元素入队列
		# print(str1)
		
def main1():
	queue = Queue(10) # 创建一个队列
    # 把队列作为参数传入
	p1 = Process(target=print_pingpong, args=(queue,'ping', )) 
	p1.start()
	p2 = Process(target=print_pingpong, args=(queue,'pong', ))
	p2.start()
	p1.join()
	p2.join()

if __name__ == '__main__':
    main1()
</code></pre>
<h3 id="多线程"><a class="header-anchor" href="#多线程"></a>多线程</h3>
<p>使用<code>threading</code>模块创建多线程程序，创建线程的方式有从函数启动和从类启动</p>
<p>从函数启动的示例代码如下：</p>
<pre><code class="language-python">import time
from threading import Thread


def sub_task(name:str):
    print(name)
    time.sleep(2)
    print(f'{name} done!')


t1 = Thread(target=sub_task, args=('bob',))
t2 = Thread(target=sub_task, args=('otto',))

t1.start()
t2.start()

t1.join()
t2.join()

print('all done!')
</code></pre>
<p>从类启动的示例代码如下：</p>
<pre><code class="language-python">#!/usr/bin/python3

# 转自：https://www.runoob.com/python3/python3-multithreading.html

import threading
import time

exitFlag = 0

class myThread (threading.Thread):
    def __init__(self, threadID, name, delay):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.delay = delay
    def run(self):
        print (&quot;开始线程：&quot; + self.name)
        print_time(self.name, self.delay, 5)
        print (&quot;退出线程：&quot; + self.name)

def print_time(threadName, delay, counter):
    while counter:
        if exitFlag:
            threadName.exit()
        time.sleep(delay)
        print (&quot;%s: %s&quot; % (threadName, time.ctime(time.time())))
        counter -= 1

# 创建新线程
thread1 = myThread(1, &quot;Thread-1&quot;, 1)
thread2 = myThread(2, &quot;Thread-2&quot;, 2)

# 开启新线程
thread1.start()
thread2.start()
thread1.join()
thread2.join()
print (&quot;退出主线程&quot;)
</code></pre>
<h3 id="协程"><a class="header-anchor" href="#协程"></a>协程</h3>
<p>使用<code>async</code>和<code>await</code>关键字进行声明</p>
<p>例如：</p>
<pre><code class="language-python">async def get_burgers(number: int):# 告诉python这个函数支持异步执行
  # Do some asynchronous stuff to create the burgers
  return burgers

burgers = await get_burgers(2) # 告诉python可以挂起这一步的执行先去执行别的操作
</code></pre>
<p>ps: <code>await</code>必须在使用<code>async def</code>声明的函数中使用</p>
<h2 id="单元测试"><a class="header-anchor" href="#单元测试"></a>单元测试</h2>
<p>对函数进行测试，给他一个输入，验证他的输出是否符合预期</p>
<pre><code class="language-python">import unittest # 导入单元测试模块

# 要测试的函数
def my_div(a, b):
    return a / b

# 测试类
class TestFunc(unittest.TestCase):
    # 测试用例
    def test_div(self):
        self.assertEqual(2, my_div(2,1)) # 判断结果是否等于
        self.assertEqual(-2, my_div(2,-1))
        
    def test_div2(self): # 可以同时测试多个函数
        pass

if __name__ == &quot;__main__&quot;:
    unittest.main()
</code></pre>
<p>在 unittest 的模块中，还有特别丰富的测试方式，常用如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">assert</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">assertEqual(a, b)</td>
<td style="text-align:left"><code>a == b</code></td>
</tr>
<tr>
<td style="text-align:left">assertNotEqual(a, b)</td>
<td style="text-align:left"><code>a != b</code></td>
</tr>
<tr>
<td style="text-align:left">assertTrue(condition)</td>
<td style="text-align:left">condition 是不是 True</td>
</tr>
<tr>
<td style="text-align:left">assertFalse(condition)</td>
<td style="text-align:left">condition 是不是 False</td>
</tr>
<tr>
<td style="text-align:left">assertGreater(a, b)</td>
<td style="text-align:left"><code>a &gt; b</code></td>
</tr>
<tr>
<td style="text-align:left">assertGreaterThan(a, b)</td>
<td style="text-align:left"><code>a &gt;= b</code></td>
</tr>
<tr>
<td style="text-align:left">assertLess(a, b)</td>
<td style="text-align:left"><code>a &lt; b</code></td>
</tr>
<tr>
<td style="text-align:left">assertLessEqual(a, b)</td>
<td style="text-align:left"><code>a &lt;= b</code></td>
</tr>
<tr>
<td style="text-align:left">assertIs(a, b)</td>
<td style="text-align:left"><code>a is b</code>，a 和 b 是不是同一对象</td>
</tr>
<tr>
<td style="text-align:left">assertIsNot(a, b)</td>
<td style="text-align:left"><code>a is not b</code>，a 和 b 是不是不同对象</td>
</tr>
<tr>
<td style="text-align:left">assertIsNone(a)</td>
<td style="text-align:left"><code>a is None</code>，a 是不是 None</td>
</tr>
<tr>
<td style="text-align:left">assertIsNotNone(a)</td>
<td style="text-align:left"><code>a is not None</code>，a 不是 None？</td>
</tr>
<tr>
<td style="text-align:left">assertIn(a, b)</td>
<td style="text-align:left"><code>a in b</code>, a 在 b 里面？</td>
</tr>
<tr>
<td style="text-align:left">assertNotIn(a, b)</td>
<td style="text-align:left"><code>a not in b</code>，a 不在 b 里？</td>
</tr>
<tr>
<td style="text-align:left">assertRaises(err)</td>
<td style="text-align:left">通常和 with 一起用，判断 with 里的功能是否会报错</td>
</tr>
</tbody>
</table>
<h2 id="python3-VS-python2"><a class="header-anchor" href="#python3-VS-python2"></a>python3  VS  python2</h2>
<p><strong>在编码上的区别</strong></p>
<p>​		在 Python2 中，字符串有两个类型，一个是 unicode，一个是 str，前者表示文本字符串，后者表示字节序列，不过两者并没有明显的界限，开发时容易出现编码错误。在 Python3 中对两者做了严格区分，分别用 str 表示字符串，bytes 表示字节序列，任何需要写入文本或者网络传输的数据都只接收字节序列，这就从源头上阻止了编码错误的问题。</p>
<p>​		要指定一个字符串为 bytes 类型，有三种方法：</p>
<ul>
<li>字符串前（引号前）加上前缀<code>b</code> ，但这种方法仅支持 ASCII 字符串；</li>
<li>使用<code>encode()</code>函数</li>
<li>使用<code>bytes()</code>构造函数</li>
</ul>
<pre><code class="language-python">str_a = b&quot;Hello World!&quot;				#正确
str_b = b&quot;一个字符串。&quot;				#错误
str_c = &quot;一个字符串&quot;.encode('utf-8')	#正确，不指定编码方式也默认以utf-8编码
str_d = bytes(&quot;abcde&quot;,'utf-8')		#正确，第二个参数不可省略
</code></pre>
<p>C语言的 printf 函数不支持 Unicode 字符串的输出。在 python3 中想要调用C语言的printf函数，需要将参数由 Unicode 字符串转化为字节序列</p>

        
    </div>
    </div>

    <div class="article-badge">
        
        
    </div>

</div>

<footer class="article-footer">
    <div class="article-more-info">
    <div class="article-date">
  <time datetime="2021-01-29T16:00:00.000Z" itemprop="datePublished">2021-01-30</time>
</div>
    
        <div class="article-category">
        <a class="article-category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
        </div>
    
    
        <div class="article-tag">
        <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/" rel="tag">Python</a></li></ul>
        </div>
    
    </div>
</footer>

</article>

    
  

  
    <nav class="pagination">
        <a class="extend prev" rel="prev" href="/">Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">Next</a>
    </nav>
  
</div>

                </section>
            </section>

            
            <aside class="sidebar ">
                


<div class="widget" id="widget">
    
      
    
      
  <div class="widget-wrap widget-cate">
    <div class="widget-title"><span>Categories</span></div>
    <div class="widget-inner">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CTF/">CTF</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/CTF/web/">web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CTF/%E6%9D%82%E9%A1%B9/">杂项</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/">专业课</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E8%AE%A1%E7%BD%91/">计网</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/Markdown/">Markdown</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/docker/">docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E8%AE%B0/">杂记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B8%97%E9%80%8F/">渗透</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">环境配置</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/go/">go</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BF%90%E7%BB%B4/">运维</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/" rel="tag">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GUI/" rel="tag">GUI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Misc/" rel="tag">Misc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSH/" rel="tag">SSH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XSS/" rel="tag">XSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/" rel="tag">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kafka/" rel="tag">kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kali/" rel="tag">kali</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/" rel="tag">sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sqli/" rel="tag">sqli</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" rel="tag">代码审计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%9E%E9%AA%8C/" rel="tag">实验</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/" rel="tag">密码学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" rel="tag">文件上传</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/" rel="tag">文件包含</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag">消息队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BC%8F%E6%B4%9E/" rel="tag">漏洞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" rel="tag">环境配置</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%90%E7%BB%B4/" rel="tag">运维</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/2022/12/27/%E5%B7%A5%E5%85%B7/redis/">Redis笔记</a>
          </li>
        
          <li>
            <a href="/2022/11/03/%E6%9D%82%E8%AE%B0/%E5%B7%B2%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F%EF%BC%88%E6%9C%8D%E5%8A%A1%EF%BC%89%E7%9A%84%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F/">已安装程序（服务）的运行方式</a>
          </li>
        
          <li>
            <a href="/2022/07/13/%E6%BC%8F%E6%B4%9E/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/">漏洞/Java反序列化漏洞</a>
          </li>
        
          <li>
            <a href="/2021/08/09/%E4%B8%93%E4%B8%9A%E8%AF%BE/%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/">密码算法</a>
          </li>
        
          <li>
            <a href="/2021/07/26/%E5%B7%A5%E5%85%B7/git/">git笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <!-- Please do not remove this -->
    <!-- 开源不易，请勿删除 -->
    <div class="footer-wrap">
        <div class="footer-inner"> 
            Dawnyh&#39;s Blog &copy; 2022<br>
            Powered By Hexo · Theme By <a href="https://linhong.me/" target="_blank">Aomori</a> · <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Github</a>
        </div>
    </div>

</footer>

<script type="module" src="https://unpkg.com/ionicons@6.0.2/dist/ionicons/ionicons.esm.js"></script>






<script src="/dist/build.js?1654266144177.js"></script>


<script src="/dist/custom.js?1654266144177.js"></script>













</body>

</html>